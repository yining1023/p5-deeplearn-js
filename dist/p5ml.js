(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["p5ml"] = factory();
	else
		root["p5ml"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 441);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(27);
var hide = __webpack_require__(15);
var redefine = __webpack_require__(16);
var ctx = __webpack_require__(24);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function shuffle(array) {
    var counter = array.length;
    var temp = 0;
    var index = 0;
    while (counter > 0) {
        index = (Math.random() * counter) | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }
}
exports.shuffle = shuffle;
function clamp(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
exports.clamp = clamp;
function randUniform(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randUniform = randUniform;
function randGauss(mean, stdDev, truncated) {
    if (mean === void 0) { mean = 0; }
    if (stdDev === void 0) { stdDev = 1; }
    if (truncated === void 0) { truncated = false; }
    var v1, v2, s;
    do {
        v1 = 2 * Math.random() - 1;
        v2 = 2 * Math.random() - 1;
        s = v1 * v1 + v2 * v2;
    } while (s > 1);
    var result = Math.sqrt(-2 * Math.log(s) / s) * v1;
    if (truncated && Math.abs(result) > 2) {
        return randGauss(mean, stdDev, true);
    }
    return mean + stdDev * result;
}
exports.randGauss = randGauss;
function distSquared(a, b) {
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        var diff = Number(a[i]) - Number(b[i]);
        result += diff * diff;
    }
    return result;
}
exports.distSquared = distSquared;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(msg);
    }
}
exports.assert = assert;
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + ("Shapes " + shapeA + " and " + shapeB + " must match"));
}
exports.assertShapesMatch = assertShapesMatch;
function flatten(arr, ret) {
    if (ret === void 0) { ret = []; }
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; ++i) {
            flatten(arr[i], ret);
        }
    }
    else {
        ret.push(arr);
    }
    return ret;
}
exports.flatten = flatten;
function inferShape(arr) {
    var shape = [];
    while (arr instanceof Array) {
        shape.push(arr.length);
        arr = arr[0];
    }
    return shape;
}
exports.inferShape = inferShape;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function isScalarShape(shape) {
    return shape.length === 0;
}
exports.isScalarShape = isScalarShape;
function arraysEqual(n1, n2) {
    if (n1.length !== n2.length) {
        return false;
    }
    for (var i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
exports.arraysEqual = arraysEqual;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function tanh(x) {
    if (Math.tanh != null) {
        return Math.tanh(x);
    }
    if (x === Infinity) {
        return 1;
    }
    else if (x === -Infinity) {
        return -1;
    }
    else {
        var e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
exports.tanh = tanh;
function sizeToSquarishShape(size) {
    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
        if (size % a === 0) {
            return [a, size / a];
        }
    }
    return [1, size];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function createShuffledIndices(n) {
    var shuffledIndices = new Uint32Array(n);
    for (var i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
}
exports.createShuffledIndices = createShuffledIndices;
function rightPad(a, size) {
    if (size <= a.length) {
        return a;
    }
    return a + ' '.repeat(size - a.length);
}
exports.rightPad = rightPad;
function repeatedTry(checkFn, delayFn, maxCounter) {
    if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }
    return new Promise(function (resolve, reject) {
        var tryCount = 0;
        var tryFn = function () {
            if (checkFn()) {
                resolve();
                return;
            }
            tryCount++;
            var nextBackoff = delayFn(tryCount);
            if (maxCounter != null && tryCount >= maxCounter) {
                reject();
                return;
            }
            setTimeout(tryFn, nextBackoff);
        };
        setTimeout(tryFn, 0);
    });
}
exports.repeatedTry = repeatedTry;
function getQueryParams(queryString) {
    var params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
        var t = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            t[_i - 1] = arguments[_i];
        }
        decodeParam(params, t[0], t[1]);
        return t.join('=');
    });
    return params;
}
exports.getQueryParams = getQueryParams;
function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || '');
}
function inferFromImplicitShape(shape, size) {
    var shapeProd = 1;
    var implicitIdx = -1;
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] > 0) {
            shapeProd *= shape[i];
        }
        else if (shape[i] === -1) {
            if (implicitIdx !== -1) {
                throw Error("Shapes can only have 1 implicit size. " +
                    ("Found -1 at dim " + implicitIdx + " and dim " + i));
            }
            implicitIdx = i;
        }
        else if (shape[i] <= 0) {
            throw Error("Shapes can not be <= 0. Found " + shape[i] + " at dim " + i);
        }
    }
    if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) {
            throw Error("Size (" + size + ") must match the product of shape " + shape);
        }
        return shape;
    }
    if (size % shapeProd !== 0) {
        throw Error("The implicit shape can't be a fractional number. " +
            ("Got " + size + " / " + shapeProd));
    }
    var newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
}
exports.inferFromImplicitShape = inferFromImplicitShape;
exports.NAN_INT32 = 1 << 31;
exports.NAN_BOOL = 255;
exports.NAN_FLOAT32 = NaN;
function getNaN(dtype) {
    if (dtype === 'float32') {
        return exports.NAN_FLOAT32;
    }
    else if (dtype === 'int32') {
        return exports.NAN_INT32;
    }
    else if (dtype === 'bool') {
        return exports.NAN_BOOL;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.getNaN = getNaN;
function isValNaN(val, dtype) {
    if (dtype === 'float32') {
        return isNaN(val);
    }
    else if (dtype === 'int32') {
        return val === exports.NAN_INT32;
    }
    else if (dtype === 'bool') {
        return val === exports.NAN_BOOL;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.isValNaN = isValNaN;
function squeezeShape(shape) {
    var newShape = [];
    var keptDims = [];
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] > 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape: newShape, keptDims: keptDims };
}
exports.squeezeShape = squeezeShape;
//# sourceMappingURL=util.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = __webpack_require__(32);
var util = __webpack_require__(4);
var tex_util_1 = __webpack_require__(67);
var webgl_util = __webpack_require__(58);
exports.GPGPU = null;
exports.TEXTURE_MANAGER = null;
var DType;
(function (DType) {
    DType["float32"] = "float32";
    DType["int32"] = "int32";
    DType["bool"] = "bool";
})(DType = exports.DType || (exports.DType = {}));
function initializeGPU(gpgpu, textureManager) {
    exports.GPGPU = gpgpu;
    exports.TEXTURE_MANAGER = textureManager;
}
exports.initializeGPU = initializeGPU;
function throwIfGPUNotInitialized() {
    if (exports.GPGPU == null || exports.TEXTURE_MANAGER == null) {
        throw new Error('GPU not intialized.');
    }
}
var NDArray = (function () {
    function NDArray(shape, data, dtype) {
        util.assert(data.values != null || data.texture != null, 'Either `values` or `texture` must be defined');
        util.assert(data.texture == null || (data.textureShapeRC != null), '`textureShape` must be defined when `texture` is defined');
        this.size = util.sizeFromShape(shape);
        if (data.values != null) {
            util.assert(this.size === data.values.length, "Constructing ndarray of shape (" + this.size + ") should match the " +
                ("length of values (" + data.values.length + ")"));
        }
        this.shape = shape;
        if (data.textureType == null) {
            data.textureType = tex_util_1.TextureType.DEFAULT;
        }
        this.ndarrayData = data;
        this.dtype = dtype || 'float32';
        var dim = this.shape.length;
        if (dim < 2) {
            this.strides = [];
        }
        else {
            this.strides = new Array(dim - 1);
            this.strides[dim - 2] = this.shape[dim - 1];
            for (var i = dim - 3; i >= 0; --i) {
                this.strides[i] = this.strides[i + 1] * this.shape[i + 1];
            }
        }
    }
    NDArray.zeros = function (shape, dtype) {
        var values = makeZerosTypedArray(util.sizeFromShape(shape), dtype);
        return NDArray.make(shape, { values: values }, dtype);
    };
    NDArray.zerosLike = function (another) {
        return NDArray.zeros(another.shape, another.dtype);
    };
    NDArray.like = function (another) {
        var newValues = copyTypedArray(another.getValues(), another.dtype);
        return NDArray.make(another.shape, { values: newValues }, another.dtype);
    };
    NDArray.make = function (shape, data, dtype) {
        if (data.isDisposed) {
            throw new Error("Cannot make new NDArray from disposed NDArrayData.");
        }
        switch (shape.length) {
            case 0:
                return new Scalar(data, dtype);
            case 1:
                return new Array1D(data, dtype);
            case 2:
                return new Array2D(shape, data, dtype);
            case 3:
                return new Array3D(shape, data, dtype);
            case 4:
                return new Array4D(shape, data, dtype);
            default:
                return new NDArray(shape, data, dtype);
        }
    };
    NDArray.fromPixels = function (pixels, numChannels) {
        if (numChannels === void 0) { numChannels = 3; }
        if (numChannels > 4) {
            throw new Error('Cannot construct NDArray with more than 4 channels from pixels.');
        }
        var shape = [pixels.height, pixels.width, numChannels];
        var textureShapeRC = [shape[0], shape[1]];
        var texture = exports.TEXTURE_MANAGER.acquireTexture(textureShapeRC);
        var textureType = tex_util_1.TextureType.RGBA_COLOR;
        exports.GPGPU.uploadPixelDataToTexture(texture, pixels);
        return Array3D.make(shape, { texture: texture, textureShapeRC: textureShapeRC, textureType: textureType });
    };
    NDArray.prototype.reshape = function (newShape) {
        this.throwIfDisposed();
        newShape = util.inferFromImplicitShape(newShape, this.size);
        if (util.arraysEqual(this.shape, newShape)) {
            return this;
        }
        util.assert(this.size === util.sizeFromShape(newShape), 'new shape and old shape must have the same number of elements.');
        return NDArray.make(newShape, this.ndarrayData, this.dtype);
    };
    NDArray.prototype.flatten = function () {
        if (this instanceof Array1D) {
            return this;
        }
        return this.as1D();
    };
    NDArray.prototype.asScalar = function () {
        util.assert(this.size === 1, 'The array must have only 1 element.');
        return this.reshape([]);
    };
    NDArray.prototype.as1D = function () {
        return this.reshape([this.size]);
    };
    NDArray.prototype.as2D = function (rows, columns) {
        return this.reshape([rows, columns]);
    };
    NDArray.prototype.as3D = function (rows, columns, depth) {
        return this.reshape([rows, columns, depth]);
    };
    NDArray.prototype.as4D = function (rows, columns, depth, depth2) {
        return this.reshape([rows, columns, depth, depth2]);
    };
    NDArray.prototype.asType = function (dtype) {
        this.throwIfDisposed();
        var newData = this.getData();
        if (newData.values != null) {
            newData = { values: toTypedArray(newData.values, dtype) };
        }
        return NDArray.make(this.shape, newData, dtype);
    };
    Object.defineProperty(NDArray.prototype, "rank", {
        get: function () {
            this.throwIfDisposed();
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    NDArray.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        this.throwIfDisposed();
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.getValues()[index];
    };
    NDArray.prototype.add = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        this.throwIfDisposed();
        this.set.apply(this, [this.get.apply(this, locs) + value].concat(locs));
    };
    NDArray.prototype.set = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        this.throwIfDisposed();
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        this.getValues()[index] = value;
    };
    NDArray.prototype.val = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.throwIfDisposed();
                        return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get.apply(this, locs)];
                }
            });
        });
    };
    NDArray.prototype.locToIndex = function (locs) {
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    NDArray.prototype.indexToLoc = function (index) {
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    NDArray.prototype.fill = function (value) {
        this.throwIfDisposed();
        this.getValues().fill(value);
    };
    NDArray.prototype.getData = function () {
        return this.ndarrayData;
    };
    NDArray.prototype.getValues = function () {
        return this.dataSync();
    };
    NDArray.prototype.getValuesAsync = function () {
        return this.data();
    };
    NDArray.prototype.data = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, queryFn;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.throwIfDisposed();
                        if (this.ndarrayData.values != null) {
                            return [2, this.ndarrayData.values];
                        }
                        if (!(environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') &&
                            this.ndarrayData.textureType === tex_util_1.TextureType.DEFAULT)) return [3, 2];
                        _a = this.ndarrayData;
                        return [4, exports.GPGPU.downloadMatrixFromTextureAsync(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1])];
                    case 1:
                        _a.values = _b.sent();
                        return [2, this.ndarrayData.values];
                    case 2:
                        if (!!environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED')) return [3, 4];
                        return [4, this.dataSync()];
                    case 3: return [2, _b.sent()];
                    case 4:
                        queryFn = function () { };
                        return [4, exports.GPGPU.runQuery(queryFn)];
                    case 5:
                        _b.sent();
                        return [2, this.dataSync()];
                }
            });
        });
    };
    NDArray.prototype.dataSync = function () {
        this.throwIfDisposed();
        if (this.ndarrayData.values == null) {
            throwIfGPUNotInitialized();
            var values = void 0;
            if (this.ndarrayData.textureType === tex_util_1.TextureType.DEFAULT) {
                values = exports.GPGPU.downloadMatrixFromTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1]);
            }
            else {
                values = exports.GPGPU.downloadMatrixFromRGBAColorTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1], this.shape[2]);
            }
            this.ndarrayData.values = float32ToTypedArray(values, this.dtype);
            this.disposeTexture();
        }
        return this.ndarrayData.values;
    };
    NDArray.prototype.uploadToGPU = function () {
        throwIfGPUNotInitialized();
        this.throwIfDisposed();
        this.ndarrayData.textureShapeRC =
            webgl_util.getTextureShapeFromLogicalShape(exports.GPGPU.gl, this.shape);
        this.ndarrayData.texture =
            exports.TEXTURE_MANAGER.acquireTexture(this.ndarrayData.textureShapeRC);
        this.ndarrayData.textureType = tex_util_1.TextureType.DEFAULT;
        exports.GPGPU.uploadMatrixToTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1], typedArrayToFloat32(this.ndarrayData.values, this.dtype));
        this.ndarrayData.values = null;
    };
    NDArray.prototype.getTexture = function () {
        this.throwIfDisposed();
        if (this.ndarrayData.texture == null) {
            this.uploadToGPU();
        }
        return this.ndarrayData.texture;
    };
    NDArray.prototype.getTextureShapeRC = function () {
        this.throwIfDisposed();
        if (this.ndarrayData.textureShapeRC == null) {
            this.uploadToGPU();
        }
        return this.ndarrayData.textureShapeRC;
    };
    NDArray.prototype.throwIfDisposed = function () {
        if (this.ndarrayData.isDisposed) {
            throw new Error("NDArray is disposed.");
        }
    };
    NDArray.prototype.dispose = function () {
        this.ndarrayData.values = null;
        this.shape = null;
        this.ndarrayData.isDisposed = true;
        if (this.ndarrayData.texture != null) {
            this.disposeTexture();
        }
    };
    NDArray.prototype.disposeTexture = function () {
        throwIfGPUNotInitialized();
        exports.TEXTURE_MANAGER.releaseTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC);
        this.ndarrayData.texture = null;
        this.ndarrayData.textureShapeRC = null;
        this.ndarrayData.textureType = null;
    };
    NDArray.prototype.inGPU = function () {
        this.throwIfDisposed();
        return this.ndarrayData.texture != null;
    };
    NDArray.prototype.equals = function (t) {
        this.throwIfDisposed();
        return this.dtype === t.dtype && util.arraysEqual(this.shape, t.shape) &&
            util.arraysEqual(this.getValues(), t.getValues());
    };
    NDArray.rand = function (shape, randFunction) {
        var size = util.sizeFromShape(shape);
        var values = new Float32Array(size);
        for (var i = 0; i < size; i++) {
            values[i] = randFunction();
        }
        return NDArray.make(shape, { values: values });
    };
    NDArray.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    NDArray.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    NDArray.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return NDArray;
}());
exports.NDArray = NDArray;
var Scalar = (function (_super) {
    __extends(Scalar, _super);
    function Scalar(data, dtype) {
        var _this = this;
        if (data.texture != null) {
            data.textureShapeRC = [1, 1];
        }
        _this = _super.call(this, [], data, dtype) || this;
        return _this;
    }
    Scalar.new = function (value, dtype) {
        var values = [value];
        return new Scalar({ values: toTypedArray(values, dtype) }, dtype);
    };
    Scalar.prototype.get = function () {
        return this.getValues()[0];
    };
    Scalar.prototype.val = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get()];
                }
            });
        });
    };
    Scalar.prototype.set = function (value) {
        this.getValues()[0] = value;
    };
    Scalar.prototype.add = function (value) {
        this.getValues()[0] += value;
    };
    Scalar.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Scalar.prototype.locToIndex = function (loc) {
        return 0;
    };
    Scalar.prototype.indexToLoc = function (index) {
        return [];
    };
    Scalar.ZERO = Scalar.new(0);
    Scalar.ONE = Scalar.new(1);
    Scalar.TWO = Scalar.new(2);
    Scalar.NEG_ONE = Scalar.new(-1);
    return Scalar;
}(NDArray));
exports.Scalar = Scalar;
var Array1D = (function (_super) {
    __extends(Array1D, _super);
    function Array1D(data, dtype) {
        var _this = this;
        var shape = (data.values != null) ?
            [data.values.length] :
            [util.sizeFromShape(data.textureShapeRC)];
        _this = _super.call(this, shape, data, dtype) || this;
        return _this;
    }
    Array1D.new = function (values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            util.assert(inferredShape.length === 1, "Error constructing Array1D. Shape of values " + inferredShape + " is " +
                "not 1 dimensional.");
        }
        return new Array1D({ values: toTypedArray(values, dtype) }, dtype);
    };
    Array1D.prototype.get = function (i) {
        return this.getValues()[i];
    };
    Array1D.prototype.set = function (value, i) {
        this.getValues()[i] = value;
    };
    Array1D.prototype.val = function (i) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i)];
                }
            });
        });
    };
    Array1D.prototype.add = function (value, i) {
        this.getValues()[i] += value;
    };
    Array1D.prototype.locToIndex = function (loc) {
        return loc[0];
    };
    Array1D.prototype.indexToLoc = function (index) {
        return [index];
    };
    Array1D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array1D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array1D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array1D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array1D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array1D;
}(NDArray));
exports.Array1D = Array1D;
var Array2D = (function (_super) {
    __extends(Array2D, _super);
    function Array2D(shape, data, dtype) {
        var _this = this;
        util.assert(shape.length === 2, 'Shape should be of length 2');
        _this = _super.call(this, shape, data, dtype) || this;
        _this.stride0 = _this.strides[0];
        return _this;
    }
    Array2D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array2D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array2D(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    Array2D.prototype.get = function (i, j) {
        return this.getValues()[this.stride0 * i + j];
    };
    Array2D.prototype.set = function (value, i, j) {
        this.getValues()[this.stride0 * i + j] = value;
    };
    Array2D.prototype.add = function (value, i, j) {
        this.getValues()[this.stride0 * i + j] += value;
    };
    Array2D.prototype.val = function (i, j) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i, j)];
                }
            });
        });
    };
    Array2D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + locs[1];
    };
    Array2D.prototype.indexToLoc = function (index) {
        return [Math.floor(index / this.stride0), index % this.stride0];
    };
    Array2D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array2D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array2D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array2D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array2D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array2D;
}(NDArray));
exports.Array2D = Array2D;
var Array3D = (function (_super) {
    __extends(Array3D, _super);
    function Array3D(shape, data, dtype) {
        var _this = this;
        util.assert(shape.length === 3, 'Shape should be of length 3');
        _this = _super.call(this, shape, data, dtype) || this;
        _this.stride0 = _this.strides[0];
        _this.stride1 = _this.strides[1];
        return _this;
    }
    Array3D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array3D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array3D(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    Array3D.prototype.get = function (i, j, k) {
        return this.getValues()[this.stride0 * i + this.stride1 * j + k];
    };
    Array3D.prototype.set = function (value, i, j, k) {
        this.getValues()[this.stride0 * i + this.stride1 * j + k] = value;
    };
    Array3D.prototype.val = function (i, j, k) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i, j, k)];
                }
            });
        });
    };
    Array3D.prototype.add = function (value, i, j, k) {
        this.getValues()[this.stride0 * i + this.stride1 * j + k] += value;
    };
    Array3D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + this.stride1 * locs[1] + locs[2];
    };
    Array3D.prototype.indexToLoc = function (index) {
        var i = Math.floor(index / this.stride0);
        index -= i * this.stride0;
        return [i, Math.floor(index / this.stride1), index % this.stride1];
    };
    Array3D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array3D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array3D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array3D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array3D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array3D;
}(NDArray));
exports.Array3D = Array3D;
var Array4D = (function (_super) {
    __extends(Array4D, _super);
    function Array4D(shape, data, dtype) {
        var _this = this;
        util.assert(shape.length === 4, 'Shape should be of length 4');
        _this = _super.call(this, shape, data, dtype) || this;
        _this.stride0 = _this.strides[0];
        _this.stride1 = _this.strides[1];
        _this.stride2 = _this.strides[2];
        return _this;
    }
    Array4D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array4D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array4D(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    Array4D.prototype.get = function (i, j, k, l) {
        return this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l];
    };
    Array4D.prototype.set = function (value, i, j, k, l) {
        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] = value;
    };
    Array4D.prototype.val = function (i, j, k, l) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i, j, k, l)];
                }
            });
        });
    };
    Array4D.prototype.add = function (value, i, j, k, l) {
        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] += value;
    };
    Array4D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + this.stride1 * locs[1] +
            this.stride2 * locs[2] + locs[3];
    };
    Array4D.prototype.indexToLoc = function (index) {
        var i = Math.floor(index / this.stride0);
        index -= i * this.stride0;
        var j = Math.floor(index / this.stride1);
        index -= j * this.stride1;
        return [i, j, Math.floor(index / this.stride2), index % this.stride2];
    };
    Array4D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array4D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array4D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array4D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array4D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array4D;
}(NDArray));
exports.Array4D = Array4D;
function copyTypedArray(array, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(array);
    }
    else if (dtype === 'int32') {
        return new Int32Array(array);
    }
    else if (dtype === 'bool') {
        var bool = new Uint8Array(array.length);
        for (var i = 0; i < bool.length; ++i) {
            var val = array[i];
            if (util.isValNaN(val, 'bool')) {
                bool[i] = util.getNaN('bool');
            }
            else if (val) {
                bool[i] = 1;
            }
        }
        return bool;
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
function instanceofTypedArray(a) {
    return a instanceof Float32Array || a instanceof Int32Array ||
        a instanceof Uint8Array;
}
function noConversionNeeded(a, dtype) {
    return (a instanceof Float32Array && dtype === 'float32') ||
        (a instanceof Int32Array && dtype === 'int32') ||
        (a instanceof Uint8Array && dtype === 'bool');
}
function toTypedArray(a, dtype) {
    if (noConversionNeeded(a, dtype)) {
        return a;
    }
    if (Array.isArray(a)) {
        a = util.flatten(a);
    }
    return copyTypedArray(a, dtype);
}
function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(size);
    }
    else if (dtype === 'int32') {
        return new Int32Array(size);
    }
    else if (dtype === 'bool') {
        return new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
function typedArrayToFloat32(a, dtype) {
    if (a instanceof Float32Array) {
        return a;
    }
    else {
        var res = new Float32Array(a.length);
        for (var i = 0; i < res.length; i++) {
            var val = a[i];
            res[i] = util.isValNaN(val, dtype) ? NaN : val;
        }
        return res;
    }
}
function float32ToTypedArray(a, dtype) {
    if (dtype === 'float32') {
        return a;
    }
    else if (dtype === 'int32' || dtype === 'bool') {
        var result = (dtype === 'int32') ? new Int32Array(a.length) :
            new Uint8Array(a.length);
        for (var i = 0; i < result.length; ++i) {
            var val = a[i];
            val = isNaN(val) ? util.getNaN(dtype) : Math.round(val);
            result[i] = val;
        }
        return result;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
//# sourceMappingURL=ndarray.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(80)('wks');
var uid = __webpack_require__(49);
var Symbol = __webpack_require__(2).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(3)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var IE8_DOM_DEFINE = __webpack_require__(121);
var toPrimitive = __webpack_require__(31);
var dP = Object.defineProperty;

exports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(30);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(28);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Operation = (function () {
    function Operation() {
    }
    Operation.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) { };
    Operation.prototype.dispose = function () { };
    return Operation;
}());
exports.Operation = Operation;
//# sourceMappingURL=op.js.map

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(9);
var createDesc = __webpack_require__(45);
module.exports = __webpack_require__(8) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(15);
var has = __webpack_require__(14);
var SRC = __webpack_require__(49)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(27).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var fails = __webpack_require__(3);
var defined = __webpack_require__(28);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(63);
var createDesc = __webpack_require__(45);
var toIObject = __webpack_require__(20);
var toPrimitive = __webpack_require__(31);
var has = __webpack_require__(14);
var IE8_DOM_DEFINE = __webpack_require__(121);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(14);
var toObject = __webpack_require__(11);
var IE_PROTO = __webpack_require__(99)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(62);
var defined = __webpack_require__(28);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = __webpack_require__(64);
var priority_queue = __webpack_require__(149);
var priority_queue_1 = __webpack_require__(149);
function getUnorderedEvaluationSet(nodes, terminatingNodes) {
    var terminatingNodeMap = {};
    var seen = {};
    var set = [];
    var visit = nodes.slice();
    terminatingNodes.forEach(function (node) { return terminatingNodeMap[node.id] = node; });
    var _loop_1 = function () {
        var cur = visit.pop();
        if (seen[cur.id] == null) {
            if (terminatingNodeMap[cur.id] == null) {
                Object.keys(cur.inputs)
                    .map(function (inputName) { return cur.inputs[inputName]; })
                    .forEach(function (input) { return visit.push(input.node); });
            }
            set.push(cur);
            seen[cur.id] = cur;
        }
    };
    while (visit.length !== 0) {
        _loop_1();
    }
    return set;
}
exports.getUnorderedEvaluationSet = getUnorderedEvaluationSet;
function getOrderedEvaluationSet(unorderedEvaluationSet) {
    var set = [];
    var nodeIndices = {};
    var pendingDependencies = {};
    var nodeQueue = new priority_queue_1.PriorityQueue(function (a, b) { return priority_queue.defaultCompare(pendingDependencies[a.id], pendingDependencies[b.id]); }, function (node, newIndex) { return nodeIndices[node.id] = newIndex; });
    unorderedEvaluationSet.forEach(function (node) { return pendingDependencies[node.id] = 0; });
    unorderedEvaluationSet.forEach(function (node) { return Object.keys(node.inputs)
        .map(function (key) { return node.inputs[key]; })
        .forEach(function (input) {
        if (unorderedEvaluationSet.indexOf(input.node) !== -1) {
            pendingDependencies[input.node.id]++;
        }
    }); });
    unorderedEvaluationSet.forEach(function (node) { return nodeQueue.enqueue(node); });
    while (!nodeQueue.empty()) {
        set.unshift(nodeQueue.dequeue());
        Object.keys(set[0].inputs).map(function (key) { return set[0].inputs[key]; }).forEach(function (input) {
            if (unorderedEvaluationSet.indexOf(input.node) === -1) {
                return;
            }
            pendingDependencies[input.node.id]--;
            nodeQueue.update(input.node, nodeIndices[input.node.id]);
        });
    }
    return set;
}
exports.getOrderedEvaluationSet = getOrderedEvaluationSet;
function isInputNode(node) {
    return Object.keys(node.inputs).length === 0;
}
exports.isInputNode = isInputNode;
function shouldBackProp(t) {
    return !(t.node instanceof graph_1.ConstantNode);
}
exports.shouldBackProp = shouldBackProp;
function isPassthroughNode(node, map) {
    var keys = Object.keys(node.inputs);
    for (var i = 0; i < keys.length; i++) {
        var input = node.inputs[keys[i]];
        if (map.get(input, true) === map.get(node.output, true)) {
            return true;
        }
    }
    return false;
}
exports.isPassthroughNode = isPassthroughNode;
//# sourceMappingURL=graph_util.js.map

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),
/* 23 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(13);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(3);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(24);
var IObject = __webpack_require__(62);
var toObject = __webpack_require__(11);
var toLength = __webpack_require__(10);
var asc = __webpack_require__(84);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 28 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0);
var core = __webpack_require__(27);
var fails = __webpack_require__(3);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 30 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(5);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var device_util = __webpack_require__(377);
var util = __webpack_require__(4);
var Type;
(function (Type) {
    Type[Type["NUMBER"] = 0] = "NUMBER";
    Type[Type["BOOLEAN"] = 1] = "BOOLEAN";
})(Type = exports.Type || (exports.Type = {}));
exports.URL_PROPERTIES = [
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED', type: Type.BOOLEAN },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: Type.BOOLEAN },
    { name: 'WEBGL_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_FLOAT_TEXTURE_ENABLED', type: Type.BOOLEAN }, {
        name: 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED',
        type: Type.BOOLEAN
    }
];
function getWebGLRenderingContext(webGLVersion) {
    if (webGLVersion === 0) {
        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
    }
    var tempCanvas = document.createElement('canvas');
    if (webGLVersion === 1) {
        return (tempCanvas.getContext('webgl') ||
            tempCanvas.getContext('experimental-webgl'));
    }
    return tempCanvas.getContext('webgl2');
}
function loseContext(gl) {
    if (gl != null) {
        var loseContextExtension = gl.getExtension('WEBGL_lose_context');
        if (loseContextExtension == null) {
            throw new Error('Extension WEBGL_lose_context not supported on this browser.');
        }
        loseContextExtension.loseContext();
    }
}
function isWebGLVersionEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    if (gl != null) {
        loseContext(gl);
        return true;
    }
    return false;
}
function isWebGLDisjointQueryTimerEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    var extensionName = webGLVersion === 1 ? 'EXT_disjoint_timer_query' :
        'EXT_disjoint_timer_query_webgl2';
    var ext = gl.getExtension(extensionName);
    var isExtEnabled = ext != null;
    if (gl != null) {
        loseContext(gl);
    }
    return isExtEnabled;
}
function isFloatTextureReadPixelsEnabled(webGLVersion) {
    if (webGLVersion === 0) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    if (webGLVersion === 1) {
        if (gl.getExtension('OES_texture_float') == null) {
            return false;
        }
    }
    else {
        if (gl.getExtension('EXT_color_buffer_float') == null) {
            return false;
        }
    }
    var frameBuffer = gl.createFramebuffer();
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var frameBufferComplete = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));
    var readPixelsNoError = gl.getError() === gl.NO_ERROR;
    loseContext(gl);
    return frameBufferComplete && readPixelsNoError;
}
function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {
    if (webGLVersion !== 2) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    var ext = gl.getExtension('WEBGL_get_buffer_sub_data_async');
    var isEnabled = ext != null;
    loseContext(gl);
    return isEnabled;
}
var Environment = (function () {
    function Environment(features) {
        this.features = {};
        if (features != null) {
            this.features = features;
        }
    }
    Environment.prototype.get = function (feature) {
        if (feature in this.features) {
            return this.features[feature];
        }
        this.features[feature] = this.evaluateFeature(feature);
        return this.features[feature];
    };
    Environment.prototype.evaluateFeature = function (feature) {
        if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') {
            var webGLVersion = this.get('WEBGL_VERSION');
            if (webGLVersion === 0) {
                return false;
            }
            return isWebGLDisjointQueryTimerEnabled(webGLVersion);
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {
            return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') &&
                !device_util.isMobile();
        }
        else if (feature === 'WEBGL_VERSION') {
            if (isWebGLVersionEnabled(2)) {
                return 2;
            }
            else if (isWebGLVersionEnabled(1)) {
                return 1;
            }
            return 0;
        }
        else if (feature === 'WEBGL_FLOAT_TEXTURE_ENABLED') {
            return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));
        }
        else if (feature === 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') {
            return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get('WEBGL_VERSION'));
        }
        throw new Error("Unknown feature " + feature + ".");
    };
    return Environment;
}());
exports.Environment = Environment;
var DEEPLEARNJS_FLAGS_PREFIX = 'dljsflags';
function getFeaturesFromURL() {
    var features = {};
    if (typeof window === 'undefined') {
        return features;
    }
    var urlParams = util.getQueryParams(window.location.search);
    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {
        var urlFlags_1 = {};
        var keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split(',');
        keyValues.forEach(function (keyValue) {
            var _a = keyValue.split(':'), key = _a[0], value = _a[1];
            urlFlags_1[key] = value;
        });
        exports.URL_PROPERTIES.forEach(function (urlProperty) {
            if (urlProperty.name in urlFlags_1) {
                console.log("Setting feature override from URL " + urlProperty.name + ": " +
                    ("" + urlFlags_1[urlProperty.name]));
                if (urlProperty.type === Type.NUMBER) {
                    features[urlProperty.name] = +urlFlags_1[urlProperty.name];
                }
                else if (urlProperty.type === Type.BOOLEAN) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';
                }
                else {
                    console.warn("Unknown URL param: " + urlProperty.name + ".");
                }
            }
        });
    }
    return features;
}
exports.ENV = new Environment(getFeaturesFromURL());
function setEnvironment(environment) {
    exports.ENV = environment;
}
exports.setEnvironment = setEnvironment;
//# sourceMappingURL=environment.js.map

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(142);
var $export = __webpack_require__(0);
var shared = __webpack_require__(80)('metadata');
var store = shared.store || (shared.store = new (__webpack_require__(145))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(8)) {
  var LIBRARY = __webpack_require__(41);
  var global = __webpack_require__(2);
  var fails = __webpack_require__(3);
  var $export = __webpack_require__(0);
  var $typed = __webpack_require__(82);
  var $buffer = __webpack_require__(105);
  var ctx = __webpack_require__(24);
  var anInstance = __webpack_require__(39);
  var propertyDesc = __webpack_require__(45);
  var hide = __webpack_require__(15);
  var redefineAll = __webpack_require__(46);
  var toInteger = __webpack_require__(30);
  var toLength = __webpack_require__(10);
  var toIndex = __webpack_require__(140);
  var toAbsoluteIndex = __webpack_require__(48);
  var toPrimitive = __webpack_require__(31);
  var has = __webpack_require__(14);
  var classof = __webpack_require__(61);
  var isObject = __webpack_require__(5);
  var toObject = __webpack_require__(11);
  var isArrayIter = __webpack_require__(91);
  var create = __webpack_require__(42);
  var getPrototypeOf = __webpack_require__(19);
  var gOPN = __webpack_require__(43).f;
  var getIterFn = __webpack_require__(107);
  var uid = __webpack_require__(49);
  var wks = __webpack_require__(7);
  var createArrayMethod = __webpack_require__(26);
  var createArrayIncludes = __webpack_require__(69);
  var speciesConstructor = __webpack_require__(81);
  var ArrayIterators = __webpack_require__(108);
  var Iterators = __webpack_require__(52);
  var $iterDetect = __webpack_require__(75);
  var setSpecies = __webpack_require__(47);
  var arrayFill = __webpack_require__(83);
  var arrayCopyWithin = __webpack_require__(113);
  var $DP = __webpack_require__(9);
  var $GOPD = __webpack_require__(18);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TensorArrayMapBase = (function () {
    function TensorArrayMapBase() {
        this.dict = {};
    }
    TensorArrayMapBase.prototype.get = function (tensor, skipChecks) {
        if (skipChecks === void 0) { skipChecks = false; }
        if (!skipChecks && this.dict[tensor.id] === undefined) {
            throw new Error("tensor " + tensor.id + " not in array map.");
        }
        var nda = this.dict[tensor.id];
        if (!skipChecks && nda === null) {
            throw new Error("tensor " + tensor.id + " has null array.");
        }
        return nda;
    };
    TensorArrayMapBase.prototype.delete = function (tensor) {
        delete this.dict[tensor.id];
    };
    TensorArrayMapBase.prototype.nullify = function (tensor) {
        this.dict[tensor.id] = null;
    };
    TensorArrayMapBase.prototype.disposeArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            return;
        }
        var nda = this.dict[tensor.id];
        if (nda === null) {
            return;
        }
        nda.dispose();
        this.dict[tensor.id] = null;
    };
    TensorArrayMapBase.prototype.size = function () {
        return Object.keys(this.dict).length;
    };
    TensorArrayMapBase.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.dict).forEach(function (tensorID) {
            var nda = _this.dict[+tensorID];
            if (nda) {
                nda.dispose();
            }
        });
        this.dict = {};
    };
    TensorArrayMapBase.prototype.hasNullArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            throw new Error("tensor " + tensor.id + " not in array map.");
        }
        return this.dict[tensor.id] === null;
    };
    return TensorArrayMapBase;
}());
exports.TensorArrayMapBase = TensorArrayMapBase;
var TensorArrayMap = (function (_super) {
    __extends(TensorArrayMap, _super);
    function TensorArrayMap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TensorArrayMap.prototype.set = function (tensor, array) {
        this.dict[tensor.id] = array;
    };
    return TensorArrayMap;
}(TensorArrayMapBase));
exports.TensorArrayMap = TensorArrayMap;
var SummedTensorArrayMap = (function (_super) {
    __extends(SummedTensorArrayMap, _super);
    function SummedTensorArrayMap(math) {
        var _this = _super.call(this) || this;
        _this.math = math;
        return _this;
    }
    SummedTensorArrayMap.prototype.add = function (tensor, array) {
        if (this.dict[tensor.id] == null) {
            this.dict[tensor.id] = this.math.keep(array);
        }
        else {
            var oldValue = this.get(tensor);
            var newValue = this.math.keep(this.math.addStrict(oldValue, array));
            this.dict[tensor.id] = newValue;
            oldValue.dispose();
        }
    };
    return SummedTensorArrayMap;
}(TensorArrayMapBase));
exports.SummedTensorArrayMap = SummedTensorArrayMap;
//# sourceMappingURL=tensor_array_map.js.map

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(7)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(15)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(49)('meta');
var isObject = __webpack_require__(5);
var has = __webpack_require__(14);
var setDesc = __webpack_require__(9).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(3)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xhr_dataset = __webpack_require__(147);
exports.xhr_dataset = xhr_dataset;
var environment = __webpack_require__(32);
exports.environment = environment;
var conv_util = __webpack_require__(51);
exports.conv_util = conv_util;
var gpgpu_util = __webpack_require__(110);
exports.gpgpu_util = gpgpu_util;
var render_ndarray_gpu_util = __webpack_require__(424);
exports.render_ndarray_gpu_util = render_ndarray_gpu_util;
var webgl_util = __webpack_require__(58);
exports.webgl_util = webgl_util;
var test_util = __webpack_require__(430);
exports.test_util = test_util;
var util = __webpack_require__(4);
exports.util = util;
var version_1 = __webpack_require__(431);
exports.version = version_1.version;
var checkpoint_loader_1 = __webpack_require__(375);
exports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;
var dataset_1 = __webpack_require__(146);
exports.InMemoryDataset = dataset_1.InMemoryDataset;
var input_provider_1 = __webpack_require__(376);
exports.InCPUMemoryShuffledInputProviderBuilder = input_provider_1.InCPUMemoryShuffledInputProviderBuilder;
exports.InGPUMemoryShuffledInputProviderBuilder = input_provider_1.InGPUMemoryShuffledInputProviderBuilder;
var xhr_dataset_1 = __webpack_require__(147);
exports.XhrDataset = xhr_dataset_1.XhrDataset;
var environment_1 = __webpack_require__(32);
exports.ENV = environment_1.ENV;
exports.Environment = environment_1.Environment;
var graph_1 = __webpack_require__(64);
exports.Graph = graph_1.Graph;
exports.Tensor = graph_1.Tensor;
var adadelta_optimizer_1 = __webpack_require__(397);
exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
var adagrad_optimizer_1 = __webpack_require__(398);
exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
var adam_optimizer_1 = __webpack_require__(399);
exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
var adamax_optimizer_1 = __webpack_require__(400);
exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
var momentum_optimizer_1 = __webpack_require__(401);
exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
var optimizer_1 = __webpack_require__(50);
exports.Optimizer = optimizer_1.Optimizer;
var rmsprop_optimizer_1 = __webpack_require__(402);
exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
var sgd_optimizer_1 = __webpack_require__(148);
exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
var session_1 = __webpack_require__(150);
exports.CostReduction = session_1.CostReduction;
exports.Session = session_1.Session;
var graph_runner_1 = __webpack_require__(403);
exports.GraphRunner = graph_runner_1.GraphRunner;
exports.MetricReduction = graph_runner_1.MetricReduction;
var initializers_1 = __webpack_require__(152);
exports.ConstantInitializer = initializers_1.ConstantInitializer;
exports.NDArrayInitializer = initializers_1.NDArrayInitializer;
exports.OnesInitializer = initializers_1.OnesInitializer;
exports.RandomNormalInitializer = initializers_1.RandomNormalInitializer;
exports.RandomTruncatedNormalInitializer = initializers_1.RandomTruncatedNormalInitializer;
exports.RandomUniformInitializer = initializers_1.RandomUniformInitializer;
exports.VarianceScalingInitializer = initializers_1.VarianceScalingInitializer;
exports.ZerosInitializer = initializers_1.ZerosInitializer;
var math_1 = __webpack_require__(57);
exports.MatrixOrientation = math_1.MatrixOrientation;
exports.NDArrayMath = math_1.NDArrayMath;
var math_cpu_1 = __webpack_require__(154);
exports.NDArrayMathCPU = math_cpu_1.NDArrayMathCPU;
var math_gpu_1 = __webpack_require__(155);
exports.NDArrayMathGPU = math_gpu_1.NDArrayMathGPU;
var ndarray_1 = __webpack_require__(6);
exports.initializeGPU = ndarray_1.initializeGPU;
var ndarray_2 = __webpack_require__(6);
exports.Array1D = ndarray_2.Array1D;
exports.Array2D = ndarray_2.Array2D;
exports.Array3D = ndarray_2.Array3D;
exports.Array4D = ndarray_2.Array4D;
exports.NDArray = ndarray_2.NDArray;
exports.Scalar = ndarray_2.Scalar;
var gpgpu_context_1 = __webpack_require__(157);
exports.GPGPUContext = gpgpu_context_1.GPGPUContext;
//# sourceMappingURL=index.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(24);
var call = __webpack_require__(124);
var isArrayIter = __webpack_require__(91);
var anObject = __webpack_require__(1);
var toLength = __webpack_require__(10);
var getIterFn = __webpack_require__(107);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(1);
var dPs = __webpack_require__(130);
var enumBugKeys = __webpack_require__(87);
var IE_PROTO = __webpack_require__(99)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(86)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(89).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(132);
var hiddenKeys = __webpack_require__(87).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(132);
var enumBugKeys = __webpack_require__(87);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(16);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var dP = __webpack_require__(9);
var DESCRIPTORS = __webpack_require__(8);
var SPECIES = __webpack_require__(7)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(30);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 49 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var session_util = __webpack_require__(151);
var tensor_array_map_1 = __webpack_require__(35);
var Optimizer = (function () {
    function Optimizer(learningRate, specifiedVariableList) {
        this.learningRate = learningRate;
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
        this.one = ndarray_1.Scalar.new(1);
        if (specifiedVariableList != null) {
            this.specifiedVariableNodes = specifiedVariableList;
        }
    }
    Optimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        this.variableNodes = this.specifiedVariableNodes == null ?
            session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :
            this.specifiedVariableNodes;
        if (batchSize !== this.prevBatchSize) {
            if (this.c != null) {
                this.c.dispose();
            }
            this.prevBatchSize = batchSize;
            this.c = ndarray_1.Scalar.new(-this.learningRate / batchSize);
        }
        this.variableNodes.forEach(function (node) { return _this.variableGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape)); });
    };
    Optimizer.prototype.afterExample = function (math, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var gradient = gradientArrayMap.get(node.output);
                var accumulatedGradient = _this.variableGradients.get(node.output);
                _this.variableGradients.set(node.output, keep(math.add(gradient, accumulatedGradient)));
                accumulatedGradient.dispose();
            });
        });
    };
    Optimizer.prototype.dispose = function () {
        if (this.c != null) {
            this.c.dispose();
        }
        this.one.dispose();
    };
    return Optimizer;
}());
exports.Optimizer = Optimizer;
//# sourceMappingURL=optimizer.js.map

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util = __webpack_require__(4);
function computeDepthwiseConv2DInfo(inShape, filterShape, strides, pad) {
    var filterHeight = filterShape[0], filterWidth = filterShape[1], inChannels = filterShape[2], channelMul = filterShape[3];
    var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
    var inHeight = inShape[1];
    var inWidth = inShape[2];
    var batchSize = inShape[0];
    var _b = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth), padInfo = _b.padInfo, outHeight = _b.outHeight, outWidth = _b.outWidth;
    var outChannels = inChannels * channelMul;
    var outShape = [batchSize, outHeight, outWidth, outChannels];
    return {
        inShape: inShape,
        outShape: outShape,
        channelMul: channelMul,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth,
        padInfo: padInfo
    };
}
exports.computeDepthwiseConv2DInfo = computeDepthwiseConv2DInfo;
function computeConv2DInfo(inShape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad) {
    var inHeight = inShape[0];
    var inWidth = inShape[1];
    var _a = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth), padInfo = _a.padInfo, outHeight = _a.outHeight, outWidth = _a.outWidth;
    var outShape = [outHeight, outWidth, outDepth];
    return {
        inShape: inShape,
        outShape: outShape,
        padInfo: padInfo,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth
    };
}
exports.computeConv2DInfo = computeConv2DInfo;
function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    var inputRows = inShape[0];
    var inputCols = inShape[1];
    var outputRows = (inputRows - fieldSize + 2 * zeroPad) / stride + 1;
    util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
        "stride and/or zero pad parameters");
    var outputCols = (inputCols - fieldSize + 2 * zeroPad) / stride + 1;
    util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
        "the stride and/or zero pad parameters");
    return [outputRows, outputCols, outDepth];
}
exports.computeOutputShape3D = computeOutputShape3D;
function computeDefaultPad(inputShape, fieldSize, stride) {
    return Math.floor((inputShape[0] * (stride - 1) - stride + fieldSize) / 2);
}
exports.computeDefaultPad = computeDefaultPad;
function computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth) {
    return [filterHeight, filterWidth, inputDepth, outputDepth];
}
exports.computeWeightsShape4D = computeWeightsShape4D;
function computeDilatedRC(rc, origStride) {
    var rowsDilated = (rc[0] - 1) * origStride + 1;
    var colsDilated = (rc[1] - 1) * origStride + 1;
    return [rowsDilated, colsDilated];
}
exports.computeDilatedRC = computeDilatedRC;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth) {
    var padInfo;
    var outHeight;
    var outWidth;
    if (typeof pad === 'number') {
        padInfo = { top: pad, bottom: pad, left: pad, right: pad };
        var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad);
        outHeight = outShape[0];
        outWidth = outShape[1];
    }
    else if (pad === 'same') {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        var top_1 = Math.floor(padAlongHeight / 2);
        var bottom = padAlongHeight - top_1;
        var left = Math.floor(padAlongWidth / 2);
        var right = padAlongWidth - left;
        padInfo = { top: top_1, bottom: bottom, left: left, right: right };
    }
    else if (pad === 'valid') {
        padInfo = { top: 0, bottom: 0, left: 0, right: 0 };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    }
    else {
        throw Error("Unknown padding parameter: " + pad);
    }
    return { padInfo: padInfo, outHeight: outHeight, outWidth: outWidth };
}
//# sourceMappingURL=conv_util.js.map

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(9).f;
var has = __webpack_require__(14);
var TAG = __webpack_require__(7)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var defined = __webpack_require__(28);
var fails = __webpack_require__(3);
var spaces = __webpack_require__(103);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getBroadcastDims(inShape, outShape) {
    var inRank = inShape.length;
    var dims = [];
    for (var i = 0; i < inRank; i++) {
        var dim = inRank - 1 - i;
        var a = inShape[dim] || 1;
        var b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
            dims.unshift(dim);
        }
    }
    return dims;
}
exports.getBroadcastDims = getBroadcastDims;
function broadcastDimsAreOuter(dims) {
    for (var i = 0; i < dims.length; i++) {
        if (dims[i] !== i) {
            return false;
        }
    }
    return true;
}
exports.broadcastDimsAreOuter = broadcastDimsAreOuter;
function assertAndGetBroadcastShape(shapeA, shapeB) {
    var result = [];
    var errMsg = "Operands could not be broadcast together with shapes " +
        (shapeA + " and " + shapeB + ".");
    var l = Math.max(shapeA.length, shapeB.length);
    for (var i = 0; i < l; i++) {
        var a = shapeA[shapeA.length - i - 1] || 1;
        var b = shapeB[shapeB.length - i - 1] || 1;
        if (a > 1 && b > 1 && a !== b) {
            throw Error(errMsg);
        }
        result.unshift(Math.max(a, b));
    }
    return result;
}
exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;
//# sourceMappingURL=broadcast_util.js.map

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util = __webpack_require__(4);
var axis_util = __webpack_require__(109);
var broadcast_util = __webpack_require__(56);
var concat_util = __webpack_require__(65);
var conv_util = __webpack_require__(51);
var copy2d_util = __webpack_require__(153);
var ndarray_1 = __webpack_require__(6);
var slice_util = __webpack_require__(407);
var SumTypesMap;
(function (SumTypesMap) {
    SumTypesMap["float32"] = "float32";
    SumTypesMap["int32"] = "int32";
    SumTypesMap["bool"] = "int32";
})(SumTypesMap = exports.SumTypesMap || (exports.SumTypesMap = {}));
var NDArrayMath = (function () {
    function NDArrayMath(safeMode) {
        this.safeMode = safeMode;
        this.ndarrayScopes = [];
        this.ndarraysToKeep = [];
        this.activeScopeNDArraysToKeep = [];
        this.debugMode = false;
    }
    NDArrayMath.prototype.scope = function (scopeFn) {
        var _this = this;
        this.startScope();
        var keepFn = function (ndarray) { return _this.keep(ndarray); };
        var trackFn = function (ndarray) { return _this.track(ndarray); };
        var result = scopeFn(keepFn, trackFn);
        if (result instanceof Promise) {
            result.then(function (r) { return _this.endScope(r); });
            return result;
        }
        else {
            this.endScope(result);
            return result;
        }
    };
    NDArrayMath.prototype.enableDebugMode = function () {
        this.debugMode = true;
        console.warn('Debugging mode is ON. The output of every math call will ' +
            'be downloaded to CPU and checked for NaNs. ' +
            'This significantly impacts performance.');
    };
    NDArrayMath.prototype.startScope = function () {
        var newScope = [];
        this.ndarrayScopes.push(newScope);
        this.activeScope = newScope;
        var newNDArraysToKeep = [];
        this.ndarraysToKeep.push(newNDArraysToKeep);
        this.activeScopeNDArraysToKeep = newNDArraysToKeep;
    };
    NDArrayMath.prototype.extractNDArraysFromScopeResult = function (result) {
        if (result == null) {
            return [];
        }
        if (result instanceof ndarray_1.NDArray) {
            return [result];
        }
        var list = [];
        var resultObj = result;
        for (var k in resultObj) {
            var val = resultObj[k];
            if (val instanceof ndarray_1.NDArray) {
                list.push(val);
            }
        }
        return list;
    };
    NDArrayMath.prototype.endScope = function (result) {
        var _this = this;
        var arraysToKeep = this.activeScopeNDArraysToKeep;
        var resultArrays = this.extractNDArraysFromScopeResult(result);
        arraysToKeep = arraysToKeep.concat(resultArrays);
        for (var i = 0; i < this.activeScope.length; i++) {
            var ndarray = this.activeScope[i];
            if (this.isNDArrayDataInList(ndarray, arraysToKeep)) {
                continue;
            }
            ndarray.dispose();
        }
        this.ndarrayScopes.pop();
        this.activeScope = this.ndarrayScopes.length === 0 ?
            null :
            this.ndarrayScopes[this.ndarrayScopes.length - 1];
        resultArrays.forEach(function (val) {
            if (!_this.isNDArrayDataInList(val, _this.activeScopeNDArraysToKeep)) {
                _this.track(val);
            }
        });
        this.ndarraysToKeep.pop();
        this.activeScopeNDArraysToKeep = this.ndarraysToKeep.length === 0 ?
            null :
            this.ndarraysToKeep[this.ndarraysToKeep.length - 1];
    };
    NDArrayMath.prototype.isNDArrayDataInList = function (ndarray, ndarrayList) {
        for (var i = 0; i < ndarrayList.length; i++) {
            if (ndarrayList[i].getData() === ndarray.getData()) {
                return true;
            }
        }
        return false;
    };
    NDArrayMath.prototype.keep = function (result) {
        if (this.activeScope == null) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
            return result;
        }
        this.activeScopeNDArraysToKeep.push(result);
        return result;
    };
    NDArrayMath.prototype.checkForNaN = function (vals, dtype, name) {
        for (var i = 0; i < vals.length; i++) {
            if (util.isValNaN(vals[i], dtype)) {
                throw Error("The result of the last math." + name + " has NaNs.");
            }
        }
    };
    NDArrayMath.prototype.track = function (result) {
        if (this.activeScope == null) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
            return result;
        }
        this.activeScope.push(result);
        return result;
    };
    NDArrayMath.prototype.dispose = function () { };
    NDArrayMath.prototype.matMul = function (a, b, aOrientation, bOrientation) {
        var _this = this;
        if (aOrientation === void 0) { aOrientation = MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = MatrixOrientation.REGULAR; }
        var innerShapeA = (aOrientation === MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var innerShapeB = (bOrientation === MatrixOrientation.REGULAR) ? b.shape[0] : b.shape[1];
        util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank +
            (" and " + b.rank + "."));
        util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
            (innerShapeB + ") of NDArrays with shapes " + a.shape + " and ") +
            (b.shape + " and orientations " + MatrixOrientation[aOrientation]) +
            (" and " + MatrixOrientation[bOrientation] + " must match."));
        return this.executeOp('matMul', function () { return _this.matMulInternal(a, b, aOrientation, bOrientation); });
    };
    NDArrayMath.prototype.executeOp = function (name, f) {
        var start;
        if (this.debugMode) {
            start = performance.now();
        }
        var result = f();
        if (this.debugMode) {
            var vals = result.getValues();
            var time = util.rightPad(performance.now() - start + "ms", 9);
            var paddedName = util.rightPad(name, 25);
            var rank = result.rank;
            var size = result.size;
            var shape = util.rightPad(result.shape.toString(), 14);
            console.log("%c" + paddedName + "\t%c" + time + "\t%c" + rank + "D " + shape + "\t%c" + size, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange');
            this.checkForNaN(vals, result.dtype, name);
        }
        return this.track(result);
    };
    NDArrayMath.prototype.vectorTimesMatrix = function (v, matrix) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of vector (" + v.size + ") " +
            ("must match first dimension of matrix (" + matrix.shape[0] + ")"));
        return this.matMul(v.as2D(1, -1), matrix).as1D();
    };
    NDArrayMath.prototype.matrixTimesVector = function (matrix, v) {
        util.assert(v.rank === 1, "Error in matrixTimesVector: second input must rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in matrixTimesVector: first input must be a rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[1], "Error in matrixTimesVector: size of first rank 1 input " + v.size + " " +
            "must match inner dimension of second rank 2 input, but got " +
            ("shape " + matrix.shape + "."));
        return this.matMul(matrix, v.as2D(-1, 1)).as1D();
    };
    NDArrayMath.prototype.dotProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" +
            (v2.size + ") must match."));
        return this.matMul(v1.as2D(1, -1), v2.as2D(-1, 1)).asScalar();
    };
    NDArrayMath.prototype.outerProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        return this.matMul(v1.as2D(-1, 1), v2.as2D(1, -1));
    };
    NDArrayMath.prototype.clone = function (ndarray) {
        var _this = this;
        return this.executeOp('clone', function () { return _this.cloneInternal(ndarray); });
    };
    NDArrayMath.prototype.reshape = function (ndarray, newShape) {
        console.warn('math.reshape() is deprecated. Please call reshape() ' +
            'directly on the ndarray object');
        return ndarray.reshape(newShape);
    };
    NDArrayMath.prototype.slice1D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, [begin], [size]);
        return this.executeOp('slice1D', function () { return _this.slice1DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.slice2D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, begin, size);
        return this.executeOp('slice2D', function () { return _this.slice2DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.slice3D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, begin, size);
        return this.executeOp('slice3D', function () { return _this.slice3DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.slice4D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, begin, size);
        return this.executeOp('slice4D', function () { return _this.slice4DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.copy2D = function (source, sourceBegin, sourceSize, dest, destBegin, destSize) {
        var _this = this;
        util.assert(sourceBegin[0] + sourceSize[0] <= source.shape[0] &&
            sourceBegin[1] + sourceSize[1] <= source.shape[1], "Error in copy2D: requested source start position " + sourceBegin + " " +
            ("and source size " + sourceSize + " would overflow source NDArray") +
            ("of shape " + source.shape + "."));
        util.assert(destBegin[0] + destSize[0] <= dest.shape[0] &&
            destBegin[1] + destSize[1] <= dest.shape[1], "Error in copy2D: requested dest start position " + destBegin + " " +
            ("and source size " + destSize + " would overflow dest NDArray of") +
            ("shape " + dest.shape + "."));
        copy2d_util.validateShapes(sourceSize, destSize);
        this.executeOp('copy2D', function () {
            _this.copy2DInternal(source, sourceBegin, sourceSize, dest, destBegin, destSize);
            return dest;
        });
    };
    NDArrayMath.prototype.concat1D = function (a, b) {
        var _this = this;
        concat_util.assertParams(a.shape, b.shape, 0);
        return this.executeOp('concat1D', function () { return _this.concat1DInternal(a, b); });
    };
    NDArrayMath.prototype.concat2D = function (a, b, axis) {
        var _this = this;
        concat_util.assertParams(a.shape, b.shape, axis);
        return this.executeOp('concat2D', function () { return _this.concat2DInternal(a, b, axis); });
    };
    NDArrayMath.prototype.concat3D = function (ndarray1, ndarray2, axis) {
        var _this = this;
        concat_util.assertParams(ndarray1.shape, ndarray2.shape, axis);
        return this.executeOp('concat3D', function () { return _this.concat3DInternal(ndarray1, ndarray2, axis); });
    };
    NDArrayMath.prototype.concat4D = function (ndarray1, ndarray2, axis) {
        var _this = this;
        concat_util.assertParams(ndarray1.shape, ndarray2.shape, axis);
        return this.executeOp('concat4D', function () { return _this.concat4DInternal(ndarray1, ndarray2, axis); });
    };
    NDArrayMath.prototype.logSumExp = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        return this.executeOp('logSumExp', function () {
            var xMax = _this.max(input, axes, true);
            var a = _this.subtract(input, xMax);
            var b = _this.exp(a);
            var c = _this.sum(b, axes);
            var d = _this.log(c);
            var res = _this.add(xMax.reshape(d.shape), d);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.sum = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, input.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('sum', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            var res = _this.sumInternal(input, axes);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.mean = function (x, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);
        var reduceShape = shapes[1];
        var reduceSize = util.sizeFromShape(reduceShape);
        return this.executeOp('mean', function () {
            return _this.scope(function (keep, track) {
                var res = _this.divide(x, track(ndarray_1.Scalar.new(reduceSize)));
                return _this.sum(res, axis, keepDims);
            });
        });
    };
    NDArrayMath.prototype.argMin = function (input, axis) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('argMin', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            return _this.argMinInternal(input, axes);
        });
    };
    NDArrayMath.prototype.argMax = function (input, axis) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('argMax', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            return _this.argMaxInternal(input, axes);
        });
    };
    NDArrayMath.prototype.argMaxEquals = function (x1, x2) {
        var _this = this;
        util.assertShapesMatch(x1.shape, x2.shape, 'Error in argMaxEquals: ');
        return this.executeOp('argMaxEquals', function () { return _this.scope(function () {
            return _this.equal(_this.argMax(x1), _this.argMax(x2));
        }); });
    };
    NDArrayMath.prototype.equal = function (x, y) {
        var _this = this;
        return this.executeOp('equal', function () { return _this.equalInternal(x, y); });
    };
    NDArrayMath.prototype.equalStrict = function (x, y) {
        util.assertShapesMatch(x.shape, y.shape, 'Error in equalStrict: ');
        return this.equal(x, y);
    };
    NDArrayMath.prototype.topK = function (ndarray, k) {
        var _this = this;
        util.assert(k <= ndarray.size, "Error in topK: k value (" + k + ") must be less than size of input " +
            ("ndarray, got shape " + ndarray.shape + "."));
        var result;
        this.executeOp('topK', function () {
            result = _this.topKInternal(ndarray, k);
            return result.values;
        });
        this.track(result.indices);
        return result;
    };
    NDArrayMath.prototype.min = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, input.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('min', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            var res = _this.minInternal(input, axes);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.max = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, input.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('max', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            var res = _this.maxInternal(input, axes);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.softmax = function (logits, dim) {
        var _this = this;
        if (dim === void 0) { dim = -1; }
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error('Softmax along a non-last dimension is not yet supported. ' +
                ("Logits was rank " + logits.rank + " and dim was " + dim));
        }
        return this.executeOp('softmax', function () {
            return _this.scope(function () {
                var lse = _this.logSumExp(logits, [dim], true);
                var logResult = _this.subtract(logits, lse);
                return _this.exp(logResult);
            });
        });
    };
    NDArrayMath.prototype.switchDim = function (a, newDim) {
        return this.transpose(a, newDim);
    };
    NDArrayMath.prototype.tile = function (a, reps) {
        var _this = this;
        util.assert(a.rank === reps.length, "Error in transpose: rank of input " + a.rank + " " +
            ("must match length of reps " + reps + "."));
        return this.executeOp('tile', function () { return _this.tileInternal(a, reps); });
    };
    NDArrayMath.prototype.transpose = function (a, perm) {
        var _this = this;
        if (perm == null) {
            perm = a.shape.map(function (s, i) { return i; }).reverse();
        }
        util.assert(a.rank === perm.length, "Error in transpose: rank of input " + a.rank + " " +
            ("must match length of perm " + perm + "."));
        return this.executeOp('transpose', function () { return _this.transposeInternal(a, perm); });
    };
    NDArrayMath.prototype.scalarPlusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarPlusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.add(c, a);
    };
    NDArrayMath.prototype.scalarMinusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarMinusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.subtract(c, a);
    };
    NDArrayMath.prototype.arrayMinusScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayMinusScalar: second argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.subtract(a, c);
    };
    NDArrayMath.prototype.neg = function (a) {
        var _this = this;
        return this.executeOp('neg', function () { return _this.negInternal(a); });
    };
    NDArrayMath.prototype.add = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('add', function () { return _this.addInternal(a, b); });
    };
    NDArrayMath.prototype.addStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
        return this.add(a, b);
    };
    NDArrayMath.prototype.subtract = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('subtract', function () { return _this.subtractInternal(a, b); });
    };
    NDArrayMath.prototype.sub = function (a, b) {
        return this.subtract(a, b);
    };
    NDArrayMath.prototype.subStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
        return this.subtract(a, b);
    };
    NDArrayMath.prototype.multiply = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('multiply', function () { return _this.multiplyInternal(a, b); });
    };
    NDArrayMath.prototype.elementWiseMul = function (a, b) {
        return this.multiplyStrict(a, b);
    };
    NDArrayMath.prototype.multiplyStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
        return this.multiply(a, b);
    };
    NDArrayMath.prototype.divide = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('divide', function () { return _this.divideInternal(a, b); });
    };
    NDArrayMath.prototype.divideStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
        return this.divide(a, b);
    };
    NDArrayMath.prototype.scalarDividedByArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarDividedByArray: first argument must be rank 0, but " +
            ("got NDArray of rank " + c.rank + "."));
        return this.divide(c, a);
    };
    NDArrayMath.prototype.arrayDividedByScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: second argument must be rank 0, " +
            ("but got NDArray of rank " + c.rank + "."));
        return this.divide(a, c);
    };
    NDArrayMath.prototype.ceil = function (ndarray) {
        var _this = this;
        return this.executeOp('ceil', function () { return _this.ceilInternal(ndarray); });
    };
    NDArrayMath.prototype.floor = function (ndarray) {
        var _this = this;
        return this.executeOp('floor', function () { return _this.floorInternal(ndarray); });
    };
    NDArrayMath.prototype.exp = function (ndarray) {
        var _this = this;
        return this.executeOp('exp', function () { return _this.expInternal(ndarray); });
    };
    NDArrayMath.prototype.log = function (ndarray) {
        var _this = this;
        return this.executeOp('log', function () { return _this.logInternal(ndarray); });
    };
    NDArrayMath.prototype.sqrt = function (ndarray) {
        var _this = this;
        return this.executeOp('sqrt', function () { return _this.sqrtInternal(ndarray); });
    };
    NDArrayMath.prototype.square = function (x) {
        var _this = this;
        return this.executeOp('square', function () { return _this.squareInternal(x); });
    };
    NDArrayMath.prototype.abs = function (ndarray) {
        var _this = this;
        return this.executeOp('abs', function () { return _this.absInternal(ndarray); });
    };
    NDArrayMath.prototype.clip = function (ndarray, min, max) {
        var _this = this;
        util.assert((min <= max), "Error in clip: min (" + min + ") must be" +
            ("less than or equal to max (" + max + ")."));
        return this.executeOp('clip', function () { return _this.clipInternal(ndarray, min, max); });
    };
    NDArrayMath.prototype.relu = function (ndarray) {
        var _this = this;
        return this.executeOp('relu', function () { return _this.reluInternal(ndarray); });
    };
    NDArrayMath.prototype.elu = function (ndarray) {
        var _this = this;
        return this.executeOp('elu', function () { return _this.eluInternal(ndarray); });
    };
    NDArrayMath.prototype.leakyRelu = function (ndarray, alpha) {
        var _this = this;
        if (alpha === void 0) { alpha = 0.2; }
        return this.executeOp('leakyRelu', function () { return _this.leakyReluInternal(ndarray, alpha); });
    };
    NDArrayMath.prototype.sigmoid = function (ndarray) {
        var _this = this;
        return this.executeOp('sigmoid', function () { return _this.sigmoidInternal(ndarray); });
    };
    NDArrayMath.prototype.sin = function (ndarray) {
        var _this = this;
        return this.executeOp('sin', function () { return _this.sinInternal(ndarray); });
    };
    NDArrayMath.prototype.cos = function (ndarray) {
        var _this = this;
        return this.executeOp('cos', function () { return _this.cosInternal(ndarray); });
    };
    NDArrayMath.prototype.tan = function (ndarray) {
        var _this = this;
        return this.executeOp('tan', function () { return _this.tanInternal(ndarray); });
    };
    NDArrayMath.prototype.asin = function (ndarray) {
        var _this = this;
        return this.executeOp('asin', function () { return _this.asinInternal(ndarray); });
    };
    NDArrayMath.prototype.acos = function (ndarray) {
        var _this = this;
        return this.executeOp('acos', function () { return _this.acosInternal(ndarray); });
    };
    NDArrayMath.prototype.atan = function (ndarray) {
        var _this = this;
        return this.executeOp('atan', function () { return _this.atanInternal(ndarray); });
    };
    NDArrayMath.prototype.sinh = function (ndarray) {
        var _this = this;
        return this.executeOp('sinh', function () { return _this.sinhInternal(ndarray); });
    };
    NDArrayMath.prototype.cosh = function (ndarray) {
        var _this = this;
        return this.executeOp('cosh', function () { return _this.coshInternal(ndarray); });
    };
    NDArrayMath.prototype.tanh = function (ndarray) {
        var _this = this;
        return this.executeOp('tanh', function () { return _this.tanhInternal(ndarray); });
    };
    NDArrayMath.prototype.step = function (ndarray, alpha) {
        var _this = this;
        if (alpha === void 0) { alpha = 0.0; }
        return this.executeOp('step', function () { return _this.stepInternal(ndarray, alpha); });
    };
    NDArrayMath.prototype.scaledArrayAdd = function (c1, a, c2, b) {
        var _this = this;
        util.assert(c1.size === 1, "Error in scaledArrayAdd: first argument must rank 0, but got " +
            (" rank " + c1.rank + "."));
        util.assert(c2.size === 1, "Error in scaledArrayAdd: third argument must be rank 0, but got " +
            ("NDArray of rank " + c2.rank + "."));
        util.assertShapesMatch(a.shape, b.shape, 'Error in scaledArrayAdd: ');
        return this.executeOp('scaledArrayAdd', function () { return _this.scaledArrayAddInternal(c1, a, c2, b); });
    };
    NDArrayMath.prototype.scalarTimesArray = function (c, a) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: first argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.multiply(c, a);
    };
    NDArrayMath.prototype.elementWiseMulBroadcast = function (a, b) {
        util.assert(a.rank === 2, "Error in elementWiseMulBroadcast: first argument must be " +
            ("rank 2, but got rank " + a.rank + "."));
        util.assert(b.rank === 2, "Error in elementWiseMulBroadcast: second argument must be " +
            ("rank 2, but got rank " + b.rank + "."));
        return this.multiply(a, b);
    };
    NDArrayMath.prototype.conv2d = function (x, filter, bias, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in conv2d: x must be rank 3, but got rank " + x.rank + ".");
        util.assert(filter.rank === 4, "Error in conv2d: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        if (bias != null) {
            util.assert(bias.rank === 1, "Error in conv2d: bias must be rank 1, but got rank " +
                (bias.rank + "."));
        }
        util.assert(x.shape[2] === filter.shape[2], "Error in conv2d: depth of input (" + x.shape[2] + ") must match  " +
            ("input depth for filter " + filter.shape[2] + "."));
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var outDepth = filter.shape[3];
        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('conv2d', function () { return _this.conv2dInternal(x, filter, bias, convInfo); });
    };
    NDArrayMath.prototype.conv2dBackProp = function (x, dy, filter, strides, pad) {
        var dw = this.conv2dDerFilter(x, dy, filter.shape, strides, pad);
        var db = this.conv2dDerBias(dy);
        var dx = this.conv2dDerInput(x.shape, dy, filter, strides, pad);
        return { db: db, dw: dw, dx: dx };
    };
    NDArrayMath.prototype.conv2dDerInput = function (inShape, dy, filter, strides, pad) {
        var _this = this;
        var inDepth = inShape[2];
        var outDepth = dy.shape[2];
        util.assert(inShape.length === 3, "Error in conv2dDerInput: x must be rank 3, but got rank " +
            (inShape.length + "."));
        util.assert(dy.rank === 3, "Error in conv2dDerInput: dy must be rank 3, but got " +
            ("rank " + dy.rank));
        util.assert(filter.rank === 4, "Error in conv2dDerInput: filter must be rank 4, but got " +
            ("rank " + filter.rank));
        util.assert(inDepth === filter.shape[2], "Error in conv2dDerInput: depth of input (" + inDepth + ") must " +
            ("match input depth for filter " + filter.shape[2] + "."));
        util.assert(outDepth === filter.shape[3], "Error in conv2dDerInput: depth of output (" + outDepth + ") must" +
            ("match output depth for filter " + filter.shape[3] + "."));
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
        var convInfo = conv_util.computeConv2DInfo(inShape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('conv2dDerInput', function () { return _this.conv2dDerInputInternal(dy, filter, convInfo); });
    };
    NDArrayMath.prototype.conv2dDerBias = function (dy) {
        return this.track(this.conv2dDerBiasInternal(dy));
    };
    NDArrayMath.prototype.conv2dDerFilter = function (x, dy, filterSize, strides, pad) {
        util.assert(x.rank === 3, "Error in conv2dDerFilter: x must be rank 3, but got shape " +
            (x.shape + "."));
        util.assert(dy.rank === 3, "Error in conv2dDerFilter: dy must be rank 3, but got shape " +
            (dy.shape + "."));
        util.assert(filterSize.length === 4, "Error in conv2dDerFilter: filterSize must be length 4, but got " +
            (filterSize + "."));
        util.assert(x.shape[2] === filterSize[2], "Error in conv2dDerFilter: depth of x " + x.shape[2] + ") must " +
            ("match input depth in filter (" + filterSize[2] + "."));
        util.assert(dy.shape[2] === filterSize[3], "Error in conv2dDerFilter: depth of dy (" + dy.shape[2] + ") must " +
            ("match output depth for filter (" + filterSize[3] + ")."));
        var filterHeight = filterSize[0];
        var filterWidth = filterSize[1];
        var outDepth = filterSize[3];
        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.track(this.conv2dDerFilterInternal(x, dy, convInfo));
    };
    NDArrayMath.prototype.conv2dTranspose = function (x, filter, outputShape, strides, pad) {
        return this.conv2dDerInput(outputShape, x, filter, strides, pad);
    };
    NDArrayMath.prototype.depthwiseConv2D = function (input, filter, strides, pad, rates) {
        var _this = this;
        if (rates === void 0) { rates = [1, 1]; }
        var input4D = input;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
        }
        util.assert(input4D.rank === 4, "Error in depthwiseConv2D: input must be rank 4, but got " +
            ("rank " + input4D.rank + "."));
        util.assert(filter.rank === 4, "Error in depthwiseConv2D: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        util.assert(input4D.shape[3] === filter.shape[2], "Error in depthwiseConv2D: number of input channels " +
            ("(" + input4D.shape[3] + ") must match the inChannels dimension in ") +
            ("filter " + filter.shape[2] + "."));
        rates = rates || [1, 1];
        var _a = parseTupleParam(rates), rateHeight = _a[0], rateWidth = _a[1];
        util.assert(rateHeight === 1 && rateWidth === 1, 'Error in depthwiseConv2D: rates greater than 1 are not yet ' +
            ("supported. Got rates '" + rates + "'"));
        var convInfo = conv_util.computeDepthwiseConv2DInfo(input4D.shape, filter.shape, strides, pad);
        return this.executeOp('depthwiseConv2D', function () {
            var res = _this.depthwiseConv2DInternal(input4D, filter, convInfo);
            if (reshapedTo4D) {
                return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
            }
            return res;
        });
    };
    NDArrayMath.prototype.maxPool = function (x, filterSize, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in maxPool: x must be rank 3 but got rank " + x.rank + ".");
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('maxPool', function () { return _this.maxPoolInternal(x, convInfo); });
    };
    NDArrayMath.prototype.maxPoolBackprop = function (dy, x, filterSize, strides, pad) {
        var _this = this;
        util.assert(dy.rank === 3, "Error in maxPoolBackprop: dy must be rank 3 but got rank " +
            (dy.rank + "."));
        util.assert(x.rank === 3, "Error in maxPoolBackprop: x must be rank 3 but got rank " +
            (x.rank + "."));
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('maxPoolBackprop', function () { return _this.maxPoolBackpropInternal(dy, x, convInfo); });
    };
    NDArrayMath.prototype.minPool = function (x, filterSize, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in minPool: x must be rank 3 but got rank " + x.rank + ".");
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('minPool', function () { return _this.minPoolInternal(x, convInfo); });
    };
    NDArrayMath.prototype.avgPool = function (x, filterSize, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in avgPool: x must be rank 3 but got rank " + x.rank + ".");
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('avgPool', function () { return _this.avgPoolInternal(x, convInfo); });
    };
    NDArrayMath.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {
        var _this = this;
        if (alignCorners === void 0) { alignCorners = false; }
        util.assert(x.rank === 3, "Error in resizeBilinear3D: x must be rank 3 but got rank " + x.rank + ".");
        util.assert(newShape2D.length === 2, "Error in resizeBilinear3D: new shape must 2D, but got shape " +
            (newShape2D + "."));
        return this.executeOp('resizeBilinear3D', function () { return _this.resizeBilinear3DInternal(x, newShape2D, alignCorners); });
    };
    NDArrayMath.prototype.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var _this = this;
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 2, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 2 || mean.rank === 1, "Error in batchNormalization2D: mean must be rank 2 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 2 || variance.rank === 1, "Error in batchNormalization2D: variance must be rank 2 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 2 || scale.rank === 1, "Error in batchNormalization2D: scale must be rank 2 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 2 || offset.rank === 1, "Error in batchNormalization2D: offset must be rank 2 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return this.executeOp('batchNorm2D', function () { return _this.batchNormalization2DInternal(x, mean, variance, varianceEpsilon, scale, offset); });
    };
    NDArrayMath.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var _this = this;
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return this.executeOp('batchNorm3D', function () { return _this.batchNormalization3DInternal(x, mean, variance, varianceEpsilon, scale, offset); });
    };
    NDArrayMath.prototype.multiRNNCell = function (lstmCells, data, c, h) {
        var res = this.scope(function () {
            var input = data;
            var newStates = [];
            for (var i = 0; i < lstmCells.length; i++) {
                var output = lstmCells[i](input, c[i], h[i]);
                newStates.push(output[0]);
                newStates.push(output[1]);
                input = output[1];
            }
            return newStates;
        });
        var newC = [];
        var newH = [];
        for (var i = 0; i < res.length; i += 2) {
            newC.push(res[i]);
            newH.push(res[i + 1]);
        }
        return [newC, newH];
    };
    NDArrayMath.prototype.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
        var _this = this;
        var res = this.scope(function () {
            var combined = _this.concat2D(data, h, 1);
            var weighted = _this.matMul(combined, lstmKernel);
            var res = _this.add(weighted, lstmBias);
            var batchSize = res.shape[0];
            var sliceCols = res.shape[1] / 4;
            var sliceSize = [batchSize, sliceCols];
            var i = _this.slice2D(res, [0, 0], sliceSize);
            var j = _this.slice2D(res, [0, sliceCols], sliceSize);
            var f = _this.slice2D(res, [0, sliceCols * 2], sliceSize);
            var o = _this.slice2D(res, [0, sliceCols * 3], sliceSize);
            var newC = _this.addStrict(_this.multiplyStrict(c, _this.sigmoid(_this.scalarPlusArray(forgetBias, f))), _this.multiplyStrict(_this.sigmoid(i), _this.tanh(j)));
            var newH = _this.multiplyStrict(_this.tanh(newC), _this.sigmoid(o));
            return [newC, newH];
        });
        return [res[0], res[1]];
    };
    NDArrayMath.prototype.multinomial = function (probabilities, numSamples, seed) {
        var _this = this;
        var numOutcomes = probabilities.size;
        if (numOutcomes < 2) {
            throw new Error("Error in multinomial: you need at least 2 outcomes, but got " +
                (numOutcomes + "."));
        }
        if (probabilities.rank > 2) {
            throw new Error("Rank of probabilities must be 1 or 2, but is " + probabilities.rank);
        }
        seed = seed || Math.random();
        var origRank = probabilities.rank;
        if (probabilities.rank === 1) {
            probabilities = probabilities.as2D(1, -1);
        }
        return this.executeOp('multinomial', function () {
            var res = _this.multinomialInternal(probabilities, numSamples, seed);
            if (origRank === 1) {
                return res.as1D();
            }
            return res;
        });
    };
    NDArrayMath.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var _this = this;
        if (onValue === void 0) { onValue = 1; }
        if (offValue === void 0) { offValue = 0; }
        if (depth < 2) {
            throw new Error("Error in oneHot: depth must be >=2, but it is " + depth);
        }
        return this.executeOp('oneHot', function () { return _this.oneHotInternal(indices, depth, onValue, offValue); });
    };
    NDArrayMath.prototype.moments = function (x, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var result = this.scope(function () {
            var mean = _this.mean(x, axes, keepDims);
            var keepDimsShape = mean.shape;
            if (!keepDims) {
                keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);
            }
            var devSquared = _this.square(_this.subtract(x, mean.reshape(keepDimsShape)));
            var variance = _this.mean(devSquared, axes, keepDims);
            return { mean: mean, variance: variance };
        });
        return result;
    };
    return NDArrayMath;
}());
exports.NDArrayMath = NDArrayMath;
var MatrixOrientation;
(function (MatrixOrientation) {
    MatrixOrientation[MatrixOrientation["REGULAR"] = 0] = "REGULAR";
    MatrixOrientation[MatrixOrientation["TRANSPOSED"] = 1] = "TRANSPOSED";
})(MatrixOrientation = exports.MatrixOrientation || (exports.MatrixOrientation = {}));
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
//# sourceMappingURL=math.js.map

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MAX_TEXTURE_SIZE = null;
var util = __webpack_require__(4);
var environment_1 = __webpack_require__(32);
function createWebGLRenderingContext(attributes) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return createWebGLRenderingContextFromCanvas(canvas, attributes);
}
exports.createWebGLRenderingContext = createWebGLRenderingContext;
function createWebGLRenderingContextFromCanvas(canvas, attributes) {
    var gl;
    var webglVersion = environment_1.ENV.get('WEBGL_VERSION');
    if (webglVersion === 2) {
        gl = canvas.getContext('webgl2', attributes);
    }
    else if (webglVersion === 1) {
        gl = (canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes));
    }
    if (webglVersion === 0 || gl == null) {
        throw new Error('This browser does not support WebGL.');
    }
    return gl;
}
exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
function callAndCheck(gl, func) {
    var returnValue = func();
    checkWebGLError(gl);
    return returnValue;
}
exports.callAndCheck = callAndCheck;
var webGLDebugErrorCheckingEnabled = false;
function enableDebugWebGLErrorChecking(enabled) {
    webGLDebugErrorCheckingEnabled = enabled;
}
exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
function checkWebGLError(gl) {
    if (webGLDebugErrorCheckingEnabled) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
        }
    }
}
exports.checkWebGLError = checkWebGLError;
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return "Unknown error code " + status;
    }
}
exports.getWebGLErrorMessage = getWebGLErrorMessage;
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension "' + extensionName + '" not supported on this browser.');
}
exports.getExtensionOrThrow = getExtensionOrThrow;
function createVertexShader(gl, vertexShaderSource) {
    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
exports.createVertexShader = createVertexShader;
function createFragmentShader(gl, fragmentShaderSource) {
    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
exports.createFragmentShader = createFragmentShader;
var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
        console.log("Couldn't parse line number in error: " + shaderInfoLog);
        console.log(shaderSource);
        return;
    }
    var lineNumber = +lineNumberRegexResult[1];
    var shaderLines = shaderSource.split('\n');
    var pad = shaderLines.length.toString().length + 2;
    var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {
        return util.rightPad((lineNumber + 1).toString(), pad) + line;
    });
    var maxLineLength = 0;
    for (var i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    var afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join('\n'));
    console.log(shaderInfoLog.split('\n')[0]);
    console.log("%c " + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
    console.log(afterErrorLines.join('\n'));
}
function createProgram(gl) {
    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');
}
exports.createProgram = createProgram;
function linkProgram(gl, program) {
    callAndCheck(gl, function () { return gl.linkProgram(program); });
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
exports.linkProgram = linkProgram;
function validateProgram(gl, program) {
    callAndCheck(gl, function () { return gl.validateProgram(program); });
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
exports.validateProgram = validateProgram;
function createStaticVertexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticVertexBuffer = createStaticVertexBuffer;
function createStaticIndexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticIndexBuffer = createStaticIndexBuffer;
function queryMaxTextureSize(gl) {
    if (MAX_TEXTURE_SIZE != null) {
        return MAX_TEXTURE_SIZE;
    }
    MAX_TEXTURE_SIZE =
        callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });
    return MAX_TEXTURE_SIZE;
}
exports.queryMaxTextureSize = queryMaxTextureSize;
function getChannelsPerTexture() {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return 4;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        return 1;
    }
    return 4;
}
exports.getChannelsPerTexture = getChannelsPerTexture;
function createTexture(gl) {
    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');
}
exports.createTexture = createTexture;
function validateTextureSize(gl, width, height) {
    var maxTextureSize = queryMaxTextureSize(gl);
    if ((width <= 0) || (height <= 0)) {
        var requested = "[" + width + "x" + height + "]";
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        var requested = "[" + width + "x" + height + "]";
        var max = "[" + maxTextureSize + "x" + maxTextureSize + "]";
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
exports.validateTextureSize = validateTextureSize;
function createFramebuffer(gl) {
    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');
}
exports.createFramebuffer = createFramebuffer;
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes, attribLocations) {
    var loc = -1;
    if ((attribLocations != null) && (attribute in attribLocations)) {
        loc = attribLocations[attribute];
    }
    else {
        loc = gl.getAttribLocation(program, attribute);
    }
    if (loc === -1) {
        return;
    }
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
}
exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
}
exports.bindTextureUnit = bindTextureUnit;
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.unbindTextureUnit = unbindTextureUnit;
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform "' + uniformName + '" not present in program.');
}
exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
    callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });
}
exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
}
exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
}
exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
}
exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
function validateFramebuffer(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
exports.validateFramebuffer = validateFramebuffer;
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return "unknown error " + status;
    }
}
exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
function throwIfNull(gl, returnTOrNull, failureMessage) {
    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        var textureUnitRange = "[gl.TEXTURE0, gl.TEXTURE" + maxTextureUnit + "]";
        throw new Error("textureUnit must be in " + textureUnitRange + ".");
    }
}
function getTextureShapeFromLogicalShape(gl, logShape) {
    if (logShape.length !== 2) {
        var squeezeResult = util.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
    }
    var maxTexSize = queryMaxTextureSize(gl);
    var size = util.sizeFromShape(logShape);
    if (logShape.length <= 1 && size <= maxTexSize) {
        return [size, 1];
    }
    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
        logShape[1] <= maxTexSize) {
        return logShape;
    }
    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
    }
    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    else {
        return util.sizeToSquarishShape(size);
    }
}
exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;
//# sourceMappingURL=webgl_util.js.map

/***/ }),
/* 59 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(23);
var TAG = __webpack_require__(7)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(23);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 63 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var initializers_1 = __webpack_require__(152);
var concat_util = __webpack_require__(65);
var conv_util = __webpack_require__(51);
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var GraphLayers = (function () {
    function GraphLayers(g) {
        this.g = g;
    }
    GraphLayers.prototype.dense = function (name, x, units, activation, useBias, kernelInitializer, biasInitializer) {
        if (activation === void 0) { activation = null; }
        if (useBias === void 0) { useBias = true; }
        if (kernelInitializer === void 0) { kernelInitializer = new initializers_1.VarianceScalingInitializer(); }
        if (biasInitializer === void 0) { biasInitializer = new initializers_1.ZerosInitializer(); }
        var weights = this.g.variable(name + '-weights', kernelInitializer.initialize([x.shape[0], units], x.shape[0], units));
        var out = this.g.matmul(x, weights);
        if (useBias) {
            var bias = this.g.variable(name + '-bias', biasInitializer.initialize([units], x.shape[0], units));
            out = this.g.add(out, bias);
        }
        if (activation != null) {
            out = activation(out);
        }
        return out;
    };
    return GraphLayers;
}());
exports.GraphLayers = GraphLayers;
var Graph = (function () {
    function Graph() {
        this.nodes = [];
        this.layers = new GraphLayers(this);
    }
    Graph.prototype.variable = function (name, data) {
        return this.addNodeAndReturnOutput(new VariableNode(this, name, data));
    };
    Graph.prototype.placeholder = function (name, shape) {
        return this.addNodeAndReturnOutput(new PlaceholderNode(this, name, shape));
    };
    Graph.prototype.constant = function (value) {
        var finalValue;
        if (typeof value === 'number') {
            finalValue = ndarray_1.Scalar.new(value);
        }
        else if (value instanceof ndarray_1.NDArray) {
            finalValue = value;
        }
        else if (value instanceof Array) {
            var flatValues = util.flatten(value);
            var vals = new Float32Array(flatValues);
            finalValue = ndarray_1.NDArray.make(util.inferShape(value), { values: vals });
        }
        else {
            throw new Error('unimplemented constant type.');
        }
        return this.addNodeAndReturnOutput(new ConstantNode(this, finalValue));
    };
    Graph.prototype.reshape = function (x, shape) {
        return this.addNodeAndReturnOutput(new ReshapeNode(this, 'Reshape', x, shape));
    };
    Graph.prototype.fusedLinearCombination = function (x1, x2, c1, c2) {
        return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this, x1, x2, c1, c2));
    };
    Graph.prototype.add = function (x1, x2) {
        return this.addNodeAndReturnOutput(new AddNode(this, x1, x2));
    };
    Graph.prototype.subtract = function (x1, x2) {
        return this.addNodeAndReturnOutput(new SubtractNode(this, x1, x2));
    };
    Graph.prototype.multiply = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MultiplyNode(this, x1, x2));
    };
    Graph.prototype.divide = function (x1, x2) {
        return this.addNodeAndReturnOutput(new DivideNode(this, x1, x2));
    };
    Graph.prototype.reduceSum = function (x) {
        return this.addNodeAndReturnOutput(new ReduceSumNode(this, x));
    };
    Graph.prototype.concat3d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat3DNode(this, x1, x2, axis));
    };
    Graph.prototype.matmul = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MatMulNode(this, x1, x2));
    };
    Graph.prototype.conv2d = function (x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new Convolution2DNode(this, x, w, b, fieldSize, outputDepth, stride, zeroPad));
    };
    Graph.prototype.maxPool = function (x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new MaxPoolNode(this, x, fieldSize, stride, zeroPad));
    };
    Graph.prototype.exp = function (x) {
        return this.addNodeAndReturnOutput(new ExpNode(this, x));
    };
    Graph.prototype.log = function (x) {
        return this.addNodeAndReturnOutput(new LogNode(this, x));
    };
    Graph.prototype.relu = function (x) {
        return this.addNodeAndReturnOutput(new ReLUNode(this, x));
    };
    Graph.prototype.leakyRelu = function (x, alpha) {
        return this.addNodeAndReturnOutput(new LeakyReLUNode(this, x, alpha));
    };
    Graph.prototype.tanh = function (x) {
        return this.addNodeAndReturnOutput(new TanHNode(this, x));
    };
    Graph.prototype.sigmoid = function (x) {
        return this.addNodeAndReturnOutput(new SigmoidNode(this, x));
    };
    Graph.prototype.square = function (x) {
        return this.addNodeAndReturnOutput(new SquareNode(this, x));
    };
    Graph.prototype.softmax = function (x) {
        return this.addNodeAndReturnOutput(new SoftmaxNode(this, x));
    };
    Graph.prototype.softmaxCrossEntropyCost = function (x, target) {
        return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this, x, target));
    };
    Graph.prototype.meanSquaredCost = function (label, prediction) {
        return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this, label, prediction));
    };
    Graph.prototype.argmax = function (x) {
        return this.addNodeAndReturnOutput(new ArgMaxNode(this, x));
    };
    Graph.prototype.argmaxEquals = function (x1, x2) {
        return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this, x1, x2));
    };
    Graph.prototype.addNodeAndReturnOutput = function (node) {
        this.nodes.push(node);
        node.validate();
        return node.output;
    };
    Graph.prototype.getNodes = function () {
        return this.nodes;
    };
    return Graph;
}());
exports.Graph = Graph;
var Tensor = (function () {
    function Tensor(shape) {
        this.shape = shape;
        this.id = Tensor.nextID++;
    }
    Tensor.nextID = 0;
    return Tensor;
}());
exports.Tensor = Tensor;
var Node = (function () {
    function Node(graph, name, inputs, output) {
        this.graph = graph;
        this.name = name;
        this.inputs = inputs;
        this.output = output;
        this.id = Node.nextID++;
        output.node = this;
    }
    Node.nextID = 0;
    return Node;
}());
exports.Node = Node;
var VariableNode = (function (_super) {
    __extends(VariableNode, _super);
    function VariableNode(graph, name, data) {
        var _this = _super.call(this, graph, name, {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    VariableNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding variable op: Data for variable \'' + this.name +
            '\' is null or undefined');
    };
    return VariableNode;
}(Node));
exports.VariableNode = VariableNode;
var PlaceholderNode = (function (_super) {
    __extends(PlaceholderNode, _super);
    function PlaceholderNode(graph, name, shape) {
        return _super.call(this, graph, name, {}, new Tensor(shape)) || this;
    }
    PlaceholderNode.prototype.validate = function () { };
    return PlaceholderNode;
}(Node));
exports.PlaceholderNode = PlaceholderNode;
var ConstantNode = (function (_super) {
    __extends(ConstantNode, _super);
    function ConstantNode(graph, data) {
        var _this = _super.call(this, graph, 'Constant', {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    ConstantNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding constant: data for placeholder \'' + this.name +
            '\' is null or undefined');
    };
    return ConstantNode;
}(Node));
exports.ConstantNode = ConstantNode;
var ReshapeNode = (function (_super) {
    __extends(ReshapeNode, _super);
    function ReshapeNode(graph, name, x, shape) {
        var _this = _super.call(this, graph, name, { x: x }, new Tensor(shape)) || this;
        _this.name = name;
        _this.x = x;
        _this.shape = shape;
        return _this;
    }
    ReshapeNode.prototype.validate = function () {
        var xSize = util.sizeFromShape(this.x.shape);
        var shapeSize = util.sizeFromShape(this.shape);
        util.assert(xSize === shapeSize, "Error making reshape operation: input to reshape '" + this.name + "'" +
            (" of shape (" + this.x.shape + ") does not match size of ") +
            ("requested shape " + this.shape + "."));
    };
    ReshapeNode.X = 'x';
    return ReshapeNode;
}(Node));
exports.ReshapeNode = ReshapeNode;
var FusedLinearCombinationNode = (function (_super) {
    __extends(FusedLinearCombinationNode, _super);
    function FusedLinearCombinationNode(graph, t1, t2, c1, c2) {
        var _this = _super.call(this, graph, 'Linear Combination', { t1: t1, t2: t2, c1: c1, c2: c2 }, new Tensor(t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.c1 = c1;
        _this.c2 = c2;
        return _this;
    }
    FusedLinearCombinationNode.prototype.validate = function () {
        util.assertShapesMatch(this.t1.shape, this.t2.shape);
        if (!util.isScalarShape(this.c1.shape)) {
            throw new Error('Error adding fusedLinearCombination: c1 is not a scalar, got ' +
                ("shape: " + this.c1.shape));
        }
        if (!util.isScalarShape(this.c2.shape)) {
            throw new Error('Error adding fusedLinearCombination: c2 is not a scalar, got ' +
                ("shape: " + this.c2.shape));
        }
    };
    FusedLinearCombinationNode.T1 = 't1';
    FusedLinearCombinationNode.T2 = 't2';
    FusedLinearCombinationNode.C1 = 'c1';
    FusedLinearCombinationNode.C2 = 'c2';
    return FusedLinearCombinationNode;
}(Node));
exports.FusedLinearCombinationNode = FusedLinearCombinationNode;
var AddNode = (function (_super) {
    __extends(AddNode, _super);
    function AddNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Add', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    AddNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding add operation op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    AddNode.T1 = 't1';
    AddNode.T2 = 't2';
    return AddNode;
}(Node));
exports.AddNode = AddNode;
var SubtractNode = (function (_super) {
    __extends(SubtractNode, _super);
    function SubtractNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Subtract', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    SubtractNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding subtract op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    SubtractNode.T1 = 't1';
    SubtractNode.T2 = 't2';
    return SubtractNode;
}(Node));
exports.SubtractNode = SubtractNode;
var MultiplyNode = (function (_super) {
    __extends(MultiplyNode, _super);
    function MultiplyNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Multiply', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    MultiplyNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding multiply op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    MultiplyNode.T1 = 't1';
    MultiplyNode.T2 = 't2';
    return MultiplyNode;
}(Node));
exports.MultiplyNode = MultiplyNode;
var DivideNode = (function (_super) {
    __extends(DivideNode, _super);
    function DivideNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Divide', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    DivideNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding divide op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    DivideNode.T1 = 't1';
    DivideNode.T2 = 't2';
    return DivideNode;
}(Node));
exports.DivideNode = DivideNode;
var ReduceSumNode = (function (_super) {
    __extends(ReduceSumNode, _super);
    function ReduceSumNode(graph, x) {
        return _super.call(this, graph, 'ReduceSum', { x: x }, new Tensor([])) || this;
    }
    ReduceSumNode.prototype.validate = function () { };
    ReduceSumNode.X = 'x';
    return ReduceSumNode;
}(Node));
exports.ReduceSumNode = ReduceSumNode;
var Concat3DNode = (function (_super) {
    __extends(Concat3DNode, _super);
    function Concat3DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat3D', { x1: x1, x2: x2 }, new Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat3DNode.prototype.validate = function () {
        concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat3DNode.X1 = 'x1';
    Concat3DNode.X2 = 'x2';
    Concat3DNode.AXIS = 'axis';
    return Concat3DNode;
}(Node));
exports.Concat3DNode = Concat3DNode;
function getMatMulOutputShape(x1Shape, x2Shape) {
    if (x1Shape.length === 1 && x2Shape.length === 1) {
        return [1];
    }
    else if (x1Shape.length === 1 && x2Shape.length === 2) {
        return [x2Shape[1]];
    }
    else if (x1Shape.length === 2 && x2Shape.length === 1) {
        return [x1Shape[0]];
    }
    return [x1Shape[0], x2Shape[1]];
}
var MatMulNode = (function (_super) {
    __extends(MatMulNode, _super);
    function MatMulNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'MatMul', { x1: x1, x2: x2 }, new Tensor(getMatMulOutputShape(x1.shape, x2.shape))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    MatMulNode.prototype.validate = function () {
        if (this.x1.shape.length === 2 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: inner shapes of matrices with shapes ' +
                (this.x1.shape + " and " + this.x2.shape + " must match."));
        }
        else if (this.x1.shape.length === 2 && this.x2.shape.length === 1) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: second dimension of matrix with shape ' +
                this.x1.shape.toString() +
                (" must match size of vector with shape " + this.x2.shape + "."));
        }
        else if (this.x1.shape.length === 1 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[0] === this.x2.shape[0], "Error adding matmul op: size of vector with shape " + this.x1.shape +
                " must match first dimension of matrix with " +
                ("shape " + this.x2.shape + "."));
        }
        else {
            throw new Error('Error adding matmul op: inputs must be vectors or matrices.');
        }
    };
    MatMulNode.X1 = 'x1';
    MatMulNode.X2 = 'x2';
    return MatMulNode;
}(Node));
exports.MatMulNode = MatMulNode;
var Convolution2DNode = (function (_super) {
    __extends(Convolution2DNode, _super);
    function Convolution2DNode(graph, x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Convolution 2D', { x: x, w: w, b: b }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad))) || this;
        _this.x = x;
        _this.w = w;
        _this.b = b;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    Convolution2DNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding conv2d op: input must be of rank 3, but got shape: ' +
            (this.x.shape + "."));
        util.assert(this.w.shape.length === 4, 'Error adding conv2d op: weights must be of rank 4, but got shape: ' +
            (this.w.shape + "."));
        util.assert(this.b.shape.length === 1, 'Error adding conv2d op: biases must be of rank 1, but got shape: ' +
            (this.b.shape + "."));
        util.assert(this.x.shape[2] === this.w.shape[2], "Error adding conv2d op: depth of input (" + this.x.shape[2] + ") " +
            ("must match input depth for weights (" + this.w.shape[2] + ")."));
    };
    Convolution2DNode.X = 'x';
    Convolution2DNode.W = 'w';
    Convolution2DNode.B = 'b';
    return Convolution2DNode;
}(Node));
exports.Convolution2DNode = Convolution2DNode;
var MaxPoolNode = (function (_super) {
    __extends(MaxPoolNode, _super);
    function MaxPoolNode(graph, x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Max pool', { x: x }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, x.shape[2], stride, zeroPad))) || this;
        _this.x = x;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    MaxPoolNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding maxPool op: input must be of rank 3, but got shape: ' +
            (this.x.shape + "."));
    };
    MaxPoolNode.X = 'x';
    return MaxPoolNode;
}(Node));
exports.MaxPoolNode = MaxPoolNode;
var ReLUNode = (function (_super) {
    __extends(ReLUNode, _super);
    function ReLUNode(graph, x) {
        return _super.call(this, graph, 'ReLU', { x: x }, new Tensor(x.shape)) || this;
    }
    ReLUNode.prototype.validate = function () { };
    ReLUNode.X = 'x';
    return ReLUNode;
}(Node));
exports.ReLUNode = ReLUNode;
var LeakyReLUNode = (function (_super) {
    __extends(LeakyReLUNode, _super);
    function LeakyReLUNode(graph, x, alpha) {
        var _this = _super.call(this, graph, 'LeakyReLU', { x: x }, new Tensor(x.shape)) || this;
        _this.alpha = alpha;
        return _this;
    }
    LeakyReLUNode.prototype.validate = function () { };
    LeakyReLUNode.X = 'x';
    return LeakyReLUNode;
}(Node));
exports.LeakyReLUNode = LeakyReLUNode;
var ExpNode = (function (_super) {
    __extends(ExpNode, _super);
    function ExpNode(graph, x) {
        return _super.call(this, graph, 'Exp', { x: x }, new Tensor(x.shape)) || this;
    }
    ExpNode.prototype.validate = function () { };
    ExpNode.X = 'x';
    return ExpNode;
}(Node));
exports.ExpNode = ExpNode;
var LogNode = (function (_super) {
    __extends(LogNode, _super);
    function LogNode(graph, x) {
        return _super.call(this, graph, 'Log', { x: x }, new Tensor(x.shape)) || this;
    }
    LogNode.prototype.validate = function () { };
    LogNode.X = 'x';
    return LogNode;
}(Node));
exports.LogNode = LogNode;
var TanHNode = (function (_super) {
    __extends(TanHNode, _super);
    function TanHNode(graph, x) {
        return _super.call(this, graph, 'TanH', { x: x }, new Tensor(x.shape)) || this;
    }
    TanHNode.prototype.validate = function () { };
    TanHNode.X = 'x';
    return TanHNode;
}(Node));
exports.TanHNode = TanHNode;
var SigmoidNode = (function (_super) {
    __extends(SigmoidNode, _super);
    function SigmoidNode(graph, x) {
        return _super.call(this, graph, 'Sigmoid', { x: x }, new Tensor(x.shape)) || this;
    }
    SigmoidNode.prototype.validate = function () { };
    SigmoidNode.X = 'x';
    return SigmoidNode;
}(Node));
exports.SigmoidNode = SigmoidNode;
var SquareNode = (function (_super) {
    __extends(SquareNode, _super);
    function SquareNode(graph, x) {
        return _super.call(this, graph, 'Square', { x: x }, new Tensor(x.shape)) || this;
    }
    SquareNode.prototype.validate = function () { };
    SquareNode.X = 'x';
    return SquareNode;
}(Node));
exports.SquareNode = SquareNode;
var SoftmaxCrossEntropyCostNode = (function (_super) {
    __extends(SoftmaxCrossEntropyCostNode, _super);
    function SoftmaxCrossEntropyCostNode(graph, x, target) {
        var _this = _super.call(this, graph, 'SoftmaxCrossEntropyCost', { x: x, target: target }, new Tensor([])) || this;
        _this.x = x;
        _this.target = target;
        return _this;
    }
    SoftmaxCrossEntropyCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x.shape, this.target.shape), "Error adding softmaxCrossEntropyCost op: x shape (" + this.x.shape + ") " +
            ("must match target shape (" + this.target.shape + ")."));
    };
    SoftmaxCrossEntropyCostNode.X = 'x';
    SoftmaxCrossEntropyCostNode.TARGET = 'target';
    return SoftmaxCrossEntropyCostNode;
}(Node));
exports.SoftmaxCrossEntropyCostNode = SoftmaxCrossEntropyCostNode;
var SoftmaxNode = (function (_super) {
    __extends(SoftmaxNode, _super);
    function SoftmaxNode(graph, x) {
        var _this = _super.call(this, graph, 'Softmax', { x: x }, new Tensor(x.shape)) || this;
        _this.x = x;
        return _this;
    }
    SoftmaxNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 1, 'The input to a softmax must be a 1-D tensor');
        util.assert(this.x.shape[0] >= 2, 'The input to a softmax must have at least 2 values');
    };
    SoftmaxNode.X = 'x';
    return SoftmaxNode;
}(Node));
exports.SoftmaxNode = SoftmaxNode;
var MeanSquaredCostNode = (function (_super) {
    __extends(MeanSquaredCostNode, _super);
    function MeanSquaredCostNode(graph, label, prediction) {
        var _this = _super.call(this, graph, 'Mean Squared Cost', { label: label, prediction: prediction }, new Tensor([])) || this;
        _this.label = label;
        _this.prediction = prediction;
        return _this;
    }
    MeanSquaredCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.label.shape, this.prediction.shape), "Error adding meanSquaredCost op: label shape (" + this.label.shape + ") " +
            ("must match prediction shape (" + this.prediction.shape + ")."));
    };
    MeanSquaredCostNode.LABEL = 'label';
    MeanSquaredCostNode.PREDICTION = 'prediction';
    return MeanSquaredCostNode;
}(Node));
exports.MeanSquaredCostNode = MeanSquaredCostNode;
var ArgMaxNode = (function (_super) {
    __extends(ArgMaxNode, _super);
    function ArgMaxNode(graph, x) {
        var _this = _super.call(this, graph, 'ArgMax', { x: x }, new Tensor([1])) || this;
        _this.x = x;
        return _this;
    }
    ArgMaxNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.x.shape) > 0, 'Error adding argmax op: input tensor must have at least one entry.');
    };
    ArgMaxNode.X = 'x';
    return ArgMaxNode;
}(Node));
exports.ArgMaxNode = ArgMaxNode;
var ArgMaxEqualsNode = (function (_super) {
    __extends(ArgMaxEqualsNode, _super);
    function ArgMaxEqualsNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'ArgMaxEquals', { x1: x1, x2: x2 }, new Tensor([1])) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    ArgMaxEqualsNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x1.shape, this.x2.shape), "Error adding ArgMaxEquals op: x1 shape (" + this.x1.shape + ") " +
            ("must match x2 shape (" + this.x2.shape + ")."));
    };
    ArgMaxEqualsNode.X1 = 'x1';
    ArgMaxEqualsNode.X2 = 'x2';
    return ArgMaxEqualsNode;
}(Node));
exports.ArgMaxEqualsNode = ArgMaxEqualsNode;
//# sourceMappingURL=graph.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util = __webpack_require__(4);
function assertParams(aShape, bShape, axis) {
    var aRank = aShape.length;
    var bRank = bShape.length;
    util.assert(aShape.length === bShape.length, "Error in concat" + aRank + "D: rank of x1 (" + aRank + ") and x2 (" + bRank + ") " +
        "must be the same.");
    util.assert(axis >= 0 && axis < aRank, "Error in concat" + aRank + "D: axis must be " +
        ("between 0 and " + (aRank - 1) + "."));
    for (var i = 0; i < aRank; i++) {
        util.assert((i === axis) || (aShape[i] === bShape[i]), "Error in concat" + aRank + "D: Shape (" + aShape + ") does not match " +
            ("(" + bShape + ") along the non-concatenated axis " + i + "."));
    }
}
exports.assertParams = assertParams;
function computeOutShape(x1Shape, x2Shape, axis) {
    util.assert(x1Shape.length === x2Shape.length, 'x1 and x2 should have the same rank.');
    var outputShape = x1Shape.slice();
    outputShape[axis] += x2Shape[axis];
    return outputShape;
}
exports.computeOutShape = computeOutShape;
//# sourceMappingURL=concat_util.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = __webpack_require__(32);
var util = __webpack_require__(4);
var broadcast_util = __webpack_require__(56);
var tex_util = __webpack_require__(67);
var tex_util_1 = __webpack_require__(67);
function makeShader(inputsInfo, outputShape, userCode, broadcast) {
    var sampleSnippet = getSampleSnippet();
    var setOutputSnippet = getSetOutputSnippet();
    var inputPrefixSnippet = inputsInfo.map(function (x) { return "uniform sampler2D " + x.name + ";"; }).join('\n');
    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
        .join('\n');
    var outTexShape = outputShape.texShape;
    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    var source = [
        SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,
        outputSamplingSnippet, inputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
exports.makeShader = makeShader;
function getSampleSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SAMPLE_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;
}
function getSetOutputSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SETOUTPUT_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;
}
function getSamplerFromInInfo(inInfo) {
    var shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 0:
            return getSamplerScalar(inInfo);
        case 1:
            return getSampler1D(inInfo);
        case 2:
            return getSampler2D(inInfo);
        case 3:
            return getSampler3D(inInfo);
        case 4:
            return getSampler4D(inInfo);
        default:
            throw new Error(shape.length + "-D input sampling" +
                " is not yet supported");
    }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
    var res = getSamplerFlat(inInfo);
    res += getSamplerFromInInfo(inInfo);
    if (broadcast ||
        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);
    }
    return res;
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output sampling is not yet supported");
    }
}
var SAMPLE_1D_SNIPPET = "\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_2D_SNIPPET = "\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_3D_SNIPPET = "\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_4D_SNIPPET = "\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = "\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = " + tex_util.FLOAT_MIN + ".0;\n  const float maxValue = " + tex_util.FLOAT_MAX + ".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sample(sampler2D texture, vec2 uv) {\n    vec4 sampleValue = texture2D(texture, uv);\n    if (all(equal(sampleValue, vec4(" + tex_util.BYTE_NAN_VALUE + ")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n";
var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = "\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(" + tex_util.BYTE_NAN_VALUE + ");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n";
var FLOAT_TEXTURE_SAMPLE_SNIPPET = "\n  float sample(sampler2D texture, vec2 uv) {\n    return texture2D(texture, uv).r;\n  }\n";
var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = "\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";
var SHADER_PREFIX = "\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    return val == val ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    return any(notEqual(values, values));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  const vec2 randomConst = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n     2.665144142690225 // 2^sqrt(2) (Gelfond\u2013Schneider constant)\n  );\n\n  float random(float seed) {\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\n  }\n\n  float sampleUVAndDepth(sampler2D texture, vec2 uv, int depth) {\n    float value;\n    if (depth == 0) {\n      value = texture2D(texture, uv).r;\n    } else if (depth == 1) {\n      value = texture2D(texture, uv).g;\n    } else if (depth == 2) {\n      value = texture2D(texture, uv).b;\n    } else if (depth == 3) {\n      value = texture2D(texture, uv).a;\n    }\n    return floor(value * 255.0 + 0.5);\n  }\n\n  " + SAMPLE_1D_SNIPPET + "\n  " + SAMPLE_2D_SNIPPET + "\n  " + SAMPLE_3D_SNIPPET + "\n  " + SAMPLE_4D_SNIPPET + "\n";
function getOutputScalarCoords() {
    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
}
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + texShape[1] + ".0);\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + texShape[0] + ".0);\n      }\n    ";
    }
    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      return resTexRC.x * " + texShape[1] + " + resTexRC.y;\n    }\n  ";
}
function getOutput3DCoords(shape, texShape) {
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n      int c = index / " + stride1 + ";\n      int d = index - c * " + stride1 + ";\n      return ivec3(r, c, d);\n    }\n  ";
}
function getOutput4DCoords(shape, texShape) {
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      int d2 = index - d * " + stride2 + ";\n\n      return ivec4(r, c, d, d2);\n    }\n  ";
}
function getOutput2DCoords(shape, texShape) {
    if (util.arraysEqual(shape, texShape)) {
        return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + texShape[0] + ", " + texShape[1] + "));\n      }\n    ";
    }
    if (shape[1] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
    }
    if (shape[0] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
    }
    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + shape[1] + ";\n      int c = index - r * " + shape[1] + ";\n      return ivec2(r, c);\n    }\n  ";
}
function getSamplerScalar(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "() {\n      return sample(" + texName + ", halfCR);\n    }\n  ";
}
function getSampler1D(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "(int index) {\n      return " + funcName + "Flat(index);\n    }\n  ";
}
function getSampler2D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (util.arraysEqual(shape, texShape)) {
        return "\n    float " + funcName + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    if (texNumR === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2((float(index) + 0.5) / " + texNumC + ".0, 0.5);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    return "\n  float " + funcName + "(int row, int col) {\n    vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n    return sample(" + texName + ", uv);\n  }\n";
}
function getSampler3D(inputInfo) {
    var texShape = inputInfo.shapeInfo.texShape;
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    var texType = inputInfo.shapeInfo.textureType;
    if (texType === tex_util_1.TextureType.DEFAULT) {
        var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
        var squeezedShape = newShape;
        if (squeezedShape.length < shape.length) {
            var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
            var params = ['row', 'col', 'depth'];
            return "\n        " + getSamplerFromInInfo(newInputInfo) + "\n        float " + funcName + "(int row, int col, int depth) {\n          return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n        }\n      ";
        }
    }
    if (texNumC === stride0) {
        if (texType === tex_util_1.TextureType.DEFAULT) {
            return "\n        float " + funcName + "(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * " + stride1 + " + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sample(" + texName + ", uv);\n        }\n      ";
        }
        else if (texType === tex_util_1.TextureType.RGBA_COLOR) {
            return "\n        float " + funcName + "(int row, int col, int depth) {\n          vec2 uv = (vec2(col, row) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sampleUVAndDepth(" + texName + ", uv, depth);\n        }\n      ";
        }
        else {
            throw new Error("Unknown TextureType " + texType + ".");
        }
    }
    if (texNumC === stride1 && texType === tex_util_1.TextureType.DEFAULT) {
        return "\n    float " + funcName + "(int row, int col, int depth) {\n      int texR = row * " + shape[1] + " + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    if (texType === tex_util_1.TextureType.DEFAULT) {
        return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            " + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ", row, col, depth);\n        return sample(" + texName + ", uv);\n      }\n  ";
    }
    else if (texType === tex_util_1.TextureType.RGBA_COLOR) {
        return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n        return sampleUVAndDepth(" + texName + ", uv, depth);\n      }\n    ";
    }
    else {
        throw new Error("Unknown TextureType " + texType + ".");
    }
}
function getSampler4D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride2) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", row, col, depth, depth2);\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getSamplerFlat(inputInfo) {
    var texName = inputInfo.name;
    var texShape = inputInfo.shapeInfo.texShape;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';
    var tNumR = texShape[0];
    var tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        return sample(" + texName + ", halfCR);\n      }\n    ";
    }
    if (tNumC === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    if (tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / " + tNumC + ".0, 0.5);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int index) {\n      vec2 uv = UVfrom1D(" + tNumR + ", " + tNumC + ", index);\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var type = 'int';
    if (outRank === 2) {
        type = 'ivec2';
    }
    else if (outRank === 3) {
        type = 'ivec3';
    }
    else if (outRank === 4) {
        type = 'ivec4';
    }
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var rankDiff = outRank - inRank;
    var coordsSnippet;
    if (inRank === 0) {
        coordsSnippet = '';
    }
    else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = 'coords = 0;';
    }
    else {
        coordsSnippet =
            broadcastDims.map(function (d) { return "coords[" + (d + rankDiff) + "] = 0;"; }).join('\n');
    }
    var unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
            .map(function (s, i) { return "coords[" + (i + rankDiff) + "]"; })
            .join(', ');
    }
    return "\n    float " + funcName + "() {\n      " + type + " coords = getOutputCoords();\n      " + coordsSnippet + "\n      return get" + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n    }\n  ";
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
    var inTexShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var isRGBAColorTexture = inputInfo.shapeInfo.textureType === tex_util_1.TextureType.RGBA_COLOR;
    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);
    var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
    if (doBroadcast && !broadcastOverOuter) {
        return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);
    }
    var outTexShape = outShapeInfo.texShape;
    if (util.arraysEqual(inTexShape, outTexShape) && !isRGBAColorTexture) {
        return "\n      float " + funcName + "() {\n        return sample(" + texName + ", resultUV);\n      }\n    ";
    }
    var inTexExpandedShape = isRGBAColorTexture ?
        [inTexShape[0], inTexShape[1] * inputInfo.shapeInfo.logicalShape[2]] :
        inTexShape;
    var sampleSnippet = "return sample(" + texName + ", uv);";
    var rgbaColorSnippet = '';
    if (isRGBAColorTexture) {
        rgbaColorSnippet = "\n      int col = texC / " + inputInfo.shapeInfo.logicalShape[2] + ";\n      int texD = texC - col * " + inputInfo.shapeInfo.logicalShape[2] + ";\n      texC = col;\n    ";
        sampleSnippet = "return sampleUVAndDepth(" + texName + ", uv, texD);";
    }
    var inSize = util.sizeFromShape(inTexExpandedShape);
    var broadcastSnippet = '';
    if (doBroadcast && broadcastOverOuter) {
        broadcastSnippet = "\n        int mainPart = index / " + inSize + ";\n        index -= mainPart * " + inSize + ";\n      ";
    }
    return "\n    float " + funcName + "() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n      int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n      " + broadcastSnippet + "\n      int texR = index / " + inTexExpandedShape[1] + ";\n      int texC = index - texR * " + inTexExpandedShape[1] + ";\n\n      " + rgbaColorSnippet + "\n\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n\n      " + sampleSnippet + "\n    }\n  ";
}
function getCoordsDataType(rank) {
    if (rank === 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else {
        throw Error("GPU for rank " + rank + " is not yet supported");
    }
}
exports.getCoordsDataType = getCoordsDataType;
function squeezeInputInfo(inInfo, squeezedShape) {
    var newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
    return keptDims.map(function (d) { return params[d]; }).join(', ');
}
//# sourceMappingURL=shader_compiler.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TextureType;
(function (TextureType) {
    TextureType[TextureType["DEFAULT"] = 0] = "DEFAULT";
    TextureType[TextureType["RGBA_COLOR"] = 1] = "RGBA_COLOR";
})(TextureType = exports.TextureType || (exports.TextureType = {}));
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error("unpackedSize (" + unpackedSize + ") must be a multiple of " +
            ("" + channelsPerTexture));
    }
    return unpackedSize / channelsPerTexture;
}
exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
    if (unpackedArray.length < requiredSize) {
        throw new Error("unpackedArray length (" + unpackedArray.length + ") must be >= " +
            ("" + requiredSize));
    }
    var dst = 0;
    for (var src = 0; src < matrix.length; ++src) {
        unpackedArray[dst] = matrix[src];
        dst += channelsPerTexture;
    }
}
exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
exports.FLOAT_MAX = 20000;
exports.FLOAT_MIN = -exports.FLOAT_MAX;
var FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;
var FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];
var FLOAT_POWERS = [1, 255, 255 * 255];
exports.BYTE_NAN_VALUE = 0;
function encodeFloatArray(floatArray) {
    var uintArray = new Uint8Array(floatArray.length * 4);
    var _loop_1 = function (i) {
        var value = floatArray[i / 4];
        if (isNaN(value)) {
            uintArray[i] = exports.BYTE_NAN_VALUE;
            uintArray[i + 1] = exports.BYTE_NAN_VALUE;
            uintArray[i + 2] = exports.BYTE_NAN_VALUE;
            uintArray[i + 3] = exports.BYTE_NAN_VALUE;
            return "continue";
        }
        var normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;
        var enc = FLOAT_POWERS.map(function (pow) { return pow * normalizedValue; });
        var buckets = enc.map(function (value) { return Math.floor((value % 1) * 255); });
        uintArray[i] = Math.floor(normalizedValue);
        uintArray[i + 1] = buckets[0];
        uintArray[i + 2] = buckets[1];
        uintArray[i + 3] = buckets[2];
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_1(i);
    }
    return uintArray;
}
exports.encodeFloatArray = encodeFloatArray;
function decodeToFloatArray(uintArray) {
    var floatArray = new Float32Array(uintArray.length / 4);
    var _loop_2 = function (i) {
        if (uintArray[i] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 1] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 2] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 3] === exports.BYTE_NAN_VALUE) {
            floatArray[i / 4] = NaN;
            return "continue";
        }
        var dot = 0;
        FLOAT_DELTAS.forEach(function (delta, j) {
            dot += delta * uintArray[i + j];
        });
        var value = dot * FLOAT_RANGE + exports.FLOAT_MIN;
        floatArray[i / 4] = value;
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_2(i);
    }
    return floatArray;
}
exports.decodeToFloatArray = decodeToFloatArray;
function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
        matrix[dst++] = unpackedArray[src];
    }
}
exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
    var requiredSize = unpackedArray.length * channels / 4;
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += 4) {
        for (var c = 0; c < channels; c++) {
            matrix[dst++] = unpackedArray[src + c];
        }
    }
}
exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
}
exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    return w * h * 4;
}
exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
    if (packedRGBA.length < requiredSize) {
        throw new Error("packedRGBA length (" + packedRGBA.length + ") must be >= " + requiredSize);
    }
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    {
        var dstStride = (oddWidth ? 4 : 0);
        var oneRow = columns;
        var dst = 0;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            var matrixSrcRow = (blockY * 2 * columns);
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                var matrixSrcCol = blockX * 2;
                var src = matrixSrcRow + matrixSrcCol;
                packedRGBA[dst] = matrix[src];
                packedRGBA[dst + 1] = matrix[src + 1];
                packedRGBA[dst + 2] = matrix[src + oneRow];
                packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                dst += 4;
            }
            dst += dstStride;
        }
    }
    if (oddWidth) {
        var src = columns - 1;
        var dst = (textureWidth - 1) * 4;
        var srcStride = 2 * columns;
        var dstStride = textureWidth * 4;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            packedRGBA[dst] = matrix[src];
            packedRGBA[dst + 2] = matrix[src + columns];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (rows - 1) * columns;
        var dst = (textureHeight - 1) * textureWidth * 4;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            packedRGBA[dst++] = matrix[src++];
            packedRGBA[dst++] = matrix[src++];
            dst += 2;
        }
    }
    if (oddWidth && oddHeight) {
        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
    }
    return packedRGBA;
}
exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
    var requiredSize = rows * columns;
    if (requiredSize < matrix.length) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    {
        var srcStride = oddWidth ? 4 : 0;
        var dstStride = columns + (oddWidth ? 1 : 0);
        var src = 0;
        var dstRow1 = 0;
        var dstRow2 = columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
            }
            src += srcStride;
            dstRow1 += dstStride;
            dstRow2 += dstStride;
        }
    }
    if (oddWidth) {
        var src = (textureWidth - 1) * 4;
        var dst = columns - 1;
        var srcStride = textureWidth * 4;
        var dstStride = 2 * columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            matrix[dst] = packedRGBA[src];
            matrix[dst + columns] = packedRGBA[src + 2];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (textureHeight - 1) * textureWidth * 4;
        var dst = (rows - 1) * columns;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            matrix[dst++] = packedRGBA[src++];
            matrix[dst++] = packedRGBA[src++];
            src += 2;
        }
    }
    if (oddWidth && oddHeight) {
        matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
    }
    return matrix;
}
exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;
//# sourceMappingURL=tex_util.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _random = __webpack_require__(167);

Object.keys(_random).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _random[key];
    }
  });
});

var _math = __webpack_require__(111);

Object.keys(_math).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _math[key];
    }
  });
});

var _sample = __webpack_require__(168);

Object.keys(_sample).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _sample[key];
    }
  });
});

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(20);
var toLength = __webpack_require__(10);
var toAbsoluteIndex = __webpack_require__(48);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(16);
var redefineAll = __webpack_require__(46);
var meta = __webpack_require__(37);
var forOf = __webpack_require__(40);
var anInstance = __webpack_require__(39);
var isObject = __webpack_require__(5);
var fails = __webpack_require__(3);
var $iterDetect = __webpack_require__(75);
var setToStringTag = __webpack_require__(53);
var inheritIfRequired = __webpack_require__(90);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(15);
var redefine = __webpack_require__(16);
var fails = __webpack_require__(3);
var defined = __webpack_require__(28);
var wks = __webpack_require__(7);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(1);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(23);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(5);
var cof = __webpack_require__(23);
var MATCH = __webpack_require__(7)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(7)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Forced replacement prototype accessors methods
module.exports = __webpack_require__(41) || !__webpack_require__(3)(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete __webpack_require__(2)[K];
});


/***/ }),
/* 77 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(13);
var ctx = __webpack_require__(24);
var forOf = __webpack_require__(40);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(13);
var SPECIES = __webpack_require__(7)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(15);
var uid = __webpack_require__(49);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(11);
var toAbsoluteIndex = __webpack_require__(48);
var toLength = __webpack_require__(10);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(171);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(9);
var createDesc = __webpack_require__(45);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
var document = __webpack_require__(2).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 87 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(7)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(2).document;
module.exports = document && document.documentElement;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
var setPrototypeOf = __webpack_require__(98).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(52);
var ITERATOR = __webpack_require__(7)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(42);
var descriptor = __webpack_require__(45);
var setToStringTag = __webpack_require__(53);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(15)(IteratorPrototype, __webpack_require__(7)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(41);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(16);
var hide = __webpack_require__(15);
var has = __webpack_require__(14);
var Iterators = __webpack_require__(52);
var $iterCreate = __webpack_require__(92);
var setToStringTag = __webpack_require__(53);
var getPrototypeOf = __webpack_require__(19);
var ITERATOR = __webpack_require__(7)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 94 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),
/* 95 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var macrotask = __webpack_require__(104).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(23)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(13);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(5);
var anObject = __webpack_require__(1);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(24)(Function.call, __webpack_require__(18).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(80)('keys');
var uid = __webpack_require__(49);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(30);
var defined = __webpack_require__(28);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(74);
var defined = __webpack_require__(28);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(30);
var defined = __webpack_require__(28);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(24);
var invoke = __webpack_require__(122);
var html = __webpack_require__(89);
var cel = __webpack_require__(86);
var global = __webpack_require__(2);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(23)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var DESCRIPTORS = __webpack_require__(8);
var LIBRARY = __webpack_require__(41);
var $typed = __webpack_require__(82);
var hide = __webpack_require__(15);
var redefineAll = __webpack_require__(46);
var fails = __webpack_require__(3);
var anInstance = __webpack_require__(39);
var toInteger = __webpack_require__(30);
var toLength = __webpack_require__(10);
var toIndex = __webpack_require__(140);
var gOPN = __webpack_require__(43).f;
var dP = __webpack_require__(9).f;
var arrayFill = __webpack_require__(83);
var setToStringTag = __webpack_require__(53);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(27);
var LIBRARY = __webpack_require__(41);
var wksExt = __webpack_require__(141);
var defineProperty = __webpack_require__(9).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(61);
var ITERATOR = __webpack_require__(7)('iterator');
var Iterators = __webpack_require__(52);
module.exports = __webpack_require__(27).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(36);
var step = __webpack_require__(125);
var Iterators = __webpack_require__(52);
var toIObject = __webpack_require__(20);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(93)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function axesAreInnerMostDims(axes, rank) {
    for (var i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
        }
    }
    return true;
}
exports.axesAreInnerMostDims = axesAreInnerMostDims;
function combineLocations(outputLoc, reduceLoc, axes) {
    var rank = outputLoc.length + reduceLoc.length;
    var loc = [];
    var outIdx = 0;
    var reduceIdx = 0;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            loc.push(outputLoc[outIdx++]);
        }
        else {
            loc.push(reduceLoc[reduceIdx++]);
        }
    }
    return loc;
}
exports.combineLocations = combineLocations;
function computeOutAndReduceShapes(aShape, axes) {
    var outShape = [];
    var rank = aShape.length;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            outShape.push(aShape[dim]);
        }
    }
    var reduceShape = axes.map(function (dim) { return aShape[dim]; });
    return [outShape, reduceShape];
}
exports.computeOutAndReduceShapes = computeOutAndReduceShapes;
function expandShapeToKeepDim(shape, axes) {
    var reduceSubShape = axes.map(function (x) { return 1; });
    return combineLocations(shape, reduceSubShape, axes);
}
exports.expandShapeToKeepDim = expandShapeToKeepDim;
function parseAxisParam(axis, shape) {
    if (axis == null) {
        axis = shape.map(function (s, i) { return i; });
    }
    else if (typeof (axis) === 'number') {
        axis = [axis];
    }
    return axis;
}
exports.parseAxisParam = parseAxisParam;
function assertAxesAreInnerMostDims(msg, axes, rank) {
    if (!axesAreInnerMostDims(axes, rank)) {
        throw new Error(msg + " supports only inner-most axes for now. " +
            ("Got axes " + axes + " and rank-" + rank + " input."));
    }
}
exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;
function getPermutedAxes(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
        return null;
    }
    var result = [];
    for (var i = 0; i < rank; ++i) {
        if (axes.indexOf(i) === -1) {
            result.push(i);
        }
    }
    axes.forEach(function (axis) { return result.push(axis); });
    return result;
}
exports.getPermutedAxes = getPermutedAxes;
function getInnerMostAxes(numAxes, rank) {
    var res = [];
    for (var i = rank - numAxes; i < rank; ++i) {
        res.push(i);
    }
    return res;
}
exports.getInnerMostAxes = getInnerMostAxes;
//# sourceMappingURL=axis_util.js.map

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = __webpack_require__(32);
var tex_util = __webpack_require__(67);
var webgl_util = __webpack_require__(58);
function getWebGLContextAttributes() {
    return {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        depth: false,
        stencil: false,
        failIfMajorPerformanceCaveat: true
    };
}
exports.getWebGLContextAttributes = getWebGLContextAttributes;
function createWebGLContext(canvas) {
    var attributes = getWebGLContextAttributes();
    var gl;
    if (canvas != null) {
        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
    }
    else {
        gl = webgl_util.createWebGLRenderingContext(attributes);
    }
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
    return gl;
}
exports.createWebGLContext = createWebGLContext;
function createVertexShader(gl) {
    var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
    return webgl_util.createVertexShader(gl, vertexShaderSource);
}
exports.createVertexShader = createVertexShader;
function createVertexBuffer(gl) {
    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return webgl_util.createStaticVertexBuffer(gl, vertexArray);
}
exports.createVertexBuffer = createVertexBuffer;
function createIndexBuffer(gl) {
    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
}
exports.createIndexBuffer = createIndexBuffer;
function getTextureInternalFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA32F;
        }
        return gl.R32F;
    }
    return gl.RGBA;
}
function getTextureFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA;
        }
        return gl.RED;
    }
    return gl.RGBA;
}
function getTextureType(gl) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.UNSIGNED_BYTE;
    }
    return gl.FLOAT;
}
function createAndConfigureTexture(gl, width, height, numChannels) {
    webgl_util.validateTextureSize(gl, width, height);
    var texture = webgl_util.createTexture(gl);
    var tex2d = gl.TEXTURE_2D;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    var format = getTextureFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
    return texture;
}
function createMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 1;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createMatrixTexture = createMatrixTexture;
function createColorMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createColorMatrixTexture = createColorMatrixTexture;
function createPackedMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createPackedMatrixTexture = createPackedMatrixTexture;
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer, attribLocations) {
    var posOffset = 0;
    var uvOffset = 3 * 4;
    var stride = (3 * 4) + (2 * 4);
    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset, attribLocations);
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset, attribLocations);
}
exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
function uploadPixelDataToTexture(gl, texture, pixels) {
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
    var textureFormat = getTextureFormat(gl, numChannels);
    webgl_util.validateTextureSize(gl, width, height);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var unpackedArray;
    if (environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
        if (channelsPerTexture === 1) {
            unpackedArray = matrix;
        }
        else {
            unpackedArray =
                new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
            tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
        }
    }
    else {
        unpackedArray = tex_util.encodeFloatArray(matrix);
    }
    uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
}
exports.uploadMatrixToTexture = uploadMatrixToTexture;
function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
    var numChannels = 4;
    uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
}
exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
function getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    var downloadTarget;
    if (isFloatTexture) {
        downloadTarget =
            new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));
    }
    else {
        downloadTarget = new Uint8Array(rows * columns * channelsPerTexture);
    }
    return downloadTarget;
}
function decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    if (isFloatTexture) {
        var matrix = new Float32Array(rows * columns);
        tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);
        return matrix;
    }
    else {
        return tex_util.decodeToFloatArray(downloadTarget);
    }
}
function downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {
    return __awaiter(this, void 0, void 0, function () {
        var gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    gl2 = gl;
                    channelsPerPixel = 4;
                    downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                    bufferSizeBytes = downloadTarget instanceof Float32Array ?
                        downloadTarget.length * 4 :
                        downloadTarget;
                    buffer = gl.createBuffer();
                    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer); });
                    webgl_util.callAndCheck(gl, function () { return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW); });
                    webgl_util.callAndCheck(gl, function () {
                        return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0);
                    });
                    return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];
                case 1:
                    _a.sent();
                    return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)];
            }
        });
    });
}
exports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;
function downloadMatrixFromOutputTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerPixel = 4;
    var downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget); });
    return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel);
}
exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;
function downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {
    var size = rows * columns * 4;
    var downloadTarget = new Uint8Array(size);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget); });
    var packedRGBA = new Float32Array(size);
    for (var i = 0; i < downloadTarget.length; i++) {
        packedRGBA[i] = downloadTarget[i];
    }
    var matrix = new Float32Array(rows * columns * channels);
    tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);
    return matrix;
}
exports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;
function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA); });
    var matrix = new Float32Array(rows * columns);
    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
}
exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;
//# sourceMappingURL=gpgpu_util.js.map

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.math = undefined;

var _deeplearn = __webpack_require__(38);

var math = new _deeplearn.NDArrayMathGPU(); // Math deeplearn

exports.math = math;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(23);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(11);
var toAbsoluteIndex = __webpack_require__(48);
var toLength = __webpack_require__(10);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(40);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(13);
var toObject = __webpack_require__(11);
var IObject = __webpack_require__(62);
var toLength = __webpack_require__(10);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(13);
var isObject = __webpack_require__(5);
var invoke = __webpack_require__(122);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(9).f;
var create = __webpack_require__(42);
var redefineAll = __webpack_require__(46);
var ctx = __webpack_require__(24);
var anInstance = __webpack_require__(39);
var forOf = __webpack_require__(40);
var $iterDefine = __webpack_require__(93);
var step = __webpack_require__(125);
var setSpecies = __webpack_require__(47);
var DESCRIPTORS = __webpack_require__(8);
var fastKey = __webpack_require__(37).fastKey;
var validate = __webpack_require__(55);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(61);
var from = __webpack_require__(114);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(46);
var getWeak = __webpack_require__(37).getWeak;
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(5);
var anInstance = __webpack_require__(39);
var forOf = __webpack_require__(40);
var createArrayMethod = __webpack_require__(26);
var $has = __webpack_require__(14);
var validate = __webpack_require__(55);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = __webpack_require__(73);
var isObject = __webpack_require__(5);
var toLength = __webpack_require__(10);
var ctx = __webpack_require__(24);
var IS_CONCAT_SPREADABLE = __webpack_require__(7)('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(8) && !__webpack_require__(3)(function () {
  return Object.defineProperty(__webpack_require__(86)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 122 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(5);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(1);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(95);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),
/* 127 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),
/* 128 */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(44);
var gOPS = __webpack_require__(77);
var pIE = __webpack_require__(63);
var toObject = __webpack_require__(11);
var IObject = __webpack_require__(62);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(3)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(9);
var anObject = __webpack_require__(1);
var getKeys = __webpack_require__(44);

module.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(20);
var gOPN = __webpack_require__(43).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(14);
var toIObject = __webpack_require__(20);
var arrayIndexOf = __webpack_require__(69)(false);
var IE_PROTO = __webpack_require__(99)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(44);
var toIObject = __webpack_require__(20);
var isEnum = __webpack_require__(63).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(43);
var gOPS = __webpack_require__(77);
var anObject = __webpack_require__(1);
var Reflect = __webpack_require__(2).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(2).parseFloat;
var $trim = __webpack_require__(54).trim;

module.exports = 1 / $parseFloat(__webpack_require__(103) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(2).parseInt;
var $trim = __webpack_require__(54).trim;
var ws = __webpack_require__(103);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var isObject = __webpack_require__(5);
var newPromiseCapability = __webpack_require__(97);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(10);
var repeat = __webpack_require__(102);
var defined = __webpack_require__(28);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(30);
var toLength = __webpack_require__(10);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(7);


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(117);
var validate = __webpack_require__(55);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(70)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(8) && /./g.flags != 'g') __webpack_require__(9).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(72)
});


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(117);
var validate = __webpack_require__(55);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(70)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each = __webpack_require__(26)(0);
var redefine = __webpack_require__(16);
var meta = __webpack_require__(37);
var assign = __webpack_require__(129);
var weak = __webpack_require__(119);
var isObject = __webpack_require__(5);
var fails = __webpack_require__(3);
var validate = __webpack_require__(55);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(70)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var STATS_SAMPLE_PERCENTAGE = 0.1;
var InMemoryDataset = (function () {
    function InMemoryDataset(dataShapes) {
        this.dataShapes = dataShapes;
        this.normalizationInfo = {};
    }
    InMemoryDataset.prototype.getDataShape = function (dataIndex) {
        return this.dataShapes[dataIndex];
    };
    InMemoryDataset.prototype.getData = function () {
        return this.dataset;
    };
    InMemoryDataset.prototype.getStats = function () {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        return this.dataset.map(function (d) { return _this.getStatsForData(d); });
    };
    InMemoryDataset.prototype.getStatsForData = function (data) {
        var inputMin = Number.POSITIVE_INFINITY;
        var inputMax = Number.NEGATIVE_INFINITY;
        var exampleIndices = data.map(function (example, i) { return i; });
        util.shuffle(exampleIndices);
        exampleIndices =
            exampleIndices.slice(exampleIndices.length * STATS_SAMPLE_PERCENTAGE);
        for (var i = 0; i < exampleIndices.length; i++) {
            var inputValues = data[exampleIndices[i]].getValues();
            for (var j = 0; j < inputValues.length; j++) {
                inputMin = Math.min(inputMin, inputValues[j]);
                inputMax = Math.max(inputMax, inputValues[j]);
            }
        }
        return {
            inputMin: inputMin,
            inputMax: inputMax,
            exampleCount: data.length,
            shape: data[0].shape,
        };
    };
    InMemoryDataset.prototype.normalizeExamplesToRange = function (examples, curLowerBounds, curUpperBounds, newLowerBounds, newUpperBounds) {
        var curBoundsIsPerDimension = (curUpperBounds instanceof Float32Array &&
            curLowerBounds instanceof Float32Array);
        var newBoundsIsPerDimension = (newLowerBounds instanceof Float32Array &&
            newUpperBounds instanceof Float32Array);
        var inputSize = util.sizeFromShape(examples[0].shape);
        var newExamples = [];
        examples.forEach(function (example) {
            var inputValues = example.getValues();
            var normalizedValues = new Float32Array(inputSize);
            for (var j = 0; j < inputSize; j++) {
                var curLowerBound = curBoundsIsPerDimension ?
                    curLowerBounds[j] :
                    curLowerBounds;
                var curUpperBound = curBoundsIsPerDimension ?
                    curUpperBounds[j] :
                    curUpperBounds;
                var curRange = curUpperBound - curLowerBound;
                var newLowerBound = newBoundsIsPerDimension ?
                    newLowerBounds[j] :
                    newLowerBounds;
                var newUpperBound = newBoundsIsPerDimension ?
                    newUpperBounds[j] :
                    newUpperBounds;
                var newRange = newUpperBound - newLowerBound;
                if (curRange === 0) {
                    normalizedValues[j] = newLowerBound;
                }
                else {
                    normalizedValues[j] = newLowerBound +
                        newRange * (inputValues[j] - curLowerBound) / curRange;
                }
            }
            newExamples.push(ndarray_1.NDArray.make(example.shape, { values: normalizedValues }));
        });
        return newExamples;
    };
    InMemoryDataset.prototype.computeBounds = function (dataIndex) {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        var size = util.sizeFromShape(this.dataset[dataIndex][0].shape);
        this.normalizationInfo[dataIndex] = {
            isNormalized: false,
            minValues: new Float32Array(size),
            maxValues: new Float32Array(size)
        };
        for (var i = 0; i < size; i++) {
            this.normalizationInfo[dataIndex].minValues[i] = Number.POSITIVE_INFINITY;
            this.normalizationInfo[dataIndex].maxValues[i] = Number.NEGATIVE_INFINITY;
        }
        this.dataset[dataIndex].forEach(function (example) {
            var inputValues = example.getValues();
            for (var k = 0; k < size; k++) {
                _this.normalizationInfo[dataIndex].minValues[k] = Math.min(_this.normalizationInfo[dataIndex].minValues[k], inputValues[k]);
                _this.normalizationInfo[dataIndex].maxValues[k] = Math.max(_this.normalizationInfo[dataIndex].maxValues[k], inputValues[k]);
            }
        });
    };
    InMemoryDataset.prototype.normalizeWithinBounds = function (dataIndex, lowerBound, upperBound) {
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        if (dataIndex >= this.dataset.length) {
            throw new Error('dataIndex out of bounds.');
        }
        if (this.normalizationInfo[dataIndex] == null) {
            this.computeBounds(dataIndex);
        }
        var curLowerBounds;
        var curUpperBounds;
        if (this.normalizationInfo[dataIndex].isNormalized) {
            curLowerBounds = this.normalizationInfo[dataIndex].lowerBound;
            curUpperBounds = this.normalizationInfo[dataIndex].upperBound;
        }
        else {
            curLowerBounds = this.normalizationInfo[dataIndex].minValues;
            curUpperBounds = this.normalizationInfo[dataIndex].maxValues;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], curLowerBounds, curUpperBounds, lowerBound, upperBound);
        this.normalizationInfo[dataIndex].isNormalized = true;
        this.normalizationInfo[dataIndex].lowerBound = lowerBound;
        this.normalizationInfo[dataIndex].upperBound = upperBound;
    };
    InMemoryDataset.prototype.isNormalized = function (dataIndex) {
        return this.normalizationInfo != null &&
            this.normalizationInfo[dataIndex].isNormalized;
    };
    InMemoryDataset.prototype.removeNormalization = function (dataIndex) {
        if (this.dataset == null) {
            throw new Error('Training or test data is null.');
        }
        if (!this.isNormalized(dataIndex)) {
            return;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
        this.normalizationInfo[dataIndex].isNormalized = false;
    };
    InMemoryDataset.prototype.unnormalizeExamples = function (examples, dataIndex) {
        if (!this.isNormalized(dataIndex)) {
            return examples;
        }
        return this.normalizeExamplesToRange(examples, this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
    };
    InMemoryDataset.prototype.dispose = function () {
        if (this.dataset == null) {
            return;
        }
        for (var i = 0; i < this.dataset.length; i++) {
            for (var j = 0; j < this.dataset[i].length; j++) {
                this.dataset[i][j].dispose();
            }
        }
        this.dataset = [];
    };
    return InMemoryDataset;
}());
exports.InMemoryDataset = InMemoryDataset;
//# sourceMappingURL=dataset.js.map

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var dataset_1 = __webpack_require__(146);
var PARSING_IMAGE_CANVAS_HEIGHT_PX = 1000;
function getXhrDatasetConfig(jsonConfigPath) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', jsonConfigPath);
        xhr.onload = function () {
            resolve(JSON.parse(xhr.responseText));
        };
        xhr.onerror = function (error) {
            reject(error);
        };
        xhr.send();
    });
}
exports.getXhrDatasetConfig = getXhrDatasetConfig;
var XhrDataset = (function (_super) {
    __extends(XhrDataset, _super);
    function XhrDataset(xhrDatasetConfig) {
        var _this = _super.call(this, xhrDatasetConfig.data.map(function (x) { return x.shape; })) || this;
        _this.xhrDatasetConfig = xhrDatasetConfig;
        return _this;
    }
    XhrDataset.prototype.getNDArray = function (info) {
        var dataPromise = info.dataType === 'png' ?
            parseTypedArrayFromPng(info, info.shape) :
            parseTypedArrayFromBinary(info);
        return dataPromise.then(function (data) {
            var inputSize = util.sizeFromShape(info.shape);
            var ndarrays = [];
            for (var i = 0; i < data.length / inputSize; i++) {
                var values = data.subarray(i * inputSize, (i + 1) * inputSize);
                var ndarray = ndarray_1.NDArray.make(info.shape, { values: new Float32Array(values) });
                ndarrays.push(ndarray);
            }
            return ndarrays;
        });
    };
    XhrDataset.prototype.fetchData = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var promises = _this.xhrDatasetConfig.data.map(function (x) { return _this.getNDArray(x); });
            Promise.all(promises).then(function (data) {
                _this.dataset = data;
                resolve();
            });
        });
    };
    return XhrDataset;
}(dataset_1.InMemoryDataset));
exports.XhrDataset = XhrDataset;
function parseTypedArrayFromBinary(info) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', info.path);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function (event) {
            var data = (info.dataType === 'float32') ?
                new Float32Array(xhr.response) :
                new Uint8Array(xhr.response);
            resolve(data);
        };
        xhr.onerror = function (err) { return reject(err); };
        xhr.send();
    });
}
function parseGrayscaleImageData(data, result, resultOffset) {
    var idx = resultOffset;
    for (var i = 0; i < data.length; i += 4) {
        result[idx++] = data[i];
    }
}
function parseRGBImageData(data, result, resultOffset) {
    var idx = resultOffset;
    for (var i = 0; i < data.length; i += 4) {
        result[idx] = data[i];
        result[idx + 1] = data[i + 1];
        result[idx + 2] = data[i + 2];
        idx += 3;
    }
}
function parseImage(img, shape) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var N = img.height;
    var inputSize = util.sizeFromShape(shape);
    var result = new Uint8Array(N * inputSize);
    if (img.width !== shape[0] * shape[1]) {
        throw new Error("Image width (" + img.width + ") must be multiple of " +
            ("rows*columns (" + shape[0] + "*" + shape[1] + ") of the ndarray"));
    }
    canvas.width = img.width;
    canvas.height = PARSING_IMAGE_CANVAS_HEIGHT_PX;
    var sx = 0;
    var sWidth = canvas.width;
    var sHeight = canvas.height;
    var dx = 0;
    var dy = 0;
    var dWidth = sWidth;
    var dHeight = sHeight;
    var depth = shape[2];
    var offset = 0;
    var numPasses = Math.ceil(N / canvas.height);
    for (var pass = 0; pass < numPasses; ++pass) {
        var sy = pass * canvas.height;
        if ((pass === numPasses - 1) && (N % canvas.height > 0)) {
            canvas.height = N % canvas.height;
            sHeight = canvas.height;
            dHeight = sHeight;
        }
        ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        (depth === 1) ? parseGrayscaleImageData(data, result, offset) :
            parseRGBImageData(data, result, offset);
        offset += canvas.height * inputSize;
    }
    return result;
}
function parseTypedArrayFromPng(info, shape) {
    return new Promise(function (resolve, reject) {
        var img = new Image();
        img.setAttribute('crossOrigin', '');
        img.onload = function () {
            var result = parseImage(img, shape);
            img.src = '';
            img = null;
            resolve(result);
        };
        img.src = info.path;
    });
}
//# sourceMappingURL=xhr-dataset.js.map

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_array_map_1 = __webpack_require__(35);
var optimizer_1 = __webpack_require__(50);
var SGDOptimizer = (function (_super) {
    __extends(SGDOptimizer, _super);
    function SGDOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        return _this;
    }
    SGDOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var variable = math.scaledArrayAdd(_this.c, gradient, _this.one, oldVariable);
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    SGDOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    SGDOptimizer.prototype.setLearningRate = function (learningRate) {
        this.learningRate = learningRate;
    };
    return SGDOptimizer;
}(optimizer_1.Optimizer));
exports.SGDOptimizer = SGDOptimizer;
//# sourceMappingURL=sgd_optimizer.js.map

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function defaultCompare(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
var PriorityQueue = (function () {
    function PriorityQueue(comparator, indexObserver) {
        this.comparator = comparator;
        this.indexObserver = indexObserver;
        this.heap = [];
    }
    PriorityQueue.prototype.enqueue = function (t) {
        this.heap.push(t);
        this.onIndexChanged(t, this.heap.length - 1);
        this.siftUp(this.heap.length - 1);
    };
    PriorityQueue.prototype.dequeue = function () {
        if (this.empty()) {
            throw new Error('dequeue called on empty priority queue.');
        }
        var t = this.heap[0];
        this.swap(0, this.heap.length - 1);
        this.heap.pop();
        this.siftDown(0);
        return t;
    };
    PriorityQueue.prototype.update = function (newT, index) {
        var last = (index === this.heap.length - 1);
        if (!last) {
            this.swap(index, this.heap.length - 1);
        }
        this.heap.pop();
        if (!last) {
            if (this.siftUpIndex(index) !== -1) {
                this.siftUp(index);
            }
            else if (this.siftDownIndex(index) !== -1) {
                this.siftDown(index);
            }
        }
        this.enqueue(newT);
    };
    PriorityQueue.prototype.empty = function () {
        return this.heap.length === 0;
    };
    PriorityQueue.prototype.onIndexChanged = function (t, newIndex) {
        if (this.indexObserver) {
            this.indexObserver(t, newIndex);
        }
    };
    PriorityQueue.prototype.getParentIndex = function (index) {
        if (index === 0) {
            return -1;
        }
        return Math.floor((index - 1) / 2);
    };
    PriorityQueue.prototype.getLeftChildIndex = function (index) {
        var candidate = index * 2 + 1;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.getRightChildIndex = function (index) {
        var candidate = index * 2 + 2;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.siftUpIndex = function (index) {
        var parentIndex = this.getParentIndex(index);
        if (parentIndex === -1) {
            return -1;
        }
        if (this.compare(parentIndex, index) > 0) {
            return parentIndex;
        }
        return -1;
    };
    PriorityQueue.prototype.siftUp = function (index) {
        var siftIndex = this.siftUpIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftUpIndex(index);
        }
    };
    PriorityQueue.prototype.siftDownIndex = function (index) {
        if (index >= this.heap.length) {
            return -1;
        }
        var largestChildIndex = index;
        var leftChildIndex = this.getLeftChildIndex(index);
        if ((leftChildIndex !== -1) &&
            (this.compare(leftChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = leftChildIndex;
        }
        var rightChildIndex = this.getRightChildIndex(index);
        if ((rightChildIndex !== -1) &&
            (this.compare(rightChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = rightChildIndex;
        }
        return (largestChildIndex === index) ? -1 : largestChildIndex;
    };
    PriorityQueue.prototype.siftDown = function (index) {
        var siftIndex = this.siftDownIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftDownIndex(index);
        }
    };
    PriorityQueue.prototype.compare = function (aIndex, bIndex) {
        return this.comparator(this.heap[aIndex], this.heap[bIndex]);
    };
    PriorityQueue.prototype.swap = function (a, b) {
        var temp = this.heap[a];
        this.heap[a] = this.heap[b];
        this.heap[b] = temp;
        this.onIndexChanged(this.heap[a], a);
        this.onIndexChanged(this.heap[b], b);
    };
    return PriorityQueue;
}());
exports.PriorityQueue = PriorityQueue;
//# sourceMappingURL=priority_queue.js.map

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var operation_emitter = __webpack_require__(378);
var session_util = __webpack_require__(151);
var tensor_array_map_1 = __webpack_require__(35);
var FeedDictionary = (function () {
    function FeedDictionary(feedEntries) {
        var _this = this;
        this.dict = {};
        if (feedEntries) {
            feedEntries.forEach(function (entry) { return _this.dict[entry.tensor.id] = entry; });
        }
    }
    return FeedDictionary;
}());
exports.FeedDictionary = FeedDictionary;
var CostReduction;
(function (CostReduction) {
    CostReduction[CostReduction["NONE"] = 0] = "NONE";
    CostReduction[CostReduction["SUM"] = 1] = "SUM";
    CostReduction[CostReduction["MEAN"] = 2] = "MEAN";
})(CostReduction = exports.CostReduction || (exports.CostReduction = {}));
var Session = (function () {
    function Session(graph, math) {
        this.math = math;
        this.activationArrayMap = new tensor_array_map_1.TensorArrayMap();
        this.runtimeCache = {};
        this.oneScalar = ndarray_1.Scalar.new(1);
        this.gradientArrayMap = new tensor_array_map_1.SummedTensorArrayMap(this.math);
    }
    Session.prototype.dispose = function () {
        var _this = this;
        this.activationArrayMap.dispose();
        Object.keys(this.runtimeCache).forEach(function (key) {
            var runtime = _this.runtimeCache[key];
            if (runtime.operations) {
                runtime.operations.forEach(function (op) { return op.dispose(); });
            }
        });
        this.runtimeCache = {};
        if (this.batchSizeScalar != null) {
            this.batchSizeScalar.dispose();
        }
        this.oneScalar.dispose();
    };
    Session.prototype.evalAll = function (tensors, feedEntries) {
        var _this = this;
        return this.math.scope(function () {
            var feed = new FeedDictionary(feedEntries);
            var runtime = _this.getOrCreateRuntime(tensors, feed);
            var activations = _this.activationArrayMap;
            session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
            session_util.disposeTransientOperationArrays(runtime.operations, _this.activationArrayMap, _this.gradientArrayMap);
            session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
            session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
            runtime.operations.forEach(function (op) { return op.feedForward(_this.math, activations); });
            var results = tensors.map(function (x) { return activations.get(x); });
            tensors.forEach(function (x) { return activations.delete(x); });
            session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
            return results;
        });
    };
    Session.prototype.eval = function (tensor, feedEntries) {
        return this.evalAll([tensor], feedEntries)[0];
    };
    Session.prototype.train = function (costTensor, feedEntries, batchSize, optimizer, costReduction) {
        var _this = this;
        if (costReduction === void 0) { costReduction = CostReduction.NONE; }
        util.assert(util.isScalarShape(costTensor.shape), 'Cost tensor for training must be a scalar value.');
        if (this.prevBatchSize !== batchSize) {
            this.prevBatchSize = batchSize;
            this.batchSizeScalar = ndarray_1.Scalar.new(batchSize);
        }
        var feed = new FeedDictionary(feedEntries);
        session_util.throwIfFeedDictionaryContainsNDArrays(feed);
        var runtime = this.getOrCreateRuntime([costTensor], feed);
        var inferenceOperations = runtime.operations;
        var backPropOperations = runtime.operations.slice().reverse();
        var activations = this.activationArrayMap;
        var gradients = this.gradientArrayMap;
        gradients.nullify(costTensor);
        gradients.add(costTensor, this.oneScalar);
        session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
        optimizer.beforeBatch(this.math, batchSize, runtime, activations, gradients);
        return this.math.scope(function (keep, track) {
            var cost = track(ndarray_1.Scalar.new(0));
            for (var i = 0; i < batchSize; ++i) {
                session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
                session_util.disposeAndInitializeOperationInputGradients(runtime.nodes, gradients);
                session_util.disposeTransientOperationArrays(runtime.operations, activations, gradients);
                session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
                inferenceOperations.forEach(function (op) { return op.feedForward(_this.math, activations); });
                backPropOperations.forEach(function (op) { return op.backProp(_this.math, activations, gradients); });
                optimizer.afterExample(_this.math, runtime, activations, gradients);
                session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
                cost = _this.updateCostForExample(cost, activations.get(costTensor), costReduction);
            }
            optimizer.afterBatch(_this.math, batchSize, runtime, activations, gradients);
            return _this.updateCostForBatch(cost, costReduction);
        });
    };
    Session.prototype.updateCostForExample = function (totalCost, currCost, costReduction) {
        if (costReduction === CostReduction.MEAN ||
            costReduction === CostReduction.SUM) {
            return this.math.add(totalCost, currCost);
        }
        return totalCost;
    };
    Session.prototype.updateCostForBatch = function (totalCost, costReduction) {
        if (costReduction === CostReduction.MEAN) {
            return this.math.divide(totalCost, this.batchSizeScalar);
        }
        return totalCost;
    };
    Session.prototype.getOrCreateRuntime = function (tensors, feed) {
        var key = this.makeRuntimeCacheKey(tensors, feed);
        var runtime = this.runtimeCache[key];
        if (runtime === undefined) {
            var nodes = session_util.getOrderedEvaluationSetFromEvalTensor(tensors, feed);
            session_util.removeFeedDictionaryNodesFromEvaluationSet(feed, nodes);
            session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);
            var operations = operation_emitter.emitFromGraphNodes(nodes);
            runtime = { nodes: nodes, operations: operations };
            this.runtimeCache[key] = runtime;
        }
        return runtime;
    };
    Session.prototype.makeRuntimeCacheKey = function (tensors, feed) {
        return tensors.map(function (x) { return x.id; }).sort().join('_') + '__' +
            Object.keys(feed.dict).sort().join('_');
    };
    return Session;
}());
exports.Session = Session;
//# sourceMappingURL=session.js.map

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var graph_1 = __webpack_require__(64);
var graph_util = __webpack_require__(21);
function getTerminatingNodesFromFeedDictionary(feedDictionary) {
    return Object.keys(feedDictionary.dict)
        .map(function (tensorID) { return feedDictionary.dict[+tensorID].tensor.node; });
}
exports.getTerminatingNodesFromFeedDictionary = getTerminatingNodesFromFeedDictionary;
function getOrderedEvaluationSetFromEvalTensor(evalTensors, feedDictionary) {
    var terminatingNodes = getTerminatingNodesFromFeedDictionary(feedDictionary);
    var evalNodes = evalTensors.map(function (x) { return x.node; });
    var unorderedEvaluationSet = graph_util.getUnorderedEvaluationSet(evalNodes, terminatingNodes);
    var orderedEvaluationSet = graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);
    return orderedEvaluationSet;
}
exports.getOrderedEvaluationSetFromEvalTensor = getOrderedEvaluationSetFromEvalTensor;
function addPersistentArraysToTensorArrayMap(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode || node instanceof graph_1.ConstantNode) {
            tensorArrayMap.set(node.output, node.data);
        }
    });
}
exports.addPersistentArraysToTensorArrayMap = addPersistentArraysToTensorArrayMap;
function getVariableNodesFromEvaluationSet(evaluationSet) {
    var nodes = [];
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode) {
            nodes.push(node);
        }
    });
    return nodes;
}
exports.getVariableNodesFromEvaluationSet = getVariableNodesFromEvaluationSet;
function throwIfFeedDictionaryContainsNDArrays(feedDictionary) {
    Object.keys(feedDictionary.dict).forEach(function (tensorID) {
        if (feedDictionary.dict[+tensorID].data instanceof ndarray_1.NDArray) {
            throw new Error('training requires FeedDictionary entries to be InputProviders' +
                'and not NDArrays.');
        }
    });
}
exports.throwIfFeedDictionaryContainsNDArrays = throwIfFeedDictionaryContainsNDArrays;
function loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        var data;
        if (feedEntry.data instanceof ndarray_1.NDArray) {
            data = feedEntry.data;
        }
        else {
            var provider = feedEntry.data;
            data = provider.getNextCopy(math);
        }
        util.assert(util.arraysEqual(feedEntry.tensor.shape, data.shape), "Error loading FeedEntry: feeding NDArray of shape " + data.shape + " " +
            ("does not match Tensor (id: " + feedEntry.tensor.id + ") shape: ") +
            (feedEntry.tensor.shape + "."));
        activations.set(feedEntry.tensor, data);
    });
}
exports.loadInputsFromFeedDictionaryToTensorArrayMap = loadInputsFromFeedDictionaryToTensorArrayMap;
function releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        if (!(feedEntry.data instanceof ndarray_1.NDArray)) {
            var provider = feedEntry.data;
            var feedEntryArray = activations.get(feedEntry.tensor);
            provider.disposeCopy(math, feedEntryArray);
        }
        activations.delete(feedEntry.tensor);
    });
}
exports.releaseFeedDictionaryInputsFromTensorArrayMap = releaseFeedDictionaryInputsFromTensorArrayMap;
function removeFeedDictionaryNodesFromEvaluationSet(feedDictionary, evaluationSet) {
    var i = 0;
    while (i < evaluationSet.length) {
        var node = evaluationSet[i];
        if (feedDictionary.dict[node.output.id] != null) {
            evaluationSet.splice(i, 1);
        }
        else {
            ++i;
        }
    }
}
exports.removeFeedDictionaryNodesFromEvaluationSet = removeFeedDictionaryNodesFromEvaluationSet;
function disposeAndInitializeOperationOutputs(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (!graph_util.isInputNode(node)) {
            if (!graph_util.isPassthroughNode(node, tensorArrayMap)) {
                tensorArrayMap.disposeArray(node.output);
            }
            tensorArrayMap.set(node.output, null);
        }
    });
}
exports.disposeAndInitializeOperationOutputs = disposeAndInitializeOperationOutputs;
function disposeAndInitializeOperationInputGradients(evaluationSet, gradients) {
    evaluationSet.forEach(function (node) {
        Object.keys(node.inputs).forEach(function (inputName) {
            var input = node.inputs[inputName];
            if (gradients.get(input, true) !== gradients.get(node.output, true)) {
                gradients.disposeArray(input);
            }
            gradients.nullify(input);
        });
    });
}
exports.disposeAndInitializeOperationInputGradients = disposeAndInitializeOperationInputGradients;
function disposeTransientOperationArrays(operations, activations, gradients) {
    operations.forEach(function (op) { return op.disposeTransientArrays(activations, gradients); });
}
exports.disposeTransientOperationArrays = disposeTransientOperationArrays;
function throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.PlaceholderNode) {
            var shape = '[' + node.output.shape.join(', ') + ']';
            throw new Error('Placeholder node "' + node.name + '" ' + shape +
                ' not present in feed dictionary.');
        }
    });
}
exports.throwErrorIfEvaluationSetContainsPlaceholderNodes = throwErrorIfEvaluationSetContainsPlaceholderNodes;
//# sourceMappingURL=session_util.js.map

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var VarianceScalingInitializer = (function () {
    function VarianceScalingInitializer(scale, mode, distribution) {
        if (scale === void 0) { scale = 1.0; }
        if (mode === void 0) { mode = 'fan_in'; }
        if (distribution === void 0) { distribution = 'normal'; }
        this.scale = scale;
        this.mode = mode;
        this.distribution = distribution;
    }
    VarianceScalingInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var n = 0;
        if (this.mode === 'fan_in') {
            n = inputUnits;
        }
        else if (this.mode === 'fan_out') {
            n = outputUnits;
        }
        else if (this.mode === 'fan_avg') {
            n = (inputUnits + outputUnits) / 2;
        }
        else {
            throw new Error("Unexpected mode for variance scaling initializer: " + this.mode);
        }
        if (this.distribution === 'normal') {
            return ndarray_1.NDArray.randTruncatedNormal(weightsShape, 0.0, Math.sqrt(this.scale / n));
        }
        else if (this.distribution === 'uniform') {
            return ndarray_1.NDArray.randUniform(weightsShape, 0.0, Math.sqrt(3 * this.scale / n));
        }
        else {
            throw new Error("Unexpected distribution for variance scaling initializer: " +
                ("" + this.distribution));
        }
    };
    return VarianceScalingInitializer;
}());
exports.VarianceScalingInitializer = VarianceScalingInitializer;
var ZerosInitializer = (function () {
    function ZerosInitializer() {
    }
    ZerosInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.zeros(weightsShape);
    };
    return ZerosInitializer;
}());
exports.ZerosInitializer = ZerosInitializer;
var OnesInitializer = (function () {
    function OnesInitializer() {
    }
    OnesInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(1);
        return values;
    };
    return OnesInitializer;
}());
exports.OnesInitializer = OnesInitializer;
var ConstantInitializer = (function () {
    function ConstantInitializer(value) {
        if (value === void 0) { value = 0; }
        this.value = value;
    }
    ConstantInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(this.value);
        return values;
    };
    return ConstantInitializer;
}());
exports.ConstantInitializer = ConstantInitializer;
var NDArrayInitializer = (function () {
    function NDArrayInitializer(ndarray) {
        this.ndarray = ndarray;
    }
    NDArrayInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return this.ndarray;
    };
    return NDArrayInitializer;
}());
exports.NDArrayInitializer = NDArrayInitializer;
var RandomNormalInitializer = (function () {
    function RandomNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomNormalInitializer;
}());
exports.RandomNormalInitializer = RandomNormalInitializer;
var RandomTruncatedNormalInitializer = (function () {
    function RandomTruncatedNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomTruncatedNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randTruncatedNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomTruncatedNormalInitializer;
}());
exports.RandomTruncatedNormalInitializer = RandomTruncatedNormalInitializer;
var RandomUniformInitializer = (function () {
    function RandomUniformInitializer(minval, maxval) {
        if (minval === void 0) { minval = -.05; }
        if (maxval === void 0) { maxval = .05; }
        this.minval = minval;
        this.maxval = maxval;
    }
    RandomUniformInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randUniform(weightsShape, this.minval, this.maxval);
    };
    return RandomUniformInitializer;
}());
exports.RandomUniformInitializer = RandomUniformInitializer;
//# sourceMappingURL=initializers.js.map

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function validateShapes(sourceSize, destSize) {
    var srcArea = sourceSize[0] * sourceSize[1];
    var dstArea = destSize[0] * destSize[1];
    if (srcArea !== dstArea) {
        var srcStr = "[" + sourceSize[0] + ", " + sourceSize[1] + "]";
        var dstStr = "[" + destSize[0] + ", " + destSize[1] + "]";
        throw new Error("copy2D shapes have different areas:\n  sourceSize " + srcStr +
            (", area " + srcArea + "\n  destSize " + dstStr + ", area " + dstArea));
    }
}
exports.validateShapes = validateShapes;
//# sourceMappingURL=copy2d_util.js.map

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = __webpack_require__(432);
var util = __webpack_require__(4);
var axis_util = __webpack_require__(109);
var broadcast_util = __webpack_require__(56);
var concat_util = __webpack_require__(65);
var conv_util = __webpack_require__(51);
var copy2D_util = __webpack_require__(153);
var math_1 = __webpack_require__(57);
var ndarray_1 = __webpack_require__(6);
var NDArrayMathCPU = (function (_super) {
    __extends(NDArrayMathCPU, _super);
    function NDArrayMathCPU(safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        return _super.call(this, safeMode) || this;
    }
    NDArrayMathCPU.prototype.cloneInternal = function (ndarray) {
        return ndarray_1.NDArray.make(ndarray.shape, { values: new Float32Array(ndarray.getValues()) });
    };
    NDArrayMathCPU.prototype.slice1DInternal = function (input, begin, size) {
        var newVals = input.getValues().slice(begin, begin + size);
        return ndarray_1.Array1D.new(newVals);
    };
    NDArrayMathCPU.prototype.slice2DInternal = function (input, begin, size) {
        var result = ndarray_1.Array2D.zeros(size);
        var startI = begin[0], startJ = begin[1];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                var val = input.get(i + startI, j + startJ);
                result.set(val, i, j);
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.slice3DInternal = function (input, begin, size) {
        var result = ndarray_1.Array3D.zeros(size);
        var startI = begin[0], startJ = begin[1], startK = begin[2];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                for (var k = 0; k < size[2]; ++k) {
                    var val = input.get(i + startI, j + startJ, k + startK);
                    result.set(val, i, j, k);
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.slice4DInternal = function (input, begin, size) {
        var result = ndarray_1.Array4D.zeros(size);
        var startI = begin[0], startJ = begin[1], startK = begin[2], startL = begin[3];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                for (var k = 0; k < size[2]; ++k) {
                    for (var l = 0; l < size[3]; ++l) {
                        var val = input.get(i + startI, j + startJ, k + startK, l + startL);
                        result.set(val, i, j, k, l);
                    }
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        copy2D_util.validateShapes(sourceSizeRowCol, destSizeRowCol);
        var srcValues = source.getValues();
        var dstValues = dest.getValues();
        var n = sourceSizeRowCol[0] * sourceSizeRowCol[1];
        for (var i = 0; i < n; ++i) {
            var srcRow = sourceBeginRowCol[0] + Math.floor(i / sourceSizeRowCol[1]);
            var srcCol = sourceBeginRowCol[1] + (i % sourceSizeRowCol[1]);
            var srcOff = srcRow * source.shape[1] + srcCol;
            var dstRow = destBeginRowCol[0] + Math.floor(i / destSizeRowCol[1]);
            var dstCol = destBeginRowCol[1] + (i % destSizeRowCol[1]);
            var dstOff = dstRow * dest.shape[1] + dstCol;
            dstValues[dstOff] = srcValues[srcOff];
        }
    };
    NDArrayMathCPU.prototype.concat1DInternal = function (a, b) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, 0);
        var result = ndarray_1.Array1D.zeros(outShape);
        var aVals = a.getValues();
        var bVals = b.getValues();
        var vals = result.getValues();
        vals.set(aVals, 0);
        vals.set(bVals, a.size);
        return result;
    };
    NDArrayMathCPU.prototype.concat2DInternal = function (a, b, axis) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
        var result = ndarray_1.Array2D.zeros(outShape);
        if (axis === 0) {
            var aVals = a.getValues();
            var bVals = b.getValues();
            var vals = result.getValues();
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return result;
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < outShape[1]; ++j) {
                var index = [i, j];
                var value = void 0;
                if (index[axis] < a.shape[axis]) {
                    value = a.get(i, j);
                }
                else {
                    index[axis] -= a.shape[axis];
                    var i2 = index[0], j2 = index[1];
                    value = b.get(i2, j2);
                }
                result.set(value, i, j);
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.concat3DInternal = function (a, b, axis) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
        var result = ndarray_1.Array3D.zeros(outShape);
        if (axis === 0) {
            var aVals = a.getValues();
            var bVals = b.getValues();
            var vals = result.getValues();
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return result;
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < outShape[1]; ++j) {
                for (var k = 0; k < outShape[2]; ++k) {
                    var index = [i, j, k];
                    var value = void 0;
                    if (index[axis] < a.shape[axis]) {
                        value = a.get(i, j, k);
                    }
                    else {
                        index[axis] -= a.shape[axis];
                        var i2 = index[0], j2 = index[1], k2 = index[2];
                        value = b.get(i2, j2, k2);
                    }
                    result.set(value, i, j, k);
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.concat4DInternal = function (a, b, axis) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
        var result = ndarray_1.Array4D.zeros(outShape);
        if (axis === 0) {
            var aVals = a.getValues();
            var bVals = b.getValues();
            var vals = result.getValues();
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return result;
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < outShape[1]; ++j) {
                for (var k = 0; k < outShape[2]; ++k) {
                    for (var l = 0; l < outShape[3]; ++l) {
                        var index = [i, j, k, l];
                        var value = void 0;
                        if (index[axis] < a.shape[axis]) {
                            value = a.get(i, j, k, l);
                        }
                        else {
                            index[axis] -= a.shape[axis];
                            var i2 = index[0], j2 = index[1], k2 = index[2], l2 = index[3];
                            value = b.get(i2, j2, k2, l2);
                        }
                        result.set(value, i, j, k, l);
                    }
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
        var c1Val = c1.get();
        var c2Val = c2.get();
        return this.broadcastedBinaryOp(a, b, 'float32', function (aVal, bVal) {
            return c1Val * aVal + c2Val * bVal;
        });
    };
    NDArrayMathCPU.prototype.negInternal = function (a) {
        return this.scalarTimesArray(ndarray_1.Scalar.NEG_ONE, a);
    };
    NDArrayMathCPU.prototype.addInternal = function (a, b) {
        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.ONE, b);
    };
    NDArrayMathCPU.prototype.subtractInternal = function (a, b) {
        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.NEG_ONE, b);
    };
    NDArrayMathCPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
        if (aOrientation === void 0) { aOrientation = math_1.MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = math_1.MatrixOrientation.REGULAR; }
        var sharedDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var leftDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[0] : a.shape[1];
        var rightDim = (bOrientation === math_1.MatrixOrientation.REGULAR) ? b.shape[1] : b.shape[0];
        var normalGetter = function (matrix, i, j) {
            return matrix.get(i, j);
        };
        var transposedGetter = function (matrix, i, j) {
            return matrix.get(j, i);
        };
        var aGetter = (aOrientation === math_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var bGetter = (bOrientation === math_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var values = new Float32Array(leftDim * rightDim);
        var index = 0;
        for (var i = 0; i < leftDim; ++i) {
            for (var j = 0; j < rightDim; ++j) {
                var sum = 0;
                for (var k = 0; k < sharedDim; ++k) {
                    sum += aGetter(a, i, k) * bGetter(b, k, j);
                }
                values[index++] = sum;
            }
        }
        return ndarray_1.Array2D.new([leftDim, rightDim], values);
    };
    NDArrayMathCPU.prototype.multiplyInternal = function (a, b) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = aValues[i % a.size] * bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues });
    };
    NDArrayMathCPU.prototype.divideInternal = function (a, b) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = aValues[i % a.size] / bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues }, 'float32');
    };
    NDArrayMathCPU.prototype.sumInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var resultDtype = math_1.SumTypesMap[input.dtype];
        var result = ndarray_1.NDArray.zeros(outShape, resultDtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var sum = 0;
            for (var j = 0; j < reduceSize; ++j) {
                sum += aVals[offset + j];
            }
            vals[i] = sum;
        }
        return result;
    };
    NDArrayMathCPU.prototype.argMinInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[offset];
            var minIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    minIndex = util.NAN_INT32;
                    break;
                }
                if (value < min) {
                    min = value;
                    minIndex = j;
                }
            }
            vals[i] = minIndex;
        }
        return result;
    };
    NDArrayMathCPU.prototype.argMaxInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            var maxIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    maxIndex = util.NAN_INT32;
                    break;
                }
                if (value > max) {
                    max = value;
                    maxIndex = j;
                }
            }
            vals[i] = maxIndex;
        }
        return result;
    };
    NDArrayMathCPU.prototype.equalInternal = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal === bVal) ? 1 : 0;
            }
        });
    };
    NDArrayMathCPU.prototype.topKInternal = function (ndarray, k) {
        var values = ndarray.getValues();
        var valuesAndIndices = [];
        for (var i = 0; i < values.length; i++) {
            valuesAndIndices.push({ value: values[i], index: i });
        }
        valuesAndIndices.sort(function (a, b) {
            return b.value - a.value;
        });
        var topkValues = new Float32Array(k);
        var topkIndices = new Float32Array(k);
        for (var i = 0; i < k; i++) {
            topkValues[i] = valuesAndIndices[i].value;
            topkIndices[i] = valuesAndIndices[i].index;
        }
        return { values: ndarray_1.Array1D.new(topkValues), indices: ndarray_1.Array1D.new(topkIndices) };
    };
    NDArrayMathCPU.prototype.minInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, input.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[0];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    min = Number.NaN;
                    break;
                }
                if (value < min) {
                    min = value;
                }
            }
            vals[i] = min;
        }
        return result;
    };
    NDArrayMathCPU.prototype.maxInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, input.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    max = Number.NaN;
                    break;
                }
                if (value > max) {
                    max = value;
                }
            }
            vals[i] = max;
        }
        return result;
    };
    NDArrayMathCPU.prototype.ceilInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.ceil(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.floorInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.floor(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.expInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.exp(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.logInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log(value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.sqrtInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.sqrt(value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.squareInternal = function (x) {
        var values = x.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = value * value;
        }
        return ndarray_1.NDArray.make(x.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.reluInternal = function (input) {
        var res = ndarray_1.NDArray.zeros(input.shape, input.dtype);
        var resVals = res.getValues();
        var inVals = input.getValues();
        for (var i = 0; i < inVals.length; ++i) {
            var val = inVals[i];
            if (util.isValNaN(val, input.dtype)) {
                resVals[i] = util.getNaN(res.dtype);
            }
            else {
                resVals[i] = Math.max(0, inVals[i]);
            }
        }
        return res;
    };
    NDArrayMathCPU.prototype.eluInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = (Math.exp(v) - 1);
            }
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.leakyReluInternal = function (ndarray, alpha) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.dataSync();
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = alpha * v;
            }
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.clipInternal = function (ndarray, min, max) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.min(max, Math.max(min, values[i]));
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.absInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.abs(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sigmoidInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = 1 / (1 + Math.exp(-values[i]));
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sinInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sin(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.cosInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cos(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.tanInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.tan(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.asinInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asin(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.acosInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acos(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.atanInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atan(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sinhInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sinh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.coshInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cosh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.tanhInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = util.tanh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.stepInternal = function (ndarray, alpha) {
        if (alpha === void 0) { alpha = 0; }
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            resultValues[i] = value > 0 ? 1 : (value < 0 ? alpha : value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.conv2dInternal = function (x, filter, bias, convInfo) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], inputDepth = _a[2];
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var outDepth = filter.shape[3];
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var y = ndarray_1.Array3D.zeros(convInfo.outShape);
        for (var d2 = 0; d2 < outDepth; ++d2) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR * convInfo.strideHeight - padLeft;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, filterHeight + xRCorner);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC * convInfo.strideWidth - padTop;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, filterWidth + xCCorner);
                    var dotProd = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC - xCCorner;
                            for (var d1 = 0; d1 < inputDepth; ++d1) {
                                var pixel = x.get(xR, xC, d1);
                                var weight = filter.get(wR, wC, d1, d2);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    var biasVal = (bias != null) ? bias.get(d2) : 0;
                    y.set(dotProd + biasVal, yR, yC, d2);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.conv2dDerInputInternal = function (dy, filter, convInfo) {
        var inDepth = filter.shape[2];
        var outDepth = filter.shape[3];
        var yRows = dy.shape[0];
        var yCols = dy.shape[1];
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dx = ndarray_1.Array3D.zeros(convInfo.inShape);
        for (var d1 = 0; d1 < inDepth; ++d1) {
            for (var xR = 0; xR < dx.shape[0]; ++xR) {
                var xRCorner = xR - leftPad;
                var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                var yRMax = Math.min(yRows, (filterHeight + xRCorner) / strideHeight);
                for (var xC = 0; xC < dx.shape[1]; ++xC) {
                    var xCCorner = xC - topPad;
                    var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                    var yCMax = Math.min(yCols, (filterWidth + xCCorner) / strideWidth);
                    var dotProd = 0;
                    for (var yR = xRMin; yR < yRMax; ++yR) {
                        var wR = yR * strideHeight - xRCorner;
                        for (var yC = xCMin; yC < yCMax; ++yC) {
                            var wC = yC * strideWidth - xCCorner;
                            for (var d2 = 0; d2 < outDepth; ++d2) {
                                var pixel = dy.get(yR, yC, d2);
                                var weight = filter.get(filterHeight - 1 - wR, filterWidth - 1 - wC, d1, d2);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    dx.set(dotProd, xR, xC, d1);
                }
            }
        }
        return dx;
    };
    NDArrayMathCPU.prototype.conv2dDerFilterInternal = function (x, dY, convInfo) {
        var inputDepth = x.shape[2];
        var outputDepth = dY.shape[2];
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var weightsShape = conv_util.computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth);
        var dW = ndarray_1.Array4D.zeros(weightsShape);
        var yNumRows = dY.shape[0];
        var yNumCols = dY.shape[1];
        var xNumRows = x.shape[0];
        var xNumCols = x.shape[1];
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(yNumRows, (xNumRows + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(yNumCols, (xNumCols + leftPad - wC) / strideWidth);
                for (var d1 = 0; d1 < inputDepth; ++d1) {
                    for (var d2 = 0; d2 < outputDepth; ++d2) {
                        var dotProd = 0;
                        for (var yR = yRMin; yR < yRMax; ++yR) {
                            var xR = wR + yR * strideHeight - topPad;
                            for (var yC = yCMin; yC < yCMax; ++yC) {
                                var xC = wC + yC * strideWidth - leftPad;
                                dotProd += x.get(xR, xC, d1) * dY.get(yR, yC, d2);
                            }
                        }
                        dW.set(dotProd, wR, wC, d1, d2);
                    }
                }
            }
        }
        return dW;
    };
    NDArrayMathCPU.prototype.conv2dDerBiasInternal = function (dY) {
        var outputDepth = dY.shape[2];
        var numRows = dY.shape[0];
        var numCols = dY.shape[1];
        var values = new Float32Array(outputDepth);
        for (var d2 = 0; d2 < outputDepth; ++d2) {
            var sum = 0;
            for (var r = 0; r < numRows; ++r) {
                for (var c = 0; c < numCols; ++c) {
                    sum += dY.get(r, c, d2);
                }
            }
            values[d2] = sum;
        }
        return ndarray_1.Array1D.new(values);
    };
    NDArrayMathCPU.prototype.depthwiseConv2DInternal = function (input, filter, convInfo) {
        var _a = convInfo.inShape, numBatches = _a[0], xRows = _a[1], xCols = _a[2], inChannels = _a[3];
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var yRows = convInfo.outShape[1];
        var yCols = convInfo.outShape[2];
        var chMul = convInfo.channelMul;
        var y = ndarray_1.Array4D.zeros(convInfo.outShape);
        for (var b = 0; b < numBatches; ++b) {
            for (var d1 = 0; d1 < inChannels; ++d1) {
                for (var yR = 0; yR < yRows; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(xRows, filterHeight + xRCorner);
                    for (var yC = 0; yC < yCols; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(xCols, filterWidth + xCCorner);
                        for (var q = 0; q < chMul; ++q) {
                            var dotProd = 0;
                            for (var xR = xRMin; xR < xRMax; ++xR) {
                                var wR = xR - xRCorner;
                                for (var xC = xCMin; xC < xCMax; ++xC) {
                                    var wC = xC - xCCorner;
                                    var pixel = input.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, q);
                                    dotProd += pixel * weight;
                                }
                            }
                            y.set(dotProd, b, yR, yC, d1 * chMul + q);
                        }
                    }
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.tileInternal = function (a, reps) {
        var newShape = new Array(a.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = a.shape[i] * reps[i];
        }
        var dtype;
        if (a.dtype === 'float32') {
            dtype = Float32Array;
        }
        else if (a.dtype === 'int32') {
            dtype = Int32Array;
        }
        else if (a.dtype === 'bool') {
            dtype = Uint8Array;
        }
        else {
            throw new Error("Dtype " + a.dtype + " not supported for tile");
        }
        var resultValues = new dtype(util.sizeFromShape(newShape));
        var result = ndarray_1.NDArray.make(newShape, { values: resultValues }, a.dtype);
        var values = a.getValues();
        for (var i = 0; i < result.size; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = new Array(a.rank);
            for (var i_1 = 0; i_1 < originalLoc.length; i_1++) {
                originalLoc[i_1] = newLoc[i_1] % a.shape[i_1];
            }
            var originalIndex = a.locToIndex(originalLoc);
            resultValues[i] = values[originalIndex];
        }
        return result;
    };
    NDArrayMathCPU.prototype.transposeInternal = function (a, perm) {
        var newShape = new Array(a.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = a.shape[perm[i]];
        }
        var resultValues = new Float32Array(a.size);
        var values = a.getValues();
        var result = ndarray_1.NDArray.make(newShape, { values: resultValues });
        for (var i = 0; i < a.size; ++i) {
            var loc = a.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var i_2 = 0; i_2 < newLoc.length; i_2++) {
                newLoc[i_2] = loc[perm[i_2]];
            }
            var newIndex = result.locToIndex(newLoc);
            resultValues[newIndex] = values[i];
        }
        return result;
    };
    NDArrayMathCPU.prototype.pool = function (x, convInfo, poolType) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var y = ndarray_1.Array3D.zeros(convInfo.outShape);
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var d = 0; d < depth; ++d) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR * strideHeight - padTop;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, filterHeight + xRCorner);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC * strideWidth - padLeft;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, filterWidth + xCCorner);
                    var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
                        Number.POSITIVE_INFINITY);
                    var avgValue = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var pixel = x.get(xR, xC, d);
                            if (isNaN(pixel)) {
                                minMaxValue = NaN;
                                avgValue = NaN;
                                break;
                            }
                            if ((poolType === 'max' && pixel > minMaxValue) ||
                                (poolType === 'min' && pixel < minMaxValue)) {
                                minMaxValue = pixel;
                            }
                            else if (poolType === 'avg') {
                                avgValue += pixel / (filterHeight * filterWidth);
                            }
                        }
                        if (isNaN(minMaxValue)) {
                            break;
                        }
                    }
                    y.set(poolType === 'avg' ? avgValue : minMaxValue, yR, yC, d);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.maxPoolInternal = function (x, convInfo) {
        return this.pool(x, convInfo, 'max');
    };
    NDArrayMathCPU.prototype.maxPoolPositions = function (x, convInfo) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
        var outputShape = convInfo.outShape;
        var maxPositions = ndarray_1.Array3D.zeros(outputShape);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var d = 0; d < depth; ++d) {
            for (var yR = 0; yR < outputShape[0]; ++yR) {
                var xRCorner = yR * strideHeight - padTop;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, filterHeight + xRCorner);
                for (var yC = 0; yC < outputShape[1]; ++yC) {
                    var xCCorner = yC * strideWidth - padLeft;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, filterWidth + xCCorner);
                    var maxValue = Number.NEGATIVE_INFINITY;
                    var maxPosition = -1;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC - xCCorner;
                            var pixel = x.get(xR, xC, d);
                            if (pixel > maxValue) {
                                maxValue = pixel;
                                maxPosition = wR * filterWidth + wC;
                            }
                        }
                    }
                    maxPositions.set(maxPosition, yR, yC, d);
                }
            }
        }
        return maxPositions;
    };
    NDArrayMathCPU.prototype.maxPoolBackpropInternal = function (dy, x, convInfo) {
        var maxPositions = this.maxPoolPositions(x, convInfo);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var _a = dy.shape, dyRows = _a[0], dyCols = _a[1], depth = _a[2];
        var dx = ndarray_1.Array3D.zeros(x.shape);
        for (var d = 0; d < depth; ++d) {
            for (var dxR = 0; dxR < dx.shape[0]; ++dxR) {
                for (var dxC = 0; dxC < dx.shape[1]; ++dxC) {
                    var dyRCorner = dxR - padTop;
                    var dyCCorner = dxC - padLeft;
                    var dotProd = 0;
                    for (var wR = 0; wR < filterHeight; ++wR) {
                        var dyR = (dyRCorner + wR) / strideHeight;
                        if (dyR < 0 || dyR >= dyRows || Math.floor(dyR) !== dyR) {
                            continue;
                        }
                        for (var wC = 0; wC < filterWidth; ++wC) {
                            var dyC = (dyCCorner + wC) / strideWidth;
                            if (dyC < 0 || dyC >= dyCols || Math.floor(dyC) !== dyC) {
                                continue;
                            }
                            var maxPos = filterHeight * filterWidth - 1 -
                                maxPositions.get(dyR, dyC, d);
                            var curPos = wR * filterWidth + wC;
                            var mask = maxPos === curPos ? 1 : 0;
                            if (mask === 0) {
                                continue;
                            }
                            var pixel = dy.get(dyR, dyC, d);
                            dotProd += pixel * mask;
                        }
                    }
                    dx.set(dotProd, dxR, dxC, d);
                }
            }
        }
        return dx;
    };
    NDArrayMathCPU.prototype.minPoolInternal = function (x, convInfo) {
        return this.pool(x, convInfo, 'min');
    };
    NDArrayMathCPU.prototype.avgPoolInternal = function (x, convInfo) {
        return this.pool(x, convInfo, 'avg');
    };
    NDArrayMathCPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
        var output = ndarray_1.Array3D.zeros([newShape2D[0], newShape2D[1], x.shape[2]]);
        var effectiveInputSize = alignCorners ? [x.shape[0] - 1, x.shape[1] - 1, x.shape[2]] : x.shape;
        var effectiveOutputSize = alignCorners ?
            [output.shape[0] - 1, output.shape[1] - 1, output.shape[2]] :
            output.shape;
        for (var r = 0; r < output.shape[0]; r++) {
            for (var c = 0; c < output.shape[1]; c++) {
                for (var d = 0; d < output.shape[2]; d++) {
                    var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                    var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                    var sourceRowFloor = Math.floor(sourceFracRow);
                    var sourceRowCeil = Math.min(x.shape[0] - 1, Math.ceil(sourceFracRow));
                    var sourceColFloor = Math.floor(sourceFracCol);
                    var sourceColCeil = Math.min(x.shape[1] - 1, Math.ceil(sourceFracCol));
                    var topLeft = x.get(sourceRowFloor, sourceColFloor, d);
                    var bottomLeft = x.get(sourceRowCeil, sourceColFloor, d);
                    var topRight = x.get(sourceRowFloor, sourceColCeil, d);
                    var bottomRight = x.get(sourceRowCeil, sourceColCeil, d);
                    var rowFrac = sourceFracRow - sourceRowFloor;
                    var colFrac = sourceFracCol - sourceColFloor;
                    var top_1 = topLeft + (topRight - topLeft) * colFrac;
                    var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                    var newValue = top_1 + (bottom - top_1) * rowFrac;
                    output.set(newValue, r, c, d);
                }
            }
        }
        return output;
    };
    NDArrayMathCPU.prototype.batchNormalization2DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.getValues();
        var meanValues = mean.getValues();
        var varianceValues = variance.getValues();
        var scaleValues = scale ? scale.getValues() : new Float32Array([1]);
        var offsetValues = offset ? offset.getValues() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.Array2D.new(x.shape, outValues);
    };
    NDArrayMathCPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.getValues();
        var meanValues = mean.getValues();
        var varianceValues = variance.getValues();
        var scaleValues = scale ? scale.getValues() : new Float32Array([1]);
        var offsetValues = offset ? offset.getValues() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.Array3D.new(x.shape, outValues);
    };
    NDArrayMathCPU.prototype.multinomialInternal = function (probabilities, numSamples, seed) {
        var batchSize = probabilities.shape[0];
        var numEvents = probabilities.shape[1];
        var res = ndarray_1.Array2D.zeros([batchSize, numSamples], 'int32');
        var resVals = res.getValues();
        var probVals = probabilities.getValues();
        for (var b = 0; b < batchSize; ++b) {
            var offset = b * numEvents;
            var cdf = new Float32Array(numEvents - 1);
            cdf[0] = probVals[offset];
            for (var event_1 = 1; event_1 < cdf.length; ++event_1) {
                cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];
            }
            var random = seedrandom.alea(seed.toString());
            var outOffset = b * numSamples;
            for (var sampleId = 0; sampleId < numSamples; ++sampleId) {
                var r = random();
                resVals[outOffset + sampleId] = cdf.length;
                for (var event_2 = 0; event_2 < cdf.length; event_2++) {
                    if (r < cdf[event_2]) {
                        resVals[outOffset + sampleId] = event_2;
                        break;
                    }
                }
            }
        }
        return res;
    };
    NDArrayMathCPU.prototype.oneHotInternal = function (indices, depth, onValue, offValue) {
        var res = new Float32Array(indices.size * depth);
        res.fill(offValue);
        for (var event_3 = 0; event_3 < indices.size; ++event_3) {
            res[event_3 * depth + indices.get(event_3)] = onValue;
        }
        return ndarray_1.Array2D.new([indices.size, depth], res);
    };
    NDArrayMathCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var result = ndarray_1.NDArray.zeros(newShape, dtype);
        var newValues = result.getValues();
        var aValues = a.getValues();
        var bValues = b.getValues();
        var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
        var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
        var _loop_1 = function (i) {
            var loc = result.indexToLoc(i);
            var aLoc = loc.slice(-a.rank);
            aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });
            var aIndex = a.locToIndex(aLoc);
            var bLoc = loc.slice(-b.rank);
            bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });
            var bIndex = b.locToIndex(bLoc);
            newValues[i] = op(aValues[aIndex], bValues[bIndex]);
        };
        for (var i = 0; i < newValues.length; ++i) {
            _loop_1(i);
        }
        return result;
    };
    return NDArrayMathCPU;
}(math_1.NDArrayMath));
exports.NDArrayMathCPU = NDArrayMathCPU;
//# sourceMappingURL=math_cpu.js.map

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = __webpack_require__(4);
var axis_util = __webpack_require__(109);
var math_1 = __webpack_require__(57);
var ndarray = __webpack_require__(6);
var ndarray_1 = __webpack_require__(6);
var reduce_util = __webpack_require__(406);
var addscaledmat_gpu_1 = __webpack_require__(408);
var argminmax_gpu_1 = __webpack_require__(409);
var batchnorm_gpu_1 = __webpack_require__(410);
var binaryop_gpu = __webpack_require__(156);
var binaryop_gpu_1 = __webpack_require__(156);
var clip_gpu_1 = __webpack_require__(411);
var concat_gpu_1 = __webpack_require__(412);
var conv_backprop_gpu_1 = __webpack_require__(413);
var conv_gpu_1 = __webpack_require__(414);
var conv_gpu_depthwise_1 = __webpack_require__(415);
var copy_gpu_1 = __webpack_require__(416);
var gpgpu_context_1 = __webpack_require__(157);
var gpgpu_math = __webpack_require__(417);
var gpgpu_util = __webpack_require__(110);
var max_pool_backprop_gpu_1 = __webpack_require__(418);
var mulmat_gpu_1 = __webpack_require__(419);
var multinomial_gpu_1 = __webpack_require__(420);
var onehot_gpu_1 = __webpack_require__(421);
var pool_gpu_1 = __webpack_require__(422);
var reduce_gpu_1 = __webpack_require__(423);
var resize_bilinear_gpu_1 = __webpack_require__(425);
var slice_gpu_1 = __webpack_require__(426);
var texture_manager_1 = __webpack_require__(427);
var tile_gpu_1 = __webpack_require__(428);
var transpose_gpu_1 = __webpack_require__(429);
var unary_op = __webpack_require__(158);
var unaryop_gpu_1 = __webpack_require__(158);
var webgl_util = __webpack_require__(58);
var NDArrayMathGPU = (function (_super) {
    __extends(NDArrayMathGPU, _super);
    function NDArrayMathGPU(gpgpu, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        var _this = _super.call(this, safeMode) || this;
        _this.binaryCache = {};
        if (gpgpu == null) {
            var gl = gpgpu_util.createWebGLContext();
            _this.gpgpu = new gpgpu_context_1.GPGPUContext(gl);
            _this.gpgpuCreatedLocally = true;
        }
        else {
            _this.gpgpu = gpgpu;
            _this.gpgpuCreatedLocally = false;
        }
        _this.textureManager = new texture_manager_1.TextureManager(_this.gpgpu);
        ndarray.initializeGPU(_this.gpgpu, _this.textureManager);
        return _this;
    }
    NDArrayMathGPU.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    NDArrayMathGPU.prototype.cloneInternal = function (a) {
        var texShape = a.getTextureShapeRC();
        var source = a.as2D(texShape[0], texShape[1]);
        var output = this.makeOutputArray(texShape, a.dtype);
        this.copy2D(source, [0, 0], texShape, output, [0, 0], texShape);
        return output.reshape(a.shape);
    };
    NDArrayMathGPU.prototype.slice1DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram([size]);
        var customSetup = program.getCustomSetupFunc([begin]);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.slice2DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.slice3DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.slice4DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        var program = new copy_gpu_1.Copy2DProgram(sourceSizeRowCol[1], destSizeRowCol[1]);
        var customSetup = program.getCustomSetupFunc(sourceBeginRowCol, destBeginRowCol, destSizeRowCol);
        this.compileAndRun(program, [source], dest, customSetup);
    };
    NDArrayMathGPU.prototype.concat1DInternal = function (a, b) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, 0);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.concat2DInternal = function (a, b, axis) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, axis);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.concat3DInternal = function (x1, x2, axis) {
        var program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);
        return this.compileAndRun(program, [x1, x2]);
    };
    NDArrayMathGPU.prototype.concat4DInternal = function (x1, x2, axis) {
        var program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);
        return this.compileAndRun(program, [x1, x2]);
    };
    NDArrayMathGPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
        var program = new addscaledmat_gpu_1.AddScaledMatProgram(a.shape, b.shape);
        return this.compileAndRun(program, [a, b, c1, c2]);
    };
    NDArrayMathGPU.prototype.negInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.NEG);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.makeOutputArray = function (shape, dtype) {
        var textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
        var texture = this.textureManager.acquireTexture(textureShapeRC);
        return ndarray_1.NDArray.make(shape, { texture: texture, textureShapeRC: textureShapeRC }, dtype);
    };
    NDArrayMathGPU.prototype.compileAndRun = function (program, inputs, output, customSetup) {
        var _this = this;
        if (output == null) {
            output = this.makeOutputArray(program.outputShape, inputs[0].dtype);
        }
        var key = gpgpu_math.makeShaderKey(program, inputs, output);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputs, output);
        });
        gpgpu_math.runProgram(binary, inputs, output, customSetup);
        return output;
    };
    NDArrayMathGPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, aOrientation, bOrientation);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.multiplyInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.batchNormalization2DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    NDArrayMathGPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    NDArrayMathGPU.prototype.tileInternal = function (a, reps) {
        var program = new tile_gpu_1.TileProgram(a.shape, reps);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.transposeInternal = function (a, perm) {
        var program = new transpose_gpu_1.TransposeProgram(a.shape, perm);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.reduce = function (a, reduceType, dtype) {
        var batchSize = a.shape[0];
        var inSize = a.shape[1];
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray(program.outputShape, dtype).as2D(rows, cols);
        this.compileAndRun(program, [a], output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.reduce(output, reduceType, dtype);
    };
    NDArrayMathGPU.prototype.argReduce = function (a, reduceType, bestIndicesA) {
        if (bestIndicesA === void 0) { bestIndicesA = null; }
        var batchSize = a.shape[0];
        var inSize = a.shape[1];
        if (bestIndicesA != null) {
            batchSize = bestIndicesA.shape[0];
            inSize = bestIndicesA.shape[1];
        }
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray(program.outputShape, 'int32').as2D(rows, cols);
        var inputs = [a];
        if (bestIndicesA != null) {
            inputs.push(bestIndicesA);
        }
        this.compileAndRun(program, inputs, output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.argReduce(a, reduceType, output);
    };
    NDArrayMathGPU.prototype.sumInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        var outputDType = math_1.SumTypesMap[a.dtype];
        return this.reduce(a2D, 'sum', outputDType).reshape(outShape);
    };
    NDArrayMathGPU.prototype.argMinInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.argReduce(a2D, 'min').reshape(outShape);
    };
    NDArrayMathGPU.prototype.argMaxInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.argReduce(a2D, 'max').reshape(outShape);
    };
    NDArrayMathGPU.prototype.equalInternal = function (x, y) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, x.shape, y.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [x, y], output);
    };
    NDArrayMathGPU.prototype.topKInternal = function (ndarray, k) {
        throw new Error('topK GPU not yet implemented!');
    };
    NDArrayMathGPU.prototype.minInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);
    };
    NDArrayMathGPU.prototype.maxInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);
    };
    NDArrayMathGPU.prototype.divideInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.DIV, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [a, b], output);
    };
    NDArrayMathGPU.prototype.addInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.subtractInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.ceilInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.CEIL);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.floorInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.FLOOR);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.expInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.EXP);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.logInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LOG);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sqrtInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SQRT);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.squareInternal = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.reluInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.RELU);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.eluInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ELU);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.leakyReluInternal = function (a, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LEAKY_RELU(alpha));
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.clipInternal = function (a, min, max) {
        var program = new clip_gpu_1.ClipProgram(a.shape, min, max);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.absInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ABS);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sigmoidInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIGMOID);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sinInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.cosInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COS);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.tanInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TAN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.asinInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ASIN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.acosInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ACOS);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.atanInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ATAN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sinhInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SINH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.coshInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COSH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.tanhInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TANH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.stepInternal = function (a, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.STEP(alpha));
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.conv2dInternal = function (x, filter, bias, convInfo) {
        var program = new conv_gpu_1.Conv2DProgram(convInfo, bias != null);
        var inputs = bias != null ? [x, filter, bias] : [x, filter];
        return this.compileAndRun(program, inputs);
    };
    NDArrayMathGPU.prototype.conv2dDerInputInternal = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    NDArrayMathGPU.prototype.conv2dDerFilterInternal = function (x, dY, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerWeightsProgram(convInfo);
        return this.compileAndRun(program, [x, dY]);
    };
    NDArrayMathGPU.prototype.conv2dDerBiasInternal = function (dY) {
        var program = new conv_backprop_gpu_1.Conv2DDerBiasProgram(dY.shape);
        return this.compileAndRun(program, [dY]);
    };
    NDArrayMathGPU.prototype.depthwiseConv2DInternal = function (input, filter, convInfo) {
        var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
        return this.compileAndRun(program, [input, filter]);
    };
    NDArrayMathGPU.prototype.maxPoolInternal = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.minPoolInternal = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'min', false);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.avgPoolInternal = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.maxPoolBackpropInternal = function (dy, x, convInfo) {
        var getPositions = true;
        var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);
        var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
        var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
        var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions]);
        maxPoolPositions.dispose();
        return result;
    };
    NDArrayMathGPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
        var program = new resize_bilinear_gpu_1.ResizeBilinear3DProgram(x.shape, newShape2D, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.multinomialInternal = function (probs, numSamples, seed) {
        var batchSize = probs.shape[0];
        var numOutcomes = probs.shape[1];
        var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        var customSetup = program.getCustomSetupFunc(seed);
        return this.compileAndRun(program, [probs], output, customSetup);
    };
    NDArrayMathGPU.prototype.oneHotInternal = function (indices, depth, onValue, offValue) {
        var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
        return this.compileAndRun(program, [indices]);
    };
    NDArrayMathGPU.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    NDArrayMathGPU.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    NDArrayMathGPU.prototype.dispose = function () {
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
    };
    return NDArrayMathGPU;
}(math_1.NDArrayMath));
exports.NDArrayMathGPU = NDArrayMathGPU;
//# sourceMappingURL=math_gpu.js.map

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = __webpack_require__(56);
exports.ADD = 'return a + b;';
exports.SUB = 'return a - b;';
exports.MUL = 'return a * b;';
exports.DIV = 'return a / b;';
exports.EQUAL = "\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n  return float(a == b);\n";
var BinaryOpProgram = (function () {
    function BinaryOpProgram(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + op + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
    }
    return BinaryOpProgram;
}());
exports.BinaryOpProgram = BinaryOpProgram;
//# sourceMappingURL=binaryop_gpu.js.map

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = __webpack_require__(32);
var util = __webpack_require__(4);
var gpgpu_util = __webpack_require__(110);
var tex_util = __webpack_require__(67);
var webgl_util = __webpack_require__(58);
var GPGPUContext = (function () {
    function GPGPUContext(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.autoDebugValidate = false;
        if (gl != null) {
            this.gl = gl;
        }
        else {
            this.gl = gpgpu_util.createWebGLContext();
        }
        if (environment_1.ENV.get('WEBGL_VERSION') === 1) {
            this.textureFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
            this.colorBufferFloatExtension =
                this.gl.getExtension('WEBGL_color_buffer_float');
        }
        else {
            this.colorBufferFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
        }
        this.loseContextExtension =
            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
        if (environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) {
            this.getBufferSubDataAsyncExtension =
                this.gl.getExtension('WEBGL_get_buffer_sub_data_async');
        }
        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
        this.framebuffer = webgl_util.createFramebuffer(this.gl);
    }
    GPGPUContext.prototype.dispose = function () {
        var _this = this;
        this.throwIfDisposed();
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        var gl = this.gl;
        webgl_util.callAndCheck(gl, function () { return gl.finish(); });
        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
        this.loseContextExtension.loseContext();
        this.disposed = true;
    };
    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
        this.autoDebugValidate = enabled;
        webgl_util.enableDebugWebGLErrorChecking(enabled);
    };
    GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
        this.throwIfDisposed();
        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
    };
    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
        var _this = this;
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
    };
    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        var numChannels = 1;
        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
    };
    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
    };
    GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () {
            return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
        });
    };
    GPGPUContext.prototype.downloadMatrixFromTextureAsync = function (texture, rows, columns) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.getBufferSubDataAsyncExtension == null) {
                    throw new Error("Cannot download matrix from output texture asynchronously, " +
                        "WEBGL_get_buffer_sub_data_async is not enabled.");
                }
                return [2, this.downloadMatrixDriverAsync(texture, function () { return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl, _this.getBufferSubDataAsyncExtension, rows, columns); })];
            });
        });
    };
    GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture = function (texture, rows, columns, channels) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl, rows, columns, channels); });
    };
    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });
    };
    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
        this.throwIfDisposed();
        var gl = this.gl;
        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
        var vertexShader = gpgpu_util.createVertexShader(gl);
        var program = webgl_util.createProgram(gl);
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
        webgl_util.linkProgram(gl, program);
        if (this.autoDebugValidate) {
            webgl_util.validateProgram(gl, program);
        }
        return program;
    };
    GPGPUContext.prototype.deleteProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
        }
    };
    GPGPUContext.prototype.setProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.autoDebugValidate) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
    };
    GPGPUContext.prototype.getUniformLocation = function (program, uniformName) {
        this.throwIfDisposed();
        return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
    };
    GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
        var _this = this;
        this.throwIfDisposed();
        return webgl_util.callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });
    };
    GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
    };
    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);
    };
    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    };
    GPGPUContext.prototype.debugValidate = function () {
        if (this.program != null) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.validateFramebuffer(this.gl);
    };
    GPGPUContext.prototype.executeProgram = function (attribLocations) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var gl = this.gl;
        gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer, attribLocations);
        if (this.autoDebugValidate) {
            this.debugValidate();
        }
        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
    };
    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
    };
    GPGPUContext.prototype.runQuery = function (queryFn) {
        if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
            return this.runQueryWebGL2(queryFn);
        }
        return this.runQueryWebGL1(queryFn);
    };
    GPGPUContext.prototype.runQueryWebGL2 = function (benchmark) {
        var _this = this;
        var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query_webgl2');
        var query = this.gl.createQuery();
        this.gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
        benchmark();
        this.gl.endQuery(ext.TIME_ELAPSED_EXT);
        return new Promise(function (resolve, reject) {
            var queryGPU = function () {
                var available = _this.gl
                    .getQueryParameter(query, _this.gl.QUERY_RESULT_AVAILABLE);
                var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                return available && !disjoint;
            };
            var getTimeElapsed = function () {
                var timeElapsedNanos = _this.gl
                    .getQueryParameter(query, _this.gl.QUERY_RESULT);
                resolve(timeElapsedNanos / 1000000);
            };
            var resolveWithWarning = function () {
                console.warn('Disjoint query timer never available.');
                resolve(-1);
            };
            util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
        });
    };
    GPGPUContext.prototype.runQueryWebGL1 = function (benchmark) {
        var _this = this;
        var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query');
        var query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        benchmark();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
        return new Promise(function (resolve, reject) {
            var queryGPU = function () {
                var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
                var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                return available && !disjoint;
            };
            var getTimeElapsed = function () {
                var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
                resolve(timeElapsedNanos / 1000000);
            };
            var resolveWithWarning = function () {
                console.warn('Disjoint query timer never available.');
                resolve(-1);
            };
            util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
        });
    };
    GPGPUContext.prototype.downloadMatrixDriverSetup = function (texture) {
        this.throwIfDisposed();
        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(this.gl);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriverTeardown = function () {
        if (this.outputTexture != null) {
            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.autoDebugValidate) {
                webgl_util.validateFramebuffer(this.gl);
            }
        }
        else {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
        this.downloadMatrixDriverSetup(texture);
        var result = downloadAndDecode();
        this.downloadMatrixDriverTeardown();
        return result;
    };
    GPGPUContext.prototype.downloadMatrixDriverAsync = function (texture, downloadAndDecode) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.downloadMatrixDriverSetup(texture);
                        return [4, downloadAndDecode()];
                    case 1:
                        result = _a.sent();
                        this.downloadMatrixDriverTeardown();
                        return [2, result];
                }
            });
        });
    };
    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        var gl = this.gl;
        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
    };
    GPGPUContext.prototype.throwIfDisposed = function () {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    };
    GPGPUContext.prototype.throwIfNoProgram = function () {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    };
    return GPGPUContext;
}());
exports.GPGPUContext = GPGPUContext;
//# sourceMappingURL=gpgpu_context.js.map

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var UnaryOpProgram = (function () {
    function UnaryOpProgram(aShape, opSnippet) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = "\n      float unaryOperation(float x) {\n        " + opSnippet + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    }
    return UnaryOpProgram;
}());
exports.UnaryOpProgram = UnaryOpProgram;
exports.CHECK_NAN_SNIPPET = "\n  if (isNaN(x)) {\n    return x;\n  }\n";
exports.ABS = "\n  return abs(x);\n";
exports.RELU = "\n  return (x < 0.0) ? 0.0 : x;\n";
exports.ELU = "\n  return (x >= 0.0) ? x : (exp(x) - 1.0);\n";
function LEAKY_RELU(alpha) {
    return "\n    return (x >= 0.0) ? x : " + alpha + " * x;\n  ";
}
exports.LEAKY_RELU = LEAKY_RELU;
function STEP(alpha) {
    if (alpha === void 0) { alpha = 0.0; }
    return "\n    return (x == x) ? (x > 0.0 ? 1.0 : float(" + alpha + ")) : x;\n  ";
}
exports.STEP = STEP;
exports.NEG = "\n  return -x;\n";
exports.CEIL = "\n  return ceil(x);\n";
exports.FLOOR = "\n  return floor(x);\n";
exports.EXP = "\n  return exp(x);\n";
exports.LOG = "\n  return log(x);\n";
exports.SQRT = exports.CHECK_NAN_SNIPPET + "\n  return sqrt(x);\n";
exports.SIGMOID = "\n  return 1.0 / (1.0 + exp(-1.0 * x));\n";
exports.SIN = exports.CHECK_NAN_SNIPPET + "\n  return sin(x);\n";
exports.COS = exports.CHECK_NAN_SNIPPET + "\n  return cos(x);\n";
exports.TAN = "\n  return tan(x);\n";
exports.ASIN = exports.CHECK_NAN_SNIPPET + "\n  return asin(x);\n";
exports.ACOS = exports.CHECK_NAN_SNIPPET + "\n  return acos(x);\n";
exports.ATAN = exports.CHECK_NAN_SNIPPET + "\n  return atan(x);\n";
exports.SINH = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
exports.COSH = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
exports.TANH = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
exports.SQUARE = "\n  return x * x;\n";
//# sourceMappingURL=unaryop_gpu.js.map

/***/ }),
/* 159 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
p5ML v.0.0.1

p5ML is a high level javascript library for machine learning.
Made @ NYU ITP
*/



var _index = __webpack_require__(166);

var _index2 = __webpack_require__(165);

var _index3 = __webpack_require__(162);

var _index4 = __webpack_require__(164);

var _deeplearn = __webpack_require__(38);

var deeplearn = _interopRequireWildcard(_deeplearn);

var _math = __webpack_require__(111);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

console.log('p5ML loaded');

window.deeplearn = deeplearn;

module.exports = {
  NeuralNetwork: _index.NeuralNetwork,
  LSTMGenerator: _index2.LSTMGenerator,
  ImageNet: _index3.ImageNet,
  KNNImageClassifier: _index4.KNNImageClassifier,
  math: _math.math
};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(369);

__webpack_require__(169);

__webpack_require__(170);

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(159)))

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageNet = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Image net Class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _index = __webpack_require__(68);

var _deeplearn = __webpack_require__(38);

var _squeezenet = __webpack_require__(163);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ImageNet = function () {
  function ImageNet(model) {
    var _this = this;

    var loadSqueezNet = function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var squeezeNet;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return new _squeezenet.SqueezeNet(_index.math);

              case 2:
                squeezeNet = _context.sent;
                _context.next = 5;
                return squeezeNet.load();

              case 5:
                return _context.abrupt('return', squeezeNet);

              case 6:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function loadSqueezNet() {
        return _ref.apply(this, arguments);
      };
    }();

    _classCallCheck(this, ImageNet);

    this.model = model;

    loadSqueezNet().then(function (sn) {
      return _this.squeezeNet = sn;
    });
  }

  _createClass(ImageNet, [{
    key: 'predict',
    value: function predict(img, callback, num) {
      var _this2 = this;

      if (!this.squeezeNet) {
        setTimeout(function () {
          _this2.predict(img, callback);
        }, 400);
      } else {
        var predictImage = function () {
          var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var inferenceResult;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return _squeezeNet.predict(image);

                  case 2:
                    inferenceResult = _context2.sent;
                    _context2.next = 5;
                    return _squeezeNet.getTopKClasses(inferenceResult.logits, num || 10);

                  case 5:
                    return _context2.abrupt('return', _context2.sent);

                  case 6:
                  case 'end':
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          return function predictImage() {
            return _ref2.apply(this, arguments);
          };
        }();

        var image = _deeplearn.Array3D.fromPixels(img);
        var _squeezeNet = this.squeezeNet;

        predictImage().then(function (data) {

          var results = [];
          for (var value in data) {
            var result = {
              label: value,
              probability: data[value]
            };
            results.push(result);
          }
          results.sort(function (a, b) {
            return b.probability - a.probability;
          });
          callback(results);
        });
      }
    }
  }]);

  return ImageNet;
}();

exports.ImageNet = ImageNet;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};(function(f){if(( false?"undefined":_typeof(exports))==="object"&&typeof module!=="undefined"){module.exports=f();}else if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else{var g;if(typeof window!=="undefined"){g=window;}else if(typeof global!=="undefined"){g=global;}else if(typeof self!=="undefined"){g=self;}else{g=this;}g.squeezenet=f();}})(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f;}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e);},l,l.exports,e,t,n,r);}return n[o].exports;}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++){s(r[o]);}return s;}({1:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.IMAGENET_CLASSES={0:'tench, Tinca tinca',1:'goldfish, Carassius auratus',2:'great white shark, white shark, man-eater, man-eating shark, '+'Carcharodon carcharias',3:'tiger shark, Galeocerdo cuvieri',4:'hammerhead, hammerhead shark',5:'electric ray, crampfish, numbfish, torpedo',6:'stingray',7:'cock',8:'hen',9:'ostrich, Struthio camelus',10:'brambling, Fringilla montifringilla',11:'goldfinch, Carduelis carduelis',12:'house finch, linnet, Carpodacus mexicanus',13:'junco, snowbird',14:'indigo bunting, indigo finch, indigo bird, Passerina cyanea',15:'robin, American robin, Turdus migratorius',16:'bulbul',17:'jay',18:'magpie',19:'chickadee',20:'water ouzel, dipper',21:'kite',22:'bald eagle, American eagle, Haliaeetus leucocephalus',23:'vulture',24:'great grey owl, great gray owl, Strix nebulosa',25:'European fire salamander, Salamandra salamandra',26:'common newt, Triturus vulgaris',27:'eft',28:'spotted salamander, Ambystoma maculatum',29:'axolotl, mud puppy, Ambystoma mexicanum',30:'bullfrog, Rana catesbeiana',31:'tree frog, tree-frog',32:'tailed frog, bell toad, ribbed toad, tailed toad, Ascaphus trui',33:'loggerhead, loggerhead turtle, Caretta caretta',34:'leatherback turtle, leatherback, leathery turtle, Dermochelys coriacea',35:'mud turtle',36:'terrapin',37:'box turtle, box tortoise',38:'banded gecko',39:'common iguana, iguana, Iguana iguana',40:'American chameleon, anole, Anolis carolinensis',41:'whiptail, whiptail lizard',42:'agama',43:'frilled lizard, Chlamydosaurus kingi',44:'alligator lizard',45:'Gila monster, Heloderma suspectum',46:'green lizard, Lacerta viridis',47:'African chameleon, Chamaeleo chamaeleon',48:'Komodo dragon, Komodo lizard, dragon lizard, giant lizard, '+'Varanus komodoensis',49:'African crocodile, Nile crocodile, Crocodylus niloticus',50:'American alligator, Alligator mississipiensis',51:'triceratops',52:'thunder snake, worm snake, Carphophis amoenus',53:'ringneck snake, ring-necked snake, ring snake',54:'hognose snake, puff adder, sand viper',55:'green snake, grass snake',56:'king snake, kingsnake',57:'garter snake, grass snake',58:'water snake',59:'vine snake',60:'night snake, Hypsiglena torquata',61:'boa constrictor, Constrictor constrictor',62:'rock python, rock snake, Python sebae',63:'Indian cobra, Naja naja',64:'green mamba',65:'sea snake',66:'horned viper, cerastes, sand viper, horned asp, Cerastes cornutus',67:'diamondback, diamondback rattlesnake, Crotalus adamanteus',68:'sidewinder, horned rattlesnake, Crotalus cerastes',69:'trilobite',70:'harvestman, daddy longlegs, Phalangium opilio',71:'scorpion',72:'black and gold garden spider, Argiope aurantia',73:'barn spider, Araneus cavaticus',74:'garden spider, Aranea diademata',75:'black widow, Latrodectus mactans',76:'tarantula',77:'wolf spider, hunting spider',78:'tick',79:'centipede',80:'black grouse',81:'ptarmigan',82:'ruffed grouse, partridge, Bonasa umbellus',83:'prairie chicken, prairie grouse, prairie fowl',84:'peacock',85:'quail',86:'partridge',87:'African grey, African gray, Psittacus erithacus',88:'macaw',89:'sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita',90:'lorikeet',91:'coucal',92:'bee eater',93:'hornbill',94:'hummingbird',95:'jacamar',96:'toucan',97:'drake',98:'red-breasted merganser, Mergus serrator',99:'goose',100:'black swan, Cygnus atratus',101:'tusker',102:'echidna, spiny anteater, anteater',103:'platypus, duckbill, duckbilled platypus, duck-billed platypus, '+'Ornithorhynchus anatinus',104:'wallaby, brush kangaroo',105:'koala, koala bear, kangaroo bear, native bear, Phascolarctos cinereus',106:'wombat',107:'jelly fish',108:'sea anemone, anemone',109:'brain coral',110:'flatworm, platyhelminth',111:'nematode, nematode worm, roundworm',112:'conch',113:'snail',114:'slug',115:'sea slug, nudibranch',116:'chiton, coat-of-mail shell, sea cradle, polyplacophore',117:'chambered nautilus, pearly nautilus, nautilus',118:'Dungeness crab, Cancer magister',119:'rock crab, Cancer irroratus',120:'fiddler crab',121:'king crab, Alaska crab, Alaskan king crab, Alaska king crab, '+'Paralithodes camtschatica',122:'American lobster, Northern lobster, Maine lobster, Homarus americanus',123:'spiny lobster, langouste, rock lobster, crawfish, crayfish, sea '+'crawfish',124:'crayfish, crawfish, crawdad, crawdaddy',125:'hermit crab',126:'isopod',127:'white stork, Ciconia ciconia',128:'black stork, Ciconia nigra',129:'spoonbill',130:'flamingo',131:'little blue heron, Egretta caerulea',132:'American egret, great white heron, Egretta albus',133:'bittern',134:'crane',135:'limpkin, Aramus pictus',136:'European gallinule, Porphyrio porphyrio',137:'American coot, marsh hen, mud hen, water hen, Fulica americana',138:'bustard',139:'ruddy turnstone, Arenaria interpres',140:'red-backed sandpiper, dunlin, Erolia alpina',141:'redshank, Tringa totanus',142:'dowitcher',143:'oystercatcher, oyster catcher',144:'pelican',145:'king penguin, Aptenodytes patagonica',146:'albatross, mollymawk',147:'grey whale, gray whale, devilfish, Eschrichtius gibbosus, '+'Eschrichtius robustus',148:'killer whale, killer, orca, grampus, sea wolf, Orcinus orca',149:'dugong, Dugong dugon',150:'sea lion',151:'Chihuahua',152:'Japanese spaniel',153:'Maltese dog, Maltese terrier, Maltese',154:'Pekinese, Pekingese, Peke',155:'Shih-Tzu',156:'Blenheim spaniel',157:'papillon',158:'toy terrier',159:'Rhodesian ridgeback',160:'Afghan hound, Afghan',161:'basset, basset hound',162:'beagle',163:'bloodhound, sleuthhound',164:'bluetick',165:'black-and-tan coonhound',166:'Walker hound, Walker foxhound',167:'English foxhound',168:'redbone',169:'borzoi, Russian wolfhound',170:'Irish wolfhound',171:'Italian greyhound',172:'whippet',173:'Ibizan hound, Ibizan Podenco',174:'Norwegian elkhound, elkhound',175:'otterhound, otter hound',176:'Saluki, gazelle hound',177:'Scottish deerhound, deerhound',178:'Weimaraner',179:'Staffordshire bullterrier, Staffordshire bull terrier',180:'American Staffordshire terrier, Staffordshire terrier, American pit '+'bull terrier, pit bull terrier',181:'Bedlington terrier',182:'Border terrier',183:'Kerry blue terrier',184:'Irish terrier',185:'Norfolk terrier',186:'Norwich terrier',187:'Yorkshire terrier',188:'wire-haired fox terrier',189:'Lakeland terrier',190:'Sealyham terrier, Sealyham',191:'Airedale, Airedale terrier',192:'cairn, cairn terrier',193:'Australian terrier',194:'Dandie Dinmont, Dandie Dinmont terrier',195:'Boston bull, Boston terrier',196:'miniature schnauzer',197:'giant schnauzer',198:'standard schnauzer',199:'Scotch terrier, Scottish terrier, Scottie',200:'Tibetan terrier, chrysanthemum dog',201:'silky terrier, Sydney silky',202:'soft-coated wheaten terrier',203:'West Highland white terrier',204:'Lhasa, Lhasa apso',205:'flat-coated retriever',206:'curly-coated retriever',207:'golden retriever',208:'Labrador retriever',209:'Chesapeake Bay retriever',210:'German short-haired pointer',211:'vizsla, Hungarian pointer',212:'English setter',213:'Irish setter, red setter',214:'Gordon setter',215:'Brittany spaniel',216:'clumber, clumber spaniel',217:'English springer, English springer spaniel',218:'Welsh springer spaniel',219:'cocker spaniel, English cocker spaniel, cocker',220:'Sussex spaniel',221:'Irish water spaniel',222:'kuvasz',223:'schipperke',224:'groenendael',225:'malinois',226:'briard',227:'kelpie',228:'komondor',229:'Old English sheepdog, bobtail',230:'Shetland sheepdog, Shetland sheep dog, Shetland',231:'collie',232:'Border collie',233:'Bouvier des Flandres, Bouviers des Flandres',234:'Rottweiler',235:'German shepherd, German shepherd dog, German police dog, alsatian',236:'Doberman, Doberman pinscher',237:'miniature pinscher',238:'Greater Swiss Mountain dog',239:'Bernese mountain dog',240:'Appenzeller',241:'EntleBucher',242:'boxer',243:'bull mastiff',244:'Tibetan mastiff',245:'French bulldog',246:'Great Dane',247:'Saint Bernard, St Bernard',248:'Eskimo dog, husky',249:'malamute, malemute, Alaskan malamute',250:'Siberian husky',251:'dalmatian, coach dog, carriage dog',252:'affenpinscher, monkey pinscher, monkey dog',253:'basenji',254:'pug, pug-dog',255:'Leonberg',256:'Newfoundland, Newfoundland dog',257:'Great Pyrenees',258:'Samoyed, Samoyede',259:'Pomeranian',260:'chow, chow chow',261:'keeshond',262:'Brabancon griffon',263:'Pembroke, Pembroke Welsh corgi',264:'Cardigan, Cardigan Welsh corgi',265:'toy poodle',266:'miniature poodle',267:'standard poodle',268:'Mexican hairless',269:'timber wolf, grey wolf, gray wolf, Canis lupus',270:'white wolf, Arctic wolf, Canis lupus tundrarum',271:'red wolf, maned wolf, Canis rufus, Canis niger',272:'coyote, prairie wolf, brush wolf, Canis latrans',273:'dingo, warrigal, warragal, Canis dingo',274:'dhole, Cuon alpinus',275:'African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus',276:'hyena, hyaena',277:'red fox, Vulpes vulpes',278:'kit fox, Vulpes macrotis',279:'Arctic fox, white fox, Alopex lagopus',280:'grey fox, gray fox, Urocyon cinereoargenteus',281:'tabby, tabby cat',282:'tiger cat',283:'Persian cat',284:'Siamese cat, Siamese',285:'Egyptian cat',286:'cougar, puma, catamount, mountain lion, painter, panther, '+'Felis concolor',287:'lynx, catamount',288:'leopard, Panthera pardus',289:'snow leopard, ounce, Panthera uncia',290:'jaguar, panther, Panthera onca, Felis onca',291:'lion, king of beasts, Panthera leo',292:'tiger, Panthera tigris',293:'cheetah, chetah, Acinonyx jubatus',294:'brown bear, bruin, Ursus arctos',295:'American black bear, black bear, Ursus americanus, Euarctos '+'americanus',296:'ice bear, polar bear, Ursus Maritimus, Thalarctos maritimus',297:'sloth bear, Melursus ursinus, Ursus ursinus',298:'mongoose',299:'meerkat, mierkat',300:'tiger beetle',301:'ladybug, ladybeetle, lady beetle, ladybird, ladybird beetle',302:'ground beetle, carabid beetle',303:'long-horned beetle, longicorn, longicorn beetle',304:'leaf beetle, chrysomelid',305:'dung beetle',306:'rhinoceros beetle',307:'weevil',308:'fly',309:'bee',310:'ant, emmet, pismire',311:'grasshopper, hopper',312:'cricket',313:'walking stick, walkingstick, stick insect',314:'cockroach, roach',315:'mantis, mantid',316:'cicada, cicala',317:'leafhopper',318:'lacewing, lacewing fly',319:'dragonfly, darning needle, devil\'s darning needle, sewing needle, '+'snake feeder, snake doctor, mosquito hawk, skeeter hawk',320:'damselfly',321:'admiral',322:'ringlet, ringlet butterfly',323:'monarch, monarch butterfly, milkweed butterfly, Danaus plexippus',324:'cabbage butterfly',325:'sulphur butterfly, sulfur butterfly',326:'lycaenid, lycaenid butterfly',327:'starfish, sea star',328:'sea urchin',329:'sea cucumber, holothurian',330:'wood rabbit, cottontail, cottontail rabbit',331:'hare',332:'Angora, Angora rabbit',333:'hamster',334:'porcupine, hedgehog',335:'fox squirrel, eastern fox squirrel, Sciurus niger',336:'marmot',337:'beaver',338:'guinea pig, Cavia cobaya',339:'sorrel',340:'zebra',341:'hog, pig, grunter, squealer, Sus scrofa',342:'wild boar, boar, Sus scrofa',343:'warthog',344:'hippopotamus, hippo, river horse, Hippopotamus amphibius',345:'ox',346:'water buffalo, water ox, Asiatic buffalo, Bubalus bubalis',347:'bison',348:'ram, tup',349:'bighorn, bighorn sheep, cimarron, Rocky Mountain bighorn, Rocky '+'Mountain sheep, Ovis canadensis',350:'ibex, Capra ibex',351:'hartebeest',352:'impala, Aepyceros melampus',353:'gazelle',354:'Arabian camel, dromedary, Camelus dromedarius',355:'llama',356:'weasel',357:'mink',358:'polecat, fitch, foulmart, foumart, Mustela putorius',359:'black-footed ferret, ferret, Mustela nigripes',360:'otter',361:'skunk, polecat, wood pussy',362:'badger',363:'armadillo',364:'three-toed sloth, ai, Bradypus tridactylus',365:'orangutan, orang, orangutang, Pongo pygmaeus',366:'gorilla, Gorilla gorilla',367:'chimpanzee, chimp, Pan troglodytes',368:'gibbon, Hylobates lar',369:'siamang, Hylobates syndactylus, Symphalangus syndactylus',370:'guenon, guenon monkey',371:'patas, hussar monkey, Erythrocebus patas',372:'baboon',373:'macaque',374:'langur',375:'colobus, colobus monkey',376:'proboscis monkey, Nasalis larvatus',377:'marmoset',378:'capuchin, ringtail, Cebus capucinus',379:'howler monkey, howler',380:'titi, titi monkey',381:'spider monkey, Ateles geoffroyi',382:'squirrel monkey, Saimiri sciureus',383:'Madagascar cat, ring-tailed lemur, Lemur catta',384:'indri, indris, Indri indri, Indri brevicaudatus',385:'Indian elephant, Elephas maximus',386:'African elephant, Loxodonta africana',387:'lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens',388:'giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca',389:'barracouta, snoek',390:'eel',391:'coho, cohoe, coho salmon, blue jack, silver salmon, Oncorhynchus '+'kisutch',392:'rock beauty, Holocanthus tricolor',393:'anemone fish',394:'sturgeon',395:'gar, garfish, garpike, billfish, Lepisosteus osseus',396:'lionfish',397:'puffer, pufferfish, blowfish, globefish',398:'abacus',399:'abaya',400:'academic gown, academic robe, judge\'s robe',401:'accordion, piano accordion, squeeze box',402:'acoustic guitar',403:'aircraft carrier, carrier, flattop, attack aircraft carrier',404:'airliner',405:'airship, dirigible',406:'altar',407:'ambulance',408:'amphibian, amphibious vehicle',409:'analog clock',410:'apiary, bee house',411:'apron',412:'ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, '+'dustbin, trash barrel, trash bin',413:'assault rifle, assault gun',414:'backpack, back pack, knapsack, packsack, rucksack, haversack',415:'bakery, bakeshop, bakehouse',416:'balance beam, beam',417:'balloon',418:'ballpoint, ballpoint pen, ballpen, Biro',419:'Band Aid',420:'banjo',421:'bannister, banister, balustrade, balusters, handrail',422:'barbell',423:'barber chair',424:'barbershop',425:'barn',426:'barometer',427:'barrel, cask',428:'barrow, garden cart, lawn cart, wheelbarrow',429:'baseball',430:'basketball',431:'bassinet',432:'bassoon',433:'bathing cap, swimming cap',434:'bath towel',435:'bathtub, bathing tub, bath, tub',436:'beach wagon, station wagon, wagon, estate car, beach waggon, station '+'waggon, waggon',437:'beacon, lighthouse, beacon light, pharos',438:'beaker',439:'bearskin, busby, shako',440:'beer bottle',441:'beer glass',442:'bell cote, bell cot',443:'bib',444:'bicycle-built-for-two, tandem bicycle, tandem',445:'bikini, two-piece',446:'binder, ring-binder',447:'binoculars, field glasses, opera glasses',448:'birdhouse',449:'boathouse',450:'bobsled, bobsleigh, bob',451:'bolo tie, bolo, bola tie, bola',452:'bonnet, poke bonnet',453:'bookcase',454:'bookshop, bookstore, bookstall',455:'bottlecap',456:'bow',457:'bow tie, bow-tie, bowtie',458:'brass, memorial tablet, plaque',459:'brassiere, bra, bandeau',460:'breakwater, groin, groyne, mole, bulwark, seawall, jetty',461:'breastplate, aegis, egis',462:'broom',463:'bucket, pail',464:'buckle',465:'bulletproof vest',466:'bullet train, bullet',467:'butcher shop, meat market',468:'cab, hack, taxi, taxicab',469:'caldron, cauldron',470:'candle, taper, wax light',471:'cannon',472:'canoe',473:'can opener, tin opener',474:'cardigan',475:'car mirror',476:'carousel, carrousel, merry-go-round, roundabout, whirligig',477:'carpenter\'s kit, tool kit',478:'carton',479:'car wheel',480:'cash machine, cash dispenser, automated teller machine, automatic '+'teller machine, automated teller, automatic teller, ATM',481:'cassette',482:'cassette player',483:'castle',484:'catamaran',485:'CD player',486:'cello, violoncello',487:'cellular telephone, cellular phone, cellphone, cell, mobile phone',488:'chain',489:'chainlink fence',490:'chain mail, ring mail, mail, chain armor, chain armour, ring armor, '+'ring armour',491:'chain saw, chainsaw',492:'chest',493:'chiffonier, commode',494:'chime, bell, gong',495:'china cabinet, china closet',496:'Christmas stocking',497:'church, church building',498:'cinema, movie theater, movie theatre, movie house, picture palace',499:'cleaver, meat cleaver, chopper',500:'cliff dwelling',501:'cloak',502:'clog, geta, patten, sabot',503:'cocktail shaker',504:'coffee mug',505:'coffeepot',506:'coil, spiral, volute, whorl, helix',507:'combination lock',508:'computer keyboard, keypad',509:'confectionery, confectionary, candy store',510:'container ship, containership, container vessel',511:'convertible',512:'corkscrew, bottle screw',513:'cornet, horn, trumpet, trump',514:'cowboy boot',515:'cowboy hat, ten-gallon hat',516:'cradle',517:'crane',518:'crash helmet',519:'crate',520:'crib, cot',521:'Crock Pot',522:'croquet ball',523:'crutch',524:'cuirass',525:'dam, dike, dyke',526:'desk',527:'desktop computer',528:'dial telephone, dial phone',529:'diaper, nappy, napkin',530:'digital clock',531:'digital watch',532:'dining table, board',533:'dishrag, dishcloth',534:'dishwasher, dish washer, dishwashing machine',535:'disk brake, disc brake',536:'dock, dockage, docking facility',537:'dogsled, dog sled, dog sleigh',538:'dome',539:'doormat, welcome mat',540:'drilling platform, offshore rig',541:'drum, membranophone, tympan',542:'drumstick',543:'dumbbell',544:'Dutch oven',545:'electric fan, blower',546:'electric guitar',547:'electric locomotive',548:'entertainment center',549:'envelope',550:'espresso maker',551:'face powder',552:'feather boa, boa',553:'file, file cabinet, filing cabinet',554:'fireboat',555:'fire engine, fire truck',556:'fire screen, fireguard',557:'flagpole, flagstaff',558:'flute, transverse flute',559:'folding chair',560:'football helmet',561:'forklift',562:'fountain',563:'fountain pen',564:'four-poster',565:'freight car',566:'French horn, horn',567:'frying pan, frypan, skillet',568:'fur coat',569:'garbage truck, dustcart',570:'gasmask, respirator, gas helmet',571:'gas pump, gasoline pump, petrol pump, island dispenser',572:'goblet',573:'go-kart',574:'golf ball',575:'golfcart, golf cart',576:'gondola',577:'gong, tam-tam',578:'gown',579:'grand piano, grand',580:'greenhouse, nursery, glasshouse',581:'grille, radiator grille',582:'grocery store, grocery, food market, market',583:'guillotine',584:'hair slide',585:'hair spray',586:'half track',587:'hammer',588:'hamper',589:'hand blower, blow dryer, blow drier, hair dryer, hair drier',590:'hand-held computer, hand-held microcomputer',591:'handkerchief, hankie, hanky, hankey',592:'hard disc, hard disk, fixed disk',593:'harmonica, mouth organ, harp, mouth harp',594:'harp',595:'harvester, reaper',596:'hatchet',597:'holster',598:'home theater, home theatre',599:'honeycomb',600:'hook, claw',601:'hoopskirt, crinoline',602:'horizontal bar, high bar',603:'horse cart, horse-cart',604:'hourglass',605:'iPod',606:'iron, smoothing iron',607:'jack-o\'-lantern',608:'jean, blue jean, denim',609:'jeep, landrover',610:'jersey, T-shirt, tee shirt',611:'jigsaw puzzle',612:'jinrikisha, ricksha, rickshaw',613:'joystick',614:'kimono',615:'knee pad',616:'knot',617:'lab coat, laboratory coat',618:'ladle',619:'lampshade, lamp shade',620:'laptop, laptop computer',621:'lawn mower, mower',622:'lens cap, lens cover',623:'letter opener, paper knife, paperknife',624:'library',625:'lifeboat',626:'lighter, light, igniter, ignitor',627:'limousine, limo',628:'liner, ocean liner',629:'lipstick, lip rouge',630:'Loafer',631:'lotion',632:'loudspeaker, speaker, speaker unit, loudspeaker system, speaker '+'system',633:'loupe, jeweler\'s loupe',634:'lumbermill, sawmill',635:'magnetic compass',636:'mailbag, postbag',637:'mailbox, letter box',638:'maillot',639:'maillot, tank suit',640:'manhole cover',641:'maraca',642:'marimba, xylophone',643:'mask',644:'matchstick',645:'maypole',646:'maze, labyrinth',647:'measuring cup',648:'medicine chest, medicine cabinet',649:'megalith, megalithic structure',650:'microphone, mike',651:'microwave, microwave oven',652:'military uniform',653:'milk can',654:'minibus',655:'miniskirt, mini',656:'minivan',657:'missile',658:'mitten',659:'mixing bowl',660:'mobile home, manufactured home',661:'Model T',662:'modem',663:'monastery',664:'monitor',665:'moped',666:'mortar',667:'mortarboard',668:'mosque',669:'mosquito net',670:'motor scooter, scooter',671:'mountain bike, all-terrain bike, off-roader',672:'mountain tent',673:'mouse, computer mouse',674:'mousetrap',675:'moving van',676:'muzzle',677:'nail',678:'neck brace',679:'necklace',680:'nipple',681:'notebook, notebook computer',682:'obelisk',683:'oboe, hautboy, hautbois',684:'ocarina, sweet potato',685:'odometer, hodometer, mileometer, milometer',686:'oil filter',687:'organ, pipe organ',688:'oscilloscope, scope, cathode-ray oscilloscope, CRO',689:'overskirt',690:'oxcart',691:'oxygen mask',692:'packet',693:'paddle, boat paddle',694:'paddlewheel, paddle wheel',695:'padlock',696:'paintbrush',697:'pajama, pyjama, pj\'s, jammies',698:'palace',699:'panpipe, pandean pipe, syrinx',700:'paper towel',701:'parachute, chute',702:'parallel bars, bars',703:'park bench',704:'parking meter',705:'passenger car, coach, carriage',706:'patio, terrace',707:'pay-phone, pay-station',708:'pedestal, plinth, footstall',709:'pencil box, pencil case',710:'pencil sharpener',711:'perfume, essence',712:'Petri dish',713:'photocopier',714:'pick, plectrum, plectron',715:'pickelhaube',716:'picket fence, paling',717:'pickup, pickup truck',718:'pier',719:'piggy bank, penny bank',720:'pill bottle',721:'pillow',722:'ping-pong ball',723:'pinwheel',724:'pirate, pirate ship',725:'pitcher, ewer',726:'plane, carpenter\'s plane, woodworking plane',727:'planetarium',728:'plastic bag',729:'plate rack',730:'plow, plough',731:'plunger, plumber\'s helper',732:'Polaroid camera, Polaroid Land camera',733:'pole',734:'police van, police wagon, paddy wagon, patrol wagon, wagon, black '+'Maria',735:'poncho',736:'pool table, billiard table, snooker table',737:'pop bottle, soda bottle',738:'pot, flowerpot',739:'potter\'s wheel',740:'power drill',741:'prayer rug, prayer mat',742:'printer',743:'prison, prison house',744:'projectile, missile',745:'projector',746:'puck, hockey puck',747:'punching bag, punch bag, punching ball, punchball',748:'purse',749:'quill, quill pen',750:'quilt, comforter, comfort, puff',751:'racer, race car, racing car',752:'racket, racquet',753:'radiator',754:'radio, wireless',755:'radio telescope, radio reflector',756:'rain barrel',757:'recreational vehicle, RV, R.V.',758:'reel',759:'reflex camera',760:'refrigerator, icebox',761:'remote control, remote',762:'restaurant, eating house, eating place, eatery',763:'revolver, six-gun, six-shooter',764:'rifle',765:'rocking chair, rocker',766:'rotisserie',767:'rubber eraser, rubber, pencil eraser',768:'rugby ball',769:'rule, ruler',770:'running shoe',771:'safe',772:'safety pin',773:'saltshaker, salt shaker',774:'sandal',775:'sarong',776:'sax, saxophone',777:'scabbard',778:'scale, weighing machine',779:'school bus',780:'schooner',781:'scoreboard',782:'screen, CRT screen',783:'screw',784:'screwdriver',785:'seat belt, seatbelt',786:'sewing machine',787:'shield, buckler',788:'shoe shop, shoe-shop, shoe store',789:'shoji',790:'shopping basket',791:'shopping cart',792:'shovel',793:'shower cap',794:'shower curtain',795:'ski',796:'ski mask',797:'sleeping bag',798:'slide rule, slipstick',799:'sliding door',800:'slot, one-armed bandit',801:'snorkel',802:'snowmobile',803:'snowplow, snowplough',804:'soap dispenser',805:'soccer ball',806:'sock',807:'solar dish, solar collector, solar furnace',808:'sombrero',809:'soup bowl',810:'space bar',811:'space heater',812:'space shuttle',813:'spatula',814:'speedboat',815:'spider web, spider\'s web',816:'spindle',817:'sports car, sport car',818:'spotlight, spot',819:'stage',820:'steam locomotive',821:'steel arch bridge',822:'steel drum',823:'stethoscope',824:'stole',825:'stone wall',826:'stopwatch, stop watch',827:'stove',828:'strainer',829:'streetcar, tram, tramcar, trolley, trolley car',830:'stretcher',831:'studio couch, day bed',832:'stupa, tope',833:'submarine, pigboat, sub, U-boat',834:'suit, suit of clothes',835:'sundial',836:'sunglass',837:'sunglasses, dark glasses, shades',838:'sunscreen, sunblock, sun blocker',839:'suspension bridge',840:'swab, swob, mop',841:'sweatshirt',842:'swimming trunks, bathing trunks',843:'swing',844:'switch, electric switch, electrical switch',845:'syringe',846:'table lamp',847:'tank, army tank, armored combat vehicle, armoured combat vehicle',848:'tape player',849:'teapot',850:'teddy, teddy bear',851:'television, television system',852:'tennis ball',853:'thatch, thatched roof',854:'theater curtain, theatre curtain',855:'thimble',856:'thresher, thrasher, threshing machine',857:'throne',858:'tile roof',859:'toaster',860:'tobacco shop, tobacconist shop, tobacconist',861:'toilet seat',862:'torch',863:'totem pole',864:'tow truck, tow car, wrecker',865:'toyshop',866:'tractor',867:'trailer truck, tractor trailer, trucking rig, rig, articulated '+'lorry, semi',868:'tray',869:'trench coat',870:'tricycle, trike, velocipede',871:'trimaran',872:'tripod',873:'triumphal arch',874:'trolleybus, trolley coach, trackless trolley',875:'trombone',876:'tub, vat',877:'turnstile',878:'typewriter keyboard',879:'umbrella',880:'unicycle, monocycle',881:'upright, upright piano',882:'vacuum, vacuum cleaner',883:'vase',884:'vault',885:'velvet',886:'vending machine',887:'vestment',888:'viaduct',889:'violin, fiddle',890:'volleyball',891:'waffle iron',892:'wall clock',893:'wallet, billfold, notecase, pocketbook',894:'wardrobe, closet, press',895:'warplane, military plane',896:'washbasin, handbasin, washbowl, lavabo, wash-hand basin',897:'washer, automatic washer, washing machine',898:'water bottle',899:'water jug',900:'water tower',901:'whiskey jug',902:'whistle',903:'wig',904:'window screen',905:'window shade',906:'Windsor tie',907:'wine bottle',908:'wing',909:'wok',910:'wooden spoon',911:'wool, woolen, woollen',912:'worm fence, snake fence, snake-rail fence, Virginia fence',913:'wreck',914:'yawl',915:'yurt',916:'web site, website, internet site, site',917:'comic book',918:'crossword puzzle, crossword',919:'street sign',920:'traffic light, traffic signal, stoplight',921:'book jacket, dust cover, dust jacket, dust wrapper',922:'menu',923:'plate',924:'guacamole',925:'consomme',926:'hot pot, hotpot',927:'trifle',928:'ice cream, icecream',929:'ice lolly, lolly, lollipop, popsicle',930:'French loaf',931:'bagel, beigel',932:'pretzel',933:'cheeseburger',934:'hotdog, hot dog, red hot',935:'mashed potato',936:'head cabbage',937:'broccoli',938:'cauliflower',939:'zucchini, courgette',940:'spaghetti squash',941:'acorn squash',942:'butternut squash',943:'cucumber, cuke',944:'artichoke, globe artichoke',945:'bell pepper',946:'cardoon',947:'mushroom',948:'Granny Smith',949:'strawberry',950:'orange',951:'lemon',952:'fig',953:'pineapple, ananas',954:'banana',955:'jackfruit, jak, jack',956:'custard apple',957:'pomegranate',958:'hay',959:'carbonara',960:'chocolate sauce, chocolate syrup',961:'dough',962:'meat loaf, meatloaf',963:'pizza, pizza pie',964:'potpie',965:'burrito',966:'red wine',967:'espresso',968:'cup',969:'eggnog',970:'alp',971:'bubble',972:'cliff, drop, drop-off',973:'coral reef',974:'geyser',975:'lakeside, lakeshore',976:'promontory, headland, head, foreland',977:'sandbar, sand bar',978:'seashore, coast, seacoast, sea-coast',979:'valley, vale',980:'volcano',981:'ballplayer, baseball player',982:'groom, bridegroom',983:'scuba diver',984:'rapeseed',985:'daisy',986:'yellow lady\'s slipper, yellow lady-slipper, Cypripedium calceolus, '+'Cypripedium parviflorum',987:'corn',988:'acorn',989:'hip, rose hip, rosehip',990:'buckeye, horse chestnut, conker',991:'coral fungus',992:'agaric',993:'gyromitra',994:'stinkhorn, carrion fungus',995:'earthstar',996:'hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola '+'frondosa',997:'bolete',998:'ear, spike, capitulum',999:'toilet tissue, toilet paper, bathroom tissue'};},{}],2:[function(require,module,exports){},{}],3:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../math/ndarray");var MANIFEST_FILE='manifest.json';var CheckpointLoader=function(){function CheckpointLoader(urlPath){this.urlPath=urlPath;if(this.urlPath.charAt(this.urlPath.length-1)!=='/'){this.urlPath+='/';}}CheckpointLoader.prototype.loadManifest=function(){var _this=this;return new Promise(function(resolve,reject){var xhr=new XMLHttpRequest();xhr.open('GET',_this.urlPath+MANIFEST_FILE);xhr.onload=function(){_this.checkpointManifest=JSON.parse(xhr.responseText);resolve();};xhr.onerror=function(error){throw new Error(MANIFEST_FILE+" not found at "+_this.urlPath+". "+error);};xhr.send();});};CheckpointLoader.prototype.getCheckpointManifest=function(){var _this=this;if(this.checkpointManifest==null){return new Promise(function(resolve,reject){_this.loadManifest().then(function(){resolve(_this.checkpointManifest);});});}return new Promise(function(resolve,reject){resolve(_this.checkpointManifest);});};CheckpointLoader.prototype.getAllVariables=function(){var _this=this;if(this.variables!=null){return new Promise(function(resolve,reject){resolve(_this.variables);});}return new Promise(function(resolve,reject){_this.getCheckpointManifest().then(function(checkpointDefinition){var variableNames=Object.keys(_this.checkpointManifest);var variablePromises=[];for(var i=0;i<variableNames.length;i++){variablePromises.push(_this.getVariable(variableNames[i]));}Promise.all(variablePromises).then(function(variables){_this.variables={};for(var i=0;i<variables.length;i++){_this.variables[variableNames[i]]=variables[i];}resolve(_this.variables);});});});};CheckpointLoader.prototype.getVariable=function(varName){var _this=this;if(!(varName in this.checkpointManifest)){throw new Error('Cannot load non-existant variable '+varName);}var variableRequestPromiseMethod=function variableRequestPromiseMethod(resolve,reject){var xhr=new XMLHttpRequest();xhr.responseType='arraybuffer';var fname=_this.checkpointManifest[varName].filename;xhr.open('GET',_this.urlPath+fname);xhr.onload=function(){var values=new Float32Array(xhr.response);var ndarray=ndarray_1.NDArray.make(_this.checkpointManifest[varName].shape,{values:values});resolve(ndarray);};xhr.onerror=function(error){throw new Error("Could not fetch variable "+varName+": "+error);};xhr.send();};if(this.checkpointManifest==null){return new Promise(function(resolve,reject){_this.loadManifest().then(function(){new Promise(variableRequestPromiseMethod).then(resolve);});});}return new Promise(variableRequestPromiseMethod);};return CheckpointLoader;}();exports.CheckpointLoader=CheckpointLoader;},{"../math/ndarray":56}],4:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../math/ndarray");var util=require("../util");var STATS_SAMPLE_PERCENTAGE=0.1;var InMemoryDataset=function(){function InMemoryDataset(dataShapes){this.dataShapes=dataShapes;this.normalizationInfo={};}InMemoryDataset.prototype.getDataShape=function(dataIndex){return this.dataShapes[dataIndex];};InMemoryDataset.prototype.getData=function(){return this.dataset;};InMemoryDataset.prototype.getStats=function(){var _this=this;if(this.dataset==null){throw new Error('Data is null.');}return this.dataset.map(function(d){return _this.getStatsForData(d);});};InMemoryDataset.prototype.getStatsForData=function(data){var inputMin=Number.POSITIVE_INFINITY;var inputMax=Number.NEGATIVE_INFINITY;var exampleIndices=data.map(function(example,i){return i;});util.shuffle(exampleIndices);exampleIndices=exampleIndices.slice(exampleIndices.length*STATS_SAMPLE_PERCENTAGE);for(var i=0;i<exampleIndices.length;i++){var inputValues=data[exampleIndices[i]].getValues();for(var j=0;j<inputValues.length;j++){inputMin=Math.min(inputMin,inputValues[j]);inputMax=Math.max(inputMax,inputValues[j]);}}return{inputMin:inputMin,inputMax:inputMax,exampleCount:data.length,shape:data[0].shape};};InMemoryDataset.prototype.normalizeExamplesToRange=function(examples,curLowerBounds,curUpperBounds,newLowerBounds,newUpperBounds){var curBoundsIsPerDimension=curUpperBounds instanceof Float32Array&&curLowerBounds instanceof Float32Array;var newBoundsIsPerDimension=newLowerBounds instanceof Float32Array&&newUpperBounds instanceof Float32Array;var inputSize=util.sizeFromShape(examples[0].shape);var newExamples=[];examples.forEach(function(example){var inputValues=example.getValues();var normalizedValues=new Float32Array(inputSize);for(var j=0;j<inputSize;j++){var curLowerBound=curBoundsIsPerDimension?curLowerBounds[j]:curLowerBounds;var curUpperBound=curBoundsIsPerDimension?curUpperBounds[j]:curUpperBounds;var curRange=curUpperBound-curLowerBound;var newLowerBound=newBoundsIsPerDimension?newLowerBounds[j]:newLowerBounds;var newUpperBound=newBoundsIsPerDimension?newUpperBounds[j]:newUpperBounds;var newRange=newUpperBound-newLowerBound;if(curRange===0){normalizedValues[j]=newLowerBound;}else{normalizedValues[j]=newLowerBound+newRange*(inputValues[j]-curLowerBound)/curRange;}}newExamples.push(ndarray_1.NDArray.make(example.shape,{values:normalizedValues}));});return newExamples;};InMemoryDataset.prototype.computeBounds=function(dataIndex){var _this=this;if(this.dataset==null){throw new Error('Data is null.');}var size=util.sizeFromShape(this.dataset[dataIndex][0].shape);this.normalizationInfo[dataIndex]={isNormalized:false,minValues:new Float32Array(size),maxValues:new Float32Array(size)};for(var i=0;i<size;i++){this.normalizationInfo[dataIndex].minValues[i]=Number.POSITIVE_INFINITY;this.normalizationInfo[dataIndex].maxValues[i]=Number.NEGATIVE_INFINITY;}this.dataset[dataIndex].forEach(function(example){var inputValues=example.getValues();for(var k=0;k<size;k++){_this.normalizationInfo[dataIndex].minValues[k]=Math.min(_this.normalizationInfo[dataIndex].minValues[k],inputValues[k]);_this.normalizationInfo[dataIndex].maxValues[k]=Math.max(_this.normalizationInfo[dataIndex].maxValues[k],inputValues[k]);}});};InMemoryDataset.prototype.normalizeWithinBounds=function(dataIndex,lowerBound,upperBound){if(this.dataset==null){throw new Error('Data is null.');}if(dataIndex>=this.dataset.length){throw new Error('dataIndex out of bounds.');}if(this.normalizationInfo[dataIndex]==null){this.computeBounds(dataIndex);}var curLowerBounds;var curUpperBounds;if(this.normalizationInfo[dataIndex].isNormalized){curLowerBounds=this.normalizationInfo[dataIndex].lowerBound;curUpperBounds=this.normalizationInfo[dataIndex].upperBound;}else{curLowerBounds=this.normalizationInfo[dataIndex].minValues;curUpperBounds=this.normalizationInfo[dataIndex].maxValues;}this.dataset[dataIndex]=this.normalizeExamplesToRange(this.dataset[dataIndex],curLowerBounds,curUpperBounds,lowerBound,upperBound);this.normalizationInfo[dataIndex].isNormalized=true;this.normalizationInfo[dataIndex].lowerBound=lowerBound;this.normalizationInfo[dataIndex].upperBound=upperBound;};InMemoryDataset.prototype.isNormalized=function(dataIndex){return this.normalizationInfo!=null&&this.normalizationInfo[dataIndex].isNormalized;};InMemoryDataset.prototype.removeNormalization=function(dataIndex){if(this.dataset==null){throw new Error('Training or test data is null.');}if(!this.isNormalized(dataIndex)){return;}this.dataset[dataIndex]=this.normalizeExamplesToRange(this.dataset[dataIndex],this.normalizationInfo[dataIndex].lowerBound,this.normalizationInfo[dataIndex].upperBound,this.normalizationInfo[dataIndex].minValues,this.normalizationInfo[dataIndex].maxValues);this.normalizationInfo[dataIndex].isNormalized=false;};InMemoryDataset.prototype.unnormalizeExamples=function(examples,dataIndex){if(!this.isNormalized(dataIndex)){return examples;}return this.normalizeExamplesToRange(examples,this.normalizationInfo[dataIndex].lowerBound,this.normalizationInfo[dataIndex].upperBound,this.normalizationInfo[dataIndex].minValues,this.normalizationInfo[dataIndex].maxValues);};InMemoryDataset.prototype.dispose=function(){if(this.dataset==null){return;}for(var i=0;i<this.dataset.length;i++){for(var j=0;j<this.dataset[i].length;j++){this.dataset[i][j].dispose();}}this.dataset=[];};return InMemoryDataset;}();exports.InMemoryDataset=InMemoryDataset;},{"../math/ndarray":56,"../util":88}],5:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../math/ndarray");var util=require("../util");var InMemoryShuffledInputProviderBuilder=function(){function InMemoryShuffledInputProviderBuilder(inputs){this.inputs=inputs;this.idx=0;this.inputCounter=0;this.epoch=0;this.shuffledIndices=util.createShuffledIndices(inputs[0].length);this.numInputs=inputs.length;var numExamples=this.inputs[0].length;for(var i=0;i<this.numInputs;i++){util.assert(this.inputs[i].length===numExamples,'Number of examples must match across different inputs.');}for(var i=0;i<this.numInputs;i++){var inputShape=this.inputs[i][0].shape;for(var j=0;j<this.inputs[i].length;j++){util.assertShapesMatch(inputShape,this.inputs[i][j].shape);}}}InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex=function(){var returnIdx=this.idx;this.inputCounter++;if(this.inputCounter>=this.numInputs){this.idx++;this.inputCounter=0;if(this.idx>=this.inputs[0].length){this.idx=0;this.epoch++;}}return returnIdx;};InMemoryShuffledInputProviderBuilder.prototype.getNextInput=function(inputId){var currentExampleIndex=this.getCurrentExampleIndex();return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];};InMemoryShuffledInputProviderBuilder.prototype.getEpoch=function(){return this.epoch;};InMemoryShuffledInputProviderBuilder.prototype.getInputProviders=function(){var inputProviders=[];for(var i=0;i<this.numInputs;i++){inputProviders.push(this.getInputProvider(i));}return inputProviders;};return InMemoryShuffledInputProviderBuilder;}();exports.InMemoryShuffledInputProviderBuilder=InMemoryShuffledInputProviderBuilder;var InCPUMemoryShuffledInputProviderBuilder=function(_super){__extends(InCPUMemoryShuffledInputProviderBuilder,_super);function InCPUMemoryShuffledInputProviderBuilder(){return _super!==null&&_super.apply(this,arguments)||this;}InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider=function(inputId){var shuffledInputProvider=this;return{getNextCopy:function getNextCopy(math){return ndarray_1.NDArray.like(shuffledInputProvider.getNextInput(inputId));},disposeCopy:function disposeCopy(math,copy){copy.dispose();}};};return InCPUMemoryShuffledInputProviderBuilder;}(InMemoryShuffledInputProviderBuilder);exports.InCPUMemoryShuffledInputProviderBuilder=InCPUMemoryShuffledInputProviderBuilder;var InGPUMemoryShuffledInputProviderBuilder=function(_super){__extends(InGPUMemoryShuffledInputProviderBuilder,_super);function InGPUMemoryShuffledInputProviderBuilder(){return _super!==null&&_super.apply(this,arguments)||this;}InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider=function(inputId){var shuffledInputProvider=this;return{getNextCopy:function getNextCopy(math){return math.clone(shuffledInputProvider.getNextInput(inputId));},disposeCopy:function disposeCopy(math,copy){copy.dispose();}};};return InGPUMemoryShuffledInputProviderBuilder;}(InMemoryShuffledInputProviderBuilder);exports.InGPUMemoryShuffledInputProviderBuilder=InGPUMemoryShuffledInputProviderBuilder;},{"../math/ndarray":56,"../util":88}],6:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../math/ndarray");var util=require("../util");var dataset_1=require("./dataset");var PARSING_IMAGE_CANVAS_HEIGHT_PX=1000;function getXhrDatasetConfig(jsonConfigPath){return new Promise(function(resolve,reject){var xhr=new XMLHttpRequest();xhr.open('GET',jsonConfigPath);xhr.onload=function(){resolve(JSON.parse(xhr.responseText));};xhr.onerror=function(error){reject(error);};xhr.send();});}exports.getXhrDatasetConfig=getXhrDatasetConfig;var XhrDataset=function(_super){__extends(XhrDataset,_super);function XhrDataset(xhrDatasetConfig){var _this=_super.call(this,xhrDatasetConfig.data.map(function(x){return x.shape;}))||this;_this.xhrDatasetConfig=xhrDatasetConfig;return _this;}XhrDataset.prototype.getNDArray=function(info){var dataPromise=info.dataType==='png'?parseTypedArrayFromPng(info,info.shape):parseTypedArrayFromBinary(info);return dataPromise.then(function(data){var inputSize=util.sizeFromShape(info.shape);var ndarrays=[];for(var i=0;i<data.length/inputSize;i++){var values=data.subarray(i*inputSize,(i+1)*inputSize);var ndarray=ndarray_1.NDArray.make(info.shape,{values:new Float32Array(values)});ndarrays.push(ndarray);}return ndarrays;});};XhrDataset.prototype.fetchData=function(){var _this=this;return new Promise(function(resolve,reject){var promises=_this.xhrDatasetConfig.data.map(function(x){return _this.getNDArray(x);});Promise.all(promises).then(function(data){_this.dataset=data;resolve();});});};return XhrDataset;}(dataset_1.InMemoryDataset);exports.XhrDataset=XhrDataset;function parseTypedArrayFromBinary(info){return new Promise(function(resolve,reject){var xhr=new XMLHttpRequest();xhr.open('GET',info.path);xhr.responseType='arraybuffer';xhr.onload=function(event){var data=info.dataType==='float32'?new Float32Array(xhr.response):new Uint8Array(xhr.response);resolve(data);};xhr.onerror=function(err){return reject(err);};xhr.send();});}function parseGrayscaleImageData(data,result,resultOffset){var idx=resultOffset;for(var i=0;i<data.length;i+=4){result[idx++]=data[i];}}function parseRGBImageData(data,result,resultOffset){var idx=resultOffset;for(var i=0;i<data.length;i+=4){result[idx]=data[i];result[idx+1]=data[i+1];result[idx+2]=data[i+2];idx+=3;}}function parseImage(img,shape){var canvas=document.createElement('canvas');var ctx=canvas.getContext('2d');var N=img.height;var inputSize=util.sizeFromShape(shape);var result=new Uint8Array(N*inputSize);if(img.width!==shape[0]*shape[1]){throw new Error("Image width ("+img.width+") must be multiple of "+("rows*columns ("+shape[0]+"*"+shape[1]+") of the ndarray"));}canvas.width=img.width;canvas.height=PARSING_IMAGE_CANVAS_HEIGHT_PX;var sx=0;var sWidth=canvas.width;var sHeight=canvas.height;var dx=0;var dy=0;var dWidth=sWidth;var dHeight=sHeight;var depth=shape[2];var offset=0;var numPasses=Math.ceil(N/canvas.height);for(var pass=0;pass<numPasses;++pass){var sy=pass*canvas.height;if(pass===numPasses-1&&N%canvas.height>0){canvas.height=N%canvas.height;sHeight=canvas.height;dHeight=sHeight;}ctx.drawImage(img,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight);var data=ctx.getImageData(0,0,canvas.width,canvas.height).data;depth===1?parseGrayscaleImageData(data,result,offset):parseRGBImageData(data,result,offset);offset+=canvas.height*inputSize;}return result;}function parseTypedArrayFromPng(info,shape){return new Promise(function(resolve,reject){var img=new Image();img.setAttribute('crossOrigin','');img.onload=function(){var result=parseImage(img,shape);img.src='';img=null;resolve(result);};img.src=info.path;});}},{"../math/ndarray":56,"../util":88,"./dataset":4}],7:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function isMobile(){var a=navigator.userAgent||navigator.vendor||window.opera;return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4));}exports.isMobile=isMobile;},{}],8:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var device_util=require("./device_util");var util=require("./util");var Type;(function(Type){Type[Type["NUMBER"]=0]="NUMBER";Type[Type["BOOLEAN"]=1]="BOOLEAN";})(Type=exports.Type||(exports.Type={}));exports.URL_PROPERTIES=[{name:'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED',type:Type.BOOLEAN},{name:'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE',type:Type.BOOLEAN},{name:'WEBGL_VERSION',type:Type.NUMBER},{name:'WEBGL_FLOAT_TEXTURE_ENABLED',type:Type.BOOLEAN},{name:'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED',type:Type.BOOLEAN}];function getWebGLRenderingContext(webGLVersion){if(webGLVersion===0){throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');}var tempCanvas=document.createElement('canvas');if(webGLVersion===1){return tempCanvas.getContext('webgl')||tempCanvas.getContext('experimental-webgl');}return tempCanvas.getContext('webgl2');}function loseContext(gl){if(gl!=null){var loseContextExtension=gl.getExtension('WEBGL_lose_context');if(loseContextExtension==null){throw new Error('Extension WEBGL_lose_context not supported on this browser.');}loseContextExtension.loseContext();}}function isWebGLVersionEnabled(webGLVersion){var gl=getWebGLRenderingContext(webGLVersion);if(gl!=null){loseContext(gl);return true;}return false;}function isWebGLDisjointQueryTimerEnabled(webGLVersion){var gl=getWebGLRenderingContext(webGLVersion);var extensionName=webGLVersion===1?'EXT_disjoint_timer_query':'EXT_disjoint_timer_query_webgl2';var ext=gl.getExtension(extensionName);var isExtEnabled=ext!=null;if(gl!=null){loseContext(gl);}return isExtEnabled;}function isFloatTextureReadPixelsEnabled(webGLVersion){if(webGLVersion===0){return false;}var gl=getWebGLRenderingContext(webGLVersion);if(webGLVersion===1){if(gl.getExtension('OES_texture_float')==null){return false;}}else{if(gl.getExtension('EXT_color_buffer_float')==null){return false;}}var frameBuffer=gl.createFramebuffer();var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);var internalFormat=webGLVersion===2?gl.RGBA32F:gl.RGBA;gl.texImage2D(gl.TEXTURE_2D,0,internalFormat,1,1,0,gl.RGBA,gl.FLOAT,null);gl.bindFramebuffer(gl.FRAMEBUFFER,frameBuffer);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);var frameBufferComplete=gl.checkFramebufferStatus(gl.FRAMEBUFFER)===gl.FRAMEBUFFER_COMPLETE;loseContext(gl);return frameBufferComplete;}function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion){if(webGLVersion!==2){return false;}var gl=getWebGLRenderingContext(webGLVersion);var ext=gl.getExtension('WEBGL_get_buffer_sub_data_async');var isEnabled=ext!=null;loseContext(gl);return isEnabled;}var Environment=function(){function Environment(features){this.features={};if(features!=null){this.features=features;}}Environment.prototype.get=function(feature){if(feature in this.features){return this.features[feature];}this.features[feature]=this.evaluateFeature(feature);return this.features[feature];};Environment.prototype.evaluateFeature=function(feature){if(feature==='WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED'){var webGLVersion=this.get('WEBGL_VERSION');if(webGLVersion===0){return false;}return isWebGLDisjointQueryTimerEnabled(webGLVersion);}else if(feature==='WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE'){return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED')&&!device_util.isMobile();}else if(feature==='WEBGL_VERSION'){if(isWebGLVersionEnabled(2)){return 2;}else if(isWebGLVersionEnabled(1)){return 1;}return 0;}else if(feature==='WEBGL_FLOAT_TEXTURE_ENABLED'){return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));}else if(feature==='WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED'){return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get('WEBGL_VERSION'));}throw new Error("Unknown feature "+feature+".");};return Environment;}();exports.Environment=Environment;var DEEPLEARNJS_FLAGS_PREFIX='dljsflags';function getFeaturesFromURL(){var features={};if(typeof window==='undefined'){return features;}var urlParams=util.getQueryParams(window.location.search);if(DEEPLEARNJS_FLAGS_PREFIX in urlParams){var urlFlags_1={};var keyValues=urlParams[DEEPLEARNJS_FLAGS_PREFIX].split(',');keyValues.forEach(function(keyValue){var _a=keyValue.split(':'),key=_a[0],value=_a[1];urlFlags_1[key]=value;});exports.URL_PROPERTIES.forEach(function(urlProperty){if(urlProperty.name in urlFlags_1){console.log("Setting feature override from URL "+urlProperty.name+": "+(""+urlFlags_1[urlProperty.name]));if(urlProperty.type===Type.NUMBER){features[urlProperty.name]=+urlFlags_1[urlProperty.name];}else if(urlProperty.type===Type.BOOLEAN){features[urlProperty.name]=urlFlags_1[urlProperty.name]==='true';}else{console.warn("Unknown URL param: "+urlProperty.name+".");}}});}return features;}exports.ENV=new Environment(getFeaturesFromURL());function setEnvironment(environment){exports.ENV=environment;}exports.setEnvironment=setEnvironment;},{"./device_util":7,"./util":88}],9:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var initializers_1=require("../initializers");var concat_util=require("../math/concat_util");var conv_util=require("../math/conv_util");var ndarray_1=require("../math/ndarray");var util=require("../util");var GraphLayers=function(){function GraphLayers(g){this.g=g;}GraphLayers.prototype.dense=function(name,x,units,activation,useBias,kernelInitializer,biasInitializer){if(activation===void 0){activation=null;}if(useBias===void 0){useBias=true;}if(kernelInitializer===void 0){kernelInitializer=new initializers_1.VarianceScalingInitializer();}if(biasInitializer===void 0){biasInitializer=new initializers_1.ZerosInitializer();}var weights=this.g.variable(name+'-weights',kernelInitializer.initialize([x.shape[0],units],x.shape[0],units));var out=this.g.matmul(x,weights);if(useBias){var bias=this.g.variable(name+'-bias',biasInitializer.initialize([units],x.shape[0],units));out=this.g.add(out,bias);}if(activation!=null){out=activation(out);}return out;};return GraphLayers;}();exports.GraphLayers=GraphLayers;var Graph=function(){function Graph(){this.nodes=[];this.layers=new GraphLayers(this);}Graph.prototype.variable=function(name,data){return this.addNodeAndReturnOutput(new VariableNode(this,name,data));};Graph.prototype.placeholder=function(name,shape){return this.addNodeAndReturnOutput(new PlaceholderNode(this,name,shape));};Graph.prototype.constant=function(value){var finalValue;if(typeof value==='number'){finalValue=ndarray_1.Scalar.new(value);}else if(value instanceof ndarray_1.NDArray){finalValue=value;}else if(value instanceof Array){var flatValues=util.flatten(value);var vals=new Float32Array(flatValues);finalValue=ndarray_1.NDArray.make(util.inferShape(value),{values:vals});}else{throw new Error('unimplemented constant type.');}return this.addNodeAndReturnOutput(new ConstantNode(this,finalValue));};Graph.prototype.reshape=function(x,shape){return this.addNodeAndReturnOutput(new ReshapeNode(this,'Reshape',x,shape));};Graph.prototype.fusedLinearCombination=function(x1,x2,c1,c2){return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this,x1,x2,c1,c2));};Graph.prototype.add=function(x1,x2){return this.addNodeAndReturnOutput(new AddNode(this,x1,x2));};Graph.prototype.subtract=function(x1,x2){return this.addNodeAndReturnOutput(new SubtractNode(this,x1,x2));};Graph.prototype.multiply=function(x1,x2){return this.addNodeAndReturnOutput(new MultiplyNode(this,x1,x2));};Graph.prototype.divide=function(x1,x2){return this.addNodeAndReturnOutput(new DivideNode(this,x1,x2));};Graph.prototype.reduceSum=function(x){return this.addNodeAndReturnOutput(new ReduceSumNode(this,x));};Graph.prototype.concat3d=function(x1,x2,axis){return this.addNodeAndReturnOutput(new Concat3DNode(this,x1,x2,axis));};Graph.prototype.matmul=function(x1,x2){return this.addNodeAndReturnOutput(new MatMulNode(this,x1,x2));};Graph.prototype.conv2d=function(x,w,b,fieldSize,outputDepth,stride,zeroPad){if(stride===void 0){stride=1;}return this.addNodeAndReturnOutput(new Convolution2DNode(this,x,w,b,fieldSize,outputDepth,stride,zeroPad));};Graph.prototype.maxPool=function(x,fieldSize,stride,zeroPad){if(stride===void 0){stride=1;}return this.addNodeAndReturnOutput(new MaxPoolNode(this,x,fieldSize,stride,zeroPad));};Graph.prototype.exp=function(x){return this.addNodeAndReturnOutput(new ExpNode(this,x));};Graph.prototype.log=function(x){return this.addNodeAndReturnOutput(new LogNode(this,x));};Graph.prototype.relu=function(x){return this.addNodeAndReturnOutput(new ReLUNode(this,x));};Graph.prototype.tanh=function(x){return this.addNodeAndReturnOutput(new TanHNode(this,x));};Graph.prototype.sigmoid=function(x){return this.addNodeAndReturnOutput(new SigmoidNode(this,x));};Graph.prototype.square=function(x){return this.addNodeAndReturnOutput(new SquareNode(this,x));};Graph.prototype.softmax=function(x){return this.addNodeAndReturnOutput(new SoftmaxNode(this,x));};Graph.prototype.softmaxCrossEntropyCost=function(x,target){return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this,x,target));};Graph.prototype.meanSquaredCost=function(label,prediction){return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this,label,prediction));};Graph.prototype.argmax=function(x){return this.addNodeAndReturnOutput(new ArgMaxNode(this,x));};Graph.prototype.argmaxEquals=function(x1,x2){return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this,x1,x2));};Graph.prototype.addNodeAndReturnOutput=function(node){this.nodes.push(node);node.validate();return node.output;};Graph.prototype.getNodes=function(){return this.nodes;};return Graph;}();exports.Graph=Graph;var Tensor=function(){function Tensor(shape){this.shape=shape;this.id=Tensor.nextID++;}Tensor.nextID=0;return Tensor;}();exports.Tensor=Tensor;var Node=function(){function Node(graph,name,inputs,output){this.graph=graph;this.name=name;this.inputs=inputs;this.output=output;this.id=Node.nextID++;output.node=this;}Node.nextID=0;return Node;}();exports.Node=Node;var VariableNode=function(_super){__extends(VariableNode,_super);function VariableNode(graph,name,data){var _this=_super.call(this,graph,name,{},new Tensor(data.shape))||this;_this.data=data;return _this;}VariableNode.prototype.validate=function(){util.assert(this.data!=null,'Error adding variable op: Data for variable \''+this.name+'\' is null or undefined');};return VariableNode;}(Node);exports.VariableNode=VariableNode;var PlaceholderNode=function(_super){__extends(PlaceholderNode,_super);function PlaceholderNode(graph,name,shape){return _super.call(this,graph,name,{},new Tensor(shape))||this;}PlaceholderNode.prototype.validate=function(){};return PlaceholderNode;}(Node);exports.PlaceholderNode=PlaceholderNode;var ConstantNode=function(_super){__extends(ConstantNode,_super);function ConstantNode(graph,data){var _this=_super.call(this,graph,'Constant',{},new Tensor(data.shape))||this;_this.data=data;return _this;}ConstantNode.prototype.validate=function(){util.assert(this.data!=null,'Error adding constant: data for placeholder \''+this.name+'\' is null or undefined');};return ConstantNode;}(Node);exports.ConstantNode=ConstantNode;var ReshapeNode=function(_super){__extends(ReshapeNode,_super);function ReshapeNode(graph,name,x,shape){var _this=_super.call(this,graph,name,{x:x},new Tensor(shape))||this;_this.name=name;_this.x=x;_this.shape=shape;return _this;}ReshapeNode.prototype.validate=function(){var xSize=util.sizeFromShape(this.x.shape);var shapeSize=util.sizeFromShape(this.shape);util.assert(xSize===shapeSize,"Error making reshape operation: input to reshape '"+this.name+"'"+(" of shape ("+this.x.shape+") does not match size of ")+("requested shape "+this.shape+"."));};ReshapeNode.X='x';return ReshapeNode;}(Node);exports.ReshapeNode=ReshapeNode;var FusedLinearCombinationNode=function(_super){__extends(FusedLinearCombinationNode,_super);function FusedLinearCombinationNode(graph,t1,t2,c1,c2){var _this=_super.call(this,graph,'Linear Combination',{t1:t1,t2:t2,c1:c1,c2:c2},new Tensor(t1.shape))||this;_this.t1=t1;_this.t2=t2;_this.c1=c1;_this.c2=c2;return _this;}FusedLinearCombinationNode.prototype.validate=function(){util.assertShapesMatch(this.t1.shape,this.t2.shape);if(!util.isScalarShape(this.c1.shape)){throw new Error('Error adding fusedLinearCombination: c1 is not a scalar, got '+("shape: "+this.c1.shape));}if(!util.isScalarShape(this.c2.shape)){throw new Error('Error adding fusedLinearCombination: c2 is not a scalar, got '+("shape: "+this.c2.shape));}};FusedLinearCombinationNode.T1='t1';FusedLinearCombinationNode.T2='t2';FusedLinearCombinationNode.C1='c1';FusedLinearCombinationNode.C2='c2';return FusedLinearCombinationNode;}(Node);exports.FusedLinearCombinationNode=FusedLinearCombinationNode;var AddNode=function(_super){__extends(AddNode,_super);function AddNode(graph,t1,t2){var _this=_super.call(this,graph,'Add',{t1:t1,t2:t2},new Tensor(util.sizeFromShape(t1.shape)===1?t2.shape:t1.shape))||this;_this.t1=t1;_this.t2=t2;return _this;}AddNode.prototype.validate=function(){util.assert(util.sizeFromShape(this.t1.shape)===1||util.sizeFromShape(this.t2.shape)===1||util.arraysEqual(this.t1.shape,this.t2.shape),'Error adding add operation op: one of inputs must be scalar or the '+("shapes "+this.t1.shape+" and "+this.t2.shape+" must match."));};AddNode.T1='t1';AddNode.T2='t2';return AddNode;}(Node);exports.AddNode=AddNode;var SubtractNode=function(_super){__extends(SubtractNode,_super);function SubtractNode(graph,t1,t2){var _this=_super.call(this,graph,'Subtract',{t1:t1,t2:t2},new Tensor(util.sizeFromShape(t1.shape)===1?t2.shape:t1.shape))||this;_this.t1=t1;_this.t2=t2;return _this;}SubtractNode.prototype.validate=function(){util.assert(util.sizeFromShape(this.t1.shape)===1||util.sizeFromShape(this.t2.shape)===1||util.arraysEqual(this.t1.shape,this.t2.shape),'Error adding subtract op: one of inputs must be scalar or the '+("shapes "+this.t1.shape+" and "+this.t2.shape+" must match."));};SubtractNode.T1='t1';SubtractNode.T2='t2';return SubtractNode;}(Node);exports.SubtractNode=SubtractNode;var MultiplyNode=function(_super){__extends(MultiplyNode,_super);function MultiplyNode(graph,t1,t2){var _this=_super.call(this,graph,'Multiply',{t1:t1,t2:t2},new Tensor(util.sizeFromShape(t1.shape)===1?t2.shape:t1.shape))||this;_this.t1=t1;_this.t2=t2;return _this;}MultiplyNode.prototype.validate=function(){util.assert(util.sizeFromShape(this.t1.shape)===1||util.sizeFromShape(this.t2.shape)===1||util.arraysEqual(this.t1.shape,this.t2.shape),'Error adding multiply op: one of inputs must be scalar or the '+("shapes "+this.t1.shape+" and "+this.t2.shape+" must match."));};MultiplyNode.T1='t1';MultiplyNode.T2='t2';return MultiplyNode;}(Node);exports.MultiplyNode=MultiplyNode;var DivideNode=function(_super){__extends(DivideNode,_super);function DivideNode(graph,t1,t2){var _this=_super.call(this,graph,'Divide',{t1:t1,t2:t2},new Tensor(util.sizeFromShape(t1.shape)===1?t2.shape:t1.shape))||this;_this.t1=t1;_this.t2=t2;return _this;}DivideNode.prototype.validate=function(){util.assert(util.sizeFromShape(this.t1.shape)===1||util.sizeFromShape(this.t2.shape)===1||util.arraysEqual(this.t1.shape,this.t2.shape),'Error adding divide op: one of inputs must be scalar or the '+("shapes "+this.t1.shape+" and "+this.t2.shape+" must match."));};DivideNode.T1='t1';DivideNode.T2='t2';return DivideNode;}(Node);exports.DivideNode=DivideNode;var ReduceSumNode=function(_super){__extends(ReduceSumNode,_super);function ReduceSumNode(graph,x){return _super.call(this,graph,'ReduceSum',{x:x},new Tensor([]))||this;}ReduceSumNode.prototype.validate=function(){};ReduceSumNode.X='x';return ReduceSumNode;}(Node);exports.ReduceSumNode=ReduceSumNode;var Concat3DNode=function(_super){__extends(Concat3DNode,_super);function Concat3DNode(graph,x1,x2,axis){var _this=_super.call(this,graph,'Concat3D',{x1:x1,x2:x2},new Tensor(concat_util.computeOutShape(x1.shape,x2.shape,axis)))||this;_this.x1=x1;_this.x2=x2;_this.axis=axis;return _this;}Concat3DNode.prototype.validate=function(){concat_util.assertParams(this.x1.shape,this.x2.shape,this.axis);};Concat3DNode.X1='x1';Concat3DNode.X2='x2';Concat3DNode.AXIS='axis';return Concat3DNode;}(Node);exports.Concat3DNode=Concat3DNode;function getMatMulOutputShape(x1Shape,x2Shape){if(x1Shape.length===1&&x2Shape.length===1){return[1];}else if(x1Shape.length===1&&x2Shape.length===2){return[x2Shape[1]];}else if(x1Shape.length===2&&x2Shape.length===1){return[x1Shape[0]];}return[x1Shape[0],x2Shape[1]];}var MatMulNode=function(_super){__extends(MatMulNode,_super);function MatMulNode(graph,x1,x2){var _this=_super.call(this,graph,'MatMul',{x1:x1,x2:x2},new Tensor(getMatMulOutputShape(x1.shape,x2.shape)))||this;_this.x1=x1;_this.x2=x2;return _this;}MatMulNode.prototype.validate=function(){if(this.x1.shape.length===2&&this.x2.shape.length===2){util.assert(this.x1.shape[1]===this.x2.shape[0],'Error adding matmul op: inner shapes of matrices with shapes '+(this.x1.shape+" and "+this.x2.shape+" must match."));}else if(this.x1.shape.length===2&&this.x2.shape.length===1){util.assert(this.x1.shape[1]===this.x2.shape[0],'Error adding matmul op: second dimension of matrix with shape '+this.x1.shape.toString()+(" must match size of vector with shape "+this.x2.shape+"."));}else if(this.x1.shape.length===1&&this.x2.shape.length===2){util.assert(this.x1.shape[0]===this.x2.shape[0],"Error adding matmul op: size of vector with shape "+this.x1.shape+" must match first dimension of matrix with "+("shape "+this.x2.shape+"."));}else{throw new Error('Error adding matmul op: inputs must be vectors or matrices.');}};MatMulNode.X1='x1';MatMulNode.X2='x2';return MatMulNode;}(Node);exports.MatMulNode=MatMulNode;var Convolution2DNode=function(_super){__extends(Convolution2DNode,_super);function Convolution2DNode(graph,x,w,b,fieldSize,outputDepth,stride,zeroPad){if(stride===void 0){stride=1;}var _this=_super.call(this,graph,'Convolution 2D',{x:x,w:w,b:b},new Tensor(conv_util.computeOutputShape3D(x.shape,fieldSize,outputDepth,stride,zeroPad)))||this;_this.x=x;_this.w=w;_this.b=b;_this.fieldSize=fieldSize;_this.outputDepth=outputDepth;_this.stride=stride;_this.zeroPad=zeroPad;return _this;}Convolution2DNode.prototype.validate=function(){util.assert(this.x.shape.length===3,'Error adding conv2d op: input must be of rank 3, but got shape: '+(this.x.shape+"."));util.assert(this.w.shape.length===4,'Error adding conv2d op: weights must be of rank 4, but got shape: '+(this.w.shape+"."));util.assert(this.b.shape.length===1,'Error adding conv2d op: biases must be of rank 1, but got shape: '+(this.b.shape+"."));util.assert(this.x.shape[2]===this.w.shape[2],"Error adding conv2d op: depth of input ("+this.x.shape[2]+") "+("must match input depth for weights ("+this.w.shape[2]+")."));};Convolution2DNode.X='x';Convolution2DNode.W='w';Convolution2DNode.B='b';return Convolution2DNode;}(Node);exports.Convolution2DNode=Convolution2DNode;var MaxPoolNode=function(_super){__extends(MaxPoolNode,_super);function MaxPoolNode(graph,x,fieldSize,stride,zeroPad){if(stride===void 0){stride=1;}var _this=_super.call(this,graph,'Max pool',{x:x},new Tensor(conv_util.computeOutputShape3D(x.shape,fieldSize,x.shape[2],stride,zeroPad)))||this;_this.x=x;_this.fieldSize=fieldSize;_this.stride=stride;_this.zeroPad=zeroPad;return _this;}MaxPoolNode.prototype.validate=function(){util.assert(this.x.shape.length===3,'Error adding maxPool op: input must be of rank 3, but got shape: '+(this.x.shape+"."));};MaxPoolNode.X='x';return MaxPoolNode;}(Node);exports.MaxPoolNode=MaxPoolNode;var ReLUNode=function(_super){__extends(ReLUNode,_super);function ReLUNode(graph,x){return _super.call(this,graph,'ReLU',{x:x},new Tensor(x.shape))||this;}ReLUNode.prototype.validate=function(){};ReLUNode.X='x';return ReLUNode;}(Node);exports.ReLUNode=ReLUNode;var ExpNode=function(_super){__extends(ExpNode,_super);function ExpNode(graph,x){return _super.call(this,graph,'Exp',{x:x},new Tensor(x.shape))||this;}ExpNode.prototype.validate=function(){};ExpNode.X='x';return ExpNode;}(Node);exports.ExpNode=ExpNode;var LogNode=function(_super){__extends(LogNode,_super);function LogNode(graph,x){return _super.call(this,graph,'Log',{x:x},new Tensor(x.shape))||this;}LogNode.prototype.validate=function(){};LogNode.X='x';return LogNode;}(Node);exports.LogNode=LogNode;var TanHNode=function(_super){__extends(TanHNode,_super);function TanHNode(graph,x){return _super.call(this,graph,'TanH',{x:x},new Tensor(x.shape))||this;}TanHNode.prototype.validate=function(){};TanHNode.X='x';return TanHNode;}(Node);exports.TanHNode=TanHNode;var SigmoidNode=function(_super){__extends(SigmoidNode,_super);function SigmoidNode(graph,x){return _super.call(this,graph,'Sigmoid',{x:x},new Tensor(x.shape))||this;}SigmoidNode.prototype.validate=function(){};SigmoidNode.X='x';return SigmoidNode;}(Node);exports.SigmoidNode=SigmoidNode;var SquareNode=function(_super){__extends(SquareNode,_super);function SquareNode(graph,x){return _super.call(this,graph,'Square',{x:x},new Tensor(x.shape))||this;}SquareNode.prototype.validate=function(){};SquareNode.X='x';return SquareNode;}(Node);exports.SquareNode=SquareNode;var SoftmaxCrossEntropyCostNode=function(_super){__extends(SoftmaxCrossEntropyCostNode,_super);function SoftmaxCrossEntropyCostNode(graph,x,target){var _this=_super.call(this,graph,'SoftmaxCrossEntropyCost',{x:x,target:target},new Tensor([]))||this;_this.x=x;_this.target=target;return _this;}SoftmaxCrossEntropyCostNode.prototype.validate=function(){util.assert(util.arraysEqual(this.x.shape,this.target.shape),"Error adding softmaxCrossEntropyCost op: x shape ("+this.x.shape+") "+("must match target shape ("+this.target.shape+")."));};SoftmaxCrossEntropyCostNode.X='x';SoftmaxCrossEntropyCostNode.TARGET='target';return SoftmaxCrossEntropyCostNode;}(Node);exports.SoftmaxCrossEntropyCostNode=SoftmaxCrossEntropyCostNode;var SoftmaxNode=function(_super){__extends(SoftmaxNode,_super);function SoftmaxNode(graph,x){var _this=_super.call(this,graph,'Softmax',{x:x},new Tensor(x.shape))||this;_this.x=x;return _this;}SoftmaxNode.prototype.validate=function(){util.assert(this.x.shape.length===1,'The input to a softmax must be a 1-D tensor');util.assert(this.x.shape[0]>=2,'The input to a softmax must have at least 2 values');};SoftmaxNode.X='x';return SoftmaxNode;}(Node);exports.SoftmaxNode=SoftmaxNode;var MeanSquaredCostNode=function(_super){__extends(MeanSquaredCostNode,_super);function MeanSquaredCostNode(graph,label,prediction){var _this=_super.call(this,graph,'Mean Squared Cost',{label:label,prediction:prediction},new Tensor([]))||this;_this.label=label;_this.prediction=prediction;return _this;}MeanSquaredCostNode.prototype.validate=function(){util.assert(util.arraysEqual(this.label.shape,this.prediction.shape),"Error adding meanSquaredCost op: label shape ("+this.label.shape+") "+("must match prediction shape ("+this.prediction.shape+")."));};MeanSquaredCostNode.LABEL='label';MeanSquaredCostNode.PREDICTION='prediction';return MeanSquaredCostNode;}(Node);exports.MeanSquaredCostNode=MeanSquaredCostNode;var ArgMaxNode=function(_super){__extends(ArgMaxNode,_super);function ArgMaxNode(graph,x){var _this=_super.call(this,graph,'ArgMax',{x:x},new Tensor([1]))||this;_this.x=x;return _this;}ArgMaxNode.prototype.validate=function(){util.assert(util.sizeFromShape(this.x.shape)>0,'Error adding argmax op: input tensor must have at least one entry.');};ArgMaxNode.X='x';return ArgMaxNode;}(Node);exports.ArgMaxNode=ArgMaxNode;var ArgMaxEqualsNode=function(_super){__extends(ArgMaxEqualsNode,_super);function ArgMaxEqualsNode(graph,x1,x2){var _this=_super.call(this,graph,'ArgMaxEquals',{x1:x1,x2:x2},new Tensor([1]))||this;_this.x1=x1;_this.x2=x2;return _this;}ArgMaxEqualsNode.prototype.validate=function(){util.assert(util.arraysEqual(this.x1.shape,this.x2.shape),"Error adding ArgMaxEquals op: x1 shape ("+this.x1.shape+") "+("must match x2 shape ("+this.x2.shape+")."));};ArgMaxEqualsNode.X1='x1';ArgMaxEqualsNode.X2='x2';return ArgMaxEqualsNode;}(Node);exports.ArgMaxEqualsNode=ArgMaxEqualsNode;},{"../initializers":45,"../math/concat_util":49,"../math/conv_util":50,"../math/ndarray":56,"../util":88}],10:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var graph_1=require("./graph");var priority_queue=require("./priority_queue");var priority_queue_1=require("./priority_queue");function getUnorderedEvaluationSet(nodes,terminatingNodes){var terminatingNodeMap={};var seen={};var set=[];var visit=nodes.slice();terminatingNodes.forEach(function(node){return terminatingNodeMap[node.id]=node;});var _loop_1=function _loop_1(){var cur=visit.pop();if(seen[cur.id]==null){if(terminatingNodeMap[cur.id]==null){Object.keys(cur.inputs).map(function(inputName){return cur.inputs[inputName];}).forEach(function(input){return visit.push(input.node);});}set.push(cur);seen[cur.id]=cur;}};while(visit.length!==0){_loop_1();}return set;}exports.getUnorderedEvaluationSet=getUnorderedEvaluationSet;function getOrderedEvaluationSet(unorderedEvaluationSet){var set=[];var nodeIndices={};var pendingDependencies={};var nodeQueue=new priority_queue_1.PriorityQueue(function(a,b){return priority_queue.defaultCompare(pendingDependencies[a.id],pendingDependencies[b.id]);},function(node,newIndex){return nodeIndices[node.id]=newIndex;});unorderedEvaluationSet.forEach(function(node){return pendingDependencies[node.id]=0;});unorderedEvaluationSet.forEach(function(node){return Object.keys(node.inputs).map(function(key){return node.inputs[key];}).forEach(function(input){if(unorderedEvaluationSet.indexOf(input.node)!==-1){pendingDependencies[input.node.id]++;}});});unorderedEvaluationSet.forEach(function(node){return nodeQueue.enqueue(node);});while(!nodeQueue.empty()){set.unshift(nodeQueue.dequeue());Object.keys(set[0].inputs).map(function(key){return set[0].inputs[key];}).forEach(function(input){if(unorderedEvaluationSet.indexOf(input.node)===-1){return;}pendingDependencies[input.node.id]--;nodeQueue.update(input.node,nodeIndices[input.node.id]);});}return set;}exports.getOrderedEvaluationSet=getOrderedEvaluationSet;function isInputNode(node){return Object.keys(node.inputs).length===0;}exports.isInputNode=isInputNode;function shouldBackProp(t){return!(t.node instanceof graph_1.ConstantNode);}exports.shouldBackProp=shouldBackProp;function isPassthroughNode(node,map){var keys=Object.keys(node.inputs);for(var i=0;i<keys.length;i++){var input=node.inputs[keys[i]];if(map.get(input,true)===map.get(node.output,true)){return true;}}return false;}exports.isPassthroughNode=isPassthroughNode;},{"./graph":9,"./priority_queue":39}],11:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var graph_1=require("./graph");var graph_util=require("./graph_util");var add_1=require("./ops/add");var argmax_1=require("./ops/argmax");var argmaxequals_1=require("./ops/argmaxequals");var concat3d_1=require("./ops/concat3d");var convolution_1=require("./ops/convolution");var divide_1=require("./ops/divide");var element_wise_activation_1=require("./ops/element_wise_activation");var element_wise_cost_1=require("./ops/element_wise_cost");var exp_1=require("./ops/exp");var linear_combination_1=require("./ops/linear_combination");var log_1=require("./ops/log");var matmul_1=require("./ops/matmul");var max_pool_1=require("./ops/max_pool");var multiply_1=require("./ops/multiply");var reduce_sum_1=require("./ops/reduce_sum");var reshape_1=require("./ops/reshape");var softmax_1=require("./ops/softmax");var subtract_1=require("./ops/subtract");function emitFromGraphNodes(nodes){var ops=[];nodes.forEach(function(node){return Array.prototype.push.apply(ops,emitOpFromNode(node));});return ops;}exports.emitFromGraphNodes=emitFromGraphNodes;function emitOpFromNode(node){if(node instanceof graph_1.ReshapeNode){return[new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X],node.output)];}else if(node instanceof graph_1.MatMulNode){var x1=node.inputs[graph_1.MatMulNode.X1];var x2=node.inputs[graph_1.MatMulNode.X2];return[new matmul_1.MatMul(x1,x2,node.output)];}else if(node instanceof graph_1.Convolution2DNode){var w=node.inputs[graph_1.Convolution2DNode.W];var x=node.inputs[graph_1.Convolution2DNode.X];var b=node.inputs[graph_1.Convolution2DNode.B];return[new convolution_1.Convolution2D(w,x,b,node.output,node.fieldSize,node.outputDepth,node.stride,node.zeroPad)];}else if(node instanceof graph_1.MaxPoolNode){var x=node.inputs[graph_1.MaxPoolNode.X];return[new max_pool_1.MaxPool(x,node.output,node.fieldSize,node.stride,node.zeroPad)];}else if(node instanceof graph_1.ExpNode){return[new exp_1.Exp(node.inputs[graph_1.ExpNode.X],node.output)];}else if(node instanceof graph_1.LogNode){return[new log_1.Log(node.inputs[graph_1.LogNode.X],node.output)];}else if(node instanceof graph_1.ReLUNode){return[new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X],node.output)];}else if(node instanceof graph_1.TanHNode){return[new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X],node.output)];}else if(node instanceof graph_1.SigmoidNode){return[new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X],node.output)];}else if(node instanceof graph_1.SoftmaxCrossEntropyCostNode){var x=node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];var target=node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];return[new softmax_1.SoftmaxCrossEntropyCost(x,target,node.output)];}else if(node instanceof graph_1.SoftmaxNode){return[new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X],node.output)];}else if(node instanceof graph_1.MeanSquaredCostNode){var label=node.inputs[graph_1.MeanSquaredCostNode.LABEL];var prediction=node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];return[new element_wise_cost_1.MeanSquaredCost(label,prediction,node.output)];}else if(node instanceof graph_1.ArgMaxEqualsNode){return[new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1],node.inputs[graph_1.ArgMaxEqualsNode.X2],node.output)];}else if(node instanceof graph_1.ArgMaxNode){return[new argmax_1.ArgMax(node.x,node.output)];}else if(node instanceof graph_1.FusedLinearCombinationNode){return[new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1],node.inputs[graph_1.FusedLinearCombinationNode.T2],node.inputs[graph_1.FusedLinearCombinationNode.C1],node.inputs[graph_1.FusedLinearCombinationNode.C2],node.output)];}else if(node instanceof graph_1.Concat3DNode){return[new concat3d_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1],node.inputs[graph_1.Concat3DNode.X2],node.axis,node.output)];}else if(node instanceof graph_1.SquareNode){return[new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X],node.output)];}else if(node instanceof graph_1.AddNode){return[new add_1.Add(node.inputs[graph_1.AddNode.T1],node.inputs[graph_1.AddNode.T2],node.output)];}else if(node instanceof graph_1.SubtractNode){return[new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1],node.inputs[graph_1.SubtractNode.T2],node.output)];}else if(node instanceof graph_1.MultiplyNode){return[new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1],node.inputs[graph_1.MultiplyNode.T2],node.output)];}else if(node instanceof graph_1.DivideNode){return[new divide_1.Divide(node.inputs[graph_1.DivideNode.T1],node.inputs[graph_1.DivideNode.T2],node.output)];}else if(node instanceof graph_1.ReduceSumNode){return[new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X],node.output)];}else if(graph_util.isInputNode(node)){return[];}else{throw Error("Unsupported node type: "+node.constructor.name);}}},{"./graph":9,"./graph_util":10,"./ops/add":12,"./ops/argmax":13,"./ops/argmaxequals":14,"./ops/concat3d":15,"./ops/convolution":16,"./ops/divide":17,"./ops/element_wise_activation":18,"./ops/element_wise_cost":19,"./ops/exp":20,"./ops/linear_combination":21,"./ops/log":22,"./ops/matmul":23,"./ops/max_pool":24,"./ops/multiply":25,"./ops/reduce_sum":27,"./ops/reshape":28,"./ops/softmax":29,"./ops/subtract":30}],12:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var util=require("../../util");var graph_util=require("../graph_util");var op_1=require("./op");var Add=function(_super){__extends(Add,_super);function Add(x1Tensor,x2Tensor,yTensor){var _this=_super.call(this)||this;_this.x1Tensor=x1Tensor;_this.x2Tensor=x2Tensor;_this.yTensor=yTensor;util.assert(util.sizeFromShape(x1Tensor.shape)===1||util.sizeFromShape(x2Tensor.shape)===1||util.arraysEqual(x1Tensor.shape,x2Tensor.shape),'One of t1 or t2 must be a scalar, or t1 and t2 must have '+'the same shape');return _this;}Add.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);math.scope(function(keep){var result;if(util.isScalarShape(x1.shape)){result=math.scalarPlusArray(x1,x2);}else if(util.isScalarShape(x2.shape)){result=math.scalarPlusArray(x2,x1);}else{result=math.add(x1,x2);}inferenceArrays.set(_this.yTensor,keep(result));});};Add.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var dy=gradientArrays.get(this.yTensor);math.scope(function(){if(graph_util.shouldBackProp(_this.x1Tensor)){if(util.isScalarShape(_this.x1Tensor.shape)){var sum=math.sum(dy);if(_this.dySizeScalar==null){_this.dySizeScalar=ndarray_1.Scalar.new(dy.size);}gradientArrays.add(_this.x1Tensor,math.divide(sum,_this.dySizeScalar));}else{gradientArrays.add(_this.x1Tensor,math.clone(dy));}}if(graph_util.shouldBackProp(_this.x2Tensor)){if(util.isScalarShape(_this.x2Tensor.shape)){var sum=math.sum(dy);if(_this.dySizeScalar==null){_this.dySizeScalar=ndarray_1.Scalar.new(dy.size);}gradientArrays.add(_this.x2Tensor,math.divide(sum,_this.dySizeScalar));}else{gradientArrays.add(_this.x2Tensor,math.clone(dy));}}});};Add.prototype.dispose=function(){if(this.dySizeScalar!=null){this.dySizeScalar.dispose();}};return Add;}(op_1.Operation);exports.Add=Add;},{"../../math/ndarray":56,"../../util":88,"../graph_util":10,"./op":26}],13:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var op_1=require("./op");var ArgMax=function(_super){__extends(ArgMax,_super);function ArgMax(xTensor,yTensor){var _this=_super.call(this)||this;_this.xTensor=xTensor;_this.yTensor=yTensor;return _this;}ArgMax.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x=inferenceArrays.get(this.xTensor);math.scope(function(keep){inferenceArrays.set(_this.yTensor,keep(math.argMax(x)));});};ArgMax.prototype.backProp=function(math,inferenceArrays,gradientArrays){throw new Error('ArgMax backprop unimplemented');};return ArgMax;}(op_1.Operation);exports.ArgMax=ArgMax;},{"./op":26}],14:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var op_1=require("./op");var ArgMaxEquals=function(_super){__extends(ArgMaxEquals,_super);function ArgMaxEquals(x1Tensor,x2Tensor,yTensor){var _this=_super.call(this)||this;_this.x1Tensor=x1Tensor;_this.x2Tensor=x2Tensor;_this.yTensor=yTensor;return _this;}ArgMaxEquals.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);math.scope(function(keep){inferenceArrays.set(_this.yTensor,keep(math.argMaxEquals(x1,x2)));});};ArgMaxEquals.prototype.backProp=function(math,inferenceArrays,gradientArrays){throw new Error('ArgMaxEquals backprop unimplemented');};return ArgMaxEquals;}(op_1.Operation);exports.ArgMaxEquals=ArgMaxEquals;},{"./op":26}],15:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var concat_util=require("../../math/concat_util");var op_1=require("./op");var Concat3D=function(_super){__extends(Concat3D,_super);function Concat3D(x1Tensor,x2Tensor,axis,yTensor){var _this=_super.call(this)||this;_this.x1Tensor=x1Tensor;_this.x2Tensor=x2Tensor;_this.axis=axis;_this.yTensor=yTensor;concat_util.assertParams(x1Tensor.shape,x2Tensor.shape,axis);return _this;}Concat3D.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);math.scope(function(keep){var concatResult=math.concat3D(x1,x2,_this.axis);inferenceArrays.set(_this.yTensor,keep(concatResult));});};Concat3D.prototype.backProp=function(math,inferenceArrays,gradientArrays){throw new Error('Concat3D backprop not implemented.');};return Concat3D;}(op_1.Operation);exports.Concat3D=Concat3D;},{"../../math/concat_util":49,"./op":26}],16:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var conv_util=require("../../math/conv_util");var util=require("../../util");var op_1=require("./op");var Convolution2D=function(_super){__extends(Convolution2D,_super);function Convolution2D(wTensor,xTensor,bTensor,yTensor,fieldSize,outputDepth,stride,zeroPad){if(stride===void 0){stride=1;}var _this=_super.call(this)||this;_this.wTensor=wTensor;_this.xTensor=xTensor;_this.bTensor=bTensor;_this.yTensor=yTensor;_this.fieldSize=fieldSize;_this.outputDepth=outputDepth;_this.stride=stride;_this.assertWeightsShape(wTensor.shape);_this.zeroPad=zeroPad!=null?zeroPad:conv_util.computeDefaultPad(_this.xTensor.shape,_this.fieldSize,_this.stride);util.assert(util.isInt(_this.zeroPad),"The zero padding ("+_this.zeroPad+") must be an integer. Change the "+"stride and/or zero pad parameters");return _this;}Convolution2D.prototype.feedForward=function(math,inferenceArrays){var _this=this;var weights=inferenceArrays.get(this.wTensor);var biases=inferenceArrays.get(this.bTensor);var x=inferenceArrays.get(this.xTensor);math.scope(function(keep){inferenceArrays.set(_this.yTensor,keep(math.conv2d(x,weights,biases,_this.stride,_this.zeroPad)));});};Convolution2D.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var weights=inferenceArrays.get(this.wTensor);var x=inferenceArrays.get(this.xTensor);var dy=gradientArrays.get(this.yTensor);math.scope(function(){var _a=math.conv2dBackProp(x,dy,weights,_this.stride,_this.zeroPad),dw=_a.dw,db=_a.db,dx=_a.dx;gradientArrays.add(_this.wTensor,dw);gradientArrays.add(_this.bTensor,db);gradientArrays.add(_this.xTensor,dx);});};Convolution2D.prototype.assertWeightsShape=function(weightsShape){util.assert(weightsShape[0]===this.fieldSize&&weightsShape[1]===this.fieldSize&&weightsShape[2]===this.xTensor.shape[2]&&weightsShape[3]===this.outputDepth,"weights must be of shape ["+this.fieldSize+","+this.fieldSize+","+(this.xTensor.shape[2]+","+this.outputDepth+"] but they are of")+("shape ["+weightsShape+"]"));};return Convolution2D;}(op_1.Operation);exports.Convolution2D=Convolution2D;},{"../../math/conv_util":50,"../../util":88,"./op":26}],17:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var util=require("../../util");var graph_util=require("../graph_util");var op_1=require("./op");var Divide=function(_super){__extends(Divide,_super);function Divide(x1Tensor,x2Tensor,yTensor){var _this=_super.call(this)||this;_this.x1Tensor=x1Tensor;_this.x2Tensor=x2Tensor;_this.yTensor=yTensor;util.assert(util.sizeFromShape(x1Tensor.shape)===1||util.sizeFromShape(x2Tensor.shape)===1||util.arraysEqual(x1Tensor.shape,x2Tensor.shape),'One of t1 or t2 must be a scalar, or t1 and t2 must have '+'the same shape');return _this;}Divide.prototype.feedForward=function(math,inferenceArrays){var _this=this;var t1=inferenceArrays.get(this.x1Tensor);var t2=inferenceArrays.get(this.x2Tensor);math.scope(function(keep){var result;if(util.isScalarShape(t1.shape)){result=math.scalarDividedByArray(t1,t2);}else if(util.isScalarShape(t2.shape)){result=math.arrayDividedByScalar(t1,t2);}else{result=math.divide(t1,t2);}inferenceArrays.set(_this.yTensor,keep(result));});};Divide.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);var dy=gradientArrays.get(this.yTensor);var x1IsScalar=util.isScalarShape(x1.shape);var x2IsScalar=util.isScalarShape(x2.shape);math.scope(function(){if(graph_util.shouldBackProp(_this.x1Tensor)){if(x1IsScalar){var div=math.divide(dy,x2);gradientArrays.add(_this.x1Tensor,math.sum(div));div.dispose();}else if(x2IsScalar){gradientArrays.add(_this.x1Tensor,math.arrayDividedByScalar(dy,x2));}else{gradientArrays.add(_this.x1Tensor,math.divide(dy,x2));}}if(graph_util.shouldBackProp(_this.x2Tensor)){var x2Squared=math.elementWiseMul(x2,x2);var x1OverX2Squared=void 0;if(x2IsScalar){x1OverX2Squared=math.arrayDividedByScalar(x1,x2Squared);}else if(x1IsScalar){x1OverX2Squared=math.scalarDividedByArray(x1,x2Squared);}else{x1OverX2Squared=math.divide(x1,x2Squared);}var dx2=math.neg(x1OverX2Squared);var dyTimesDerivative=math.elementWiseMul(dy,dx2);if(x2IsScalar){gradientArrays.add(_this.x2Tensor,math.sum(dyTimesDerivative));}else{gradientArrays.add(_this.x2Tensor,dyTimesDerivative);}}});};return Divide;}(op_1.Operation);exports.Divide=Divide;},{"../../util":88,"../graph_util":10,"./op":26}],18:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var activation_functions_1=require("../../math/activation_functions");var op_1=require("./op");var ElementWiseActivation=function(_super){__extends(ElementWiseActivation,_super);function ElementWiseActivation(xTensor,yTensor,func){var _this=_super.call(this)||this;_this.xTensor=xTensor;_this.yTensor=yTensor;_this.func=func;return _this;}ElementWiseActivation.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x=inferenceArrays.get(this.xTensor);math.scope(function(keep){inferenceArrays.set(_this.yTensor,keep(_this.func.output(math,x)));});};ElementWiseActivation.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var x=inferenceArrays.get(this.xTensor);var y=inferenceArrays.get(this.yTensor);var dy=gradientArrays.get(this.yTensor);math.scope(function(){var dydx=_this.func.der(math,x,y);gradientArrays.add(_this.xTensor,math.elementWiseMul(dy,dydx));dydx.dispose();});};return ElementWiseActivation;}(op_1.Operation);exports.ElementWiseActivation=ElementWiseActivation;var ReLU=function(_super){__extends(ReLU,_super);function ReLU(xTensor,yTensor){return _super.call(this,xTensor,yTensor,new activation_functions_1.ReLUFunc())||this;}return ReLU;}(ElementWiseActivation);exports.ReLU=ReLU;var TanH=function(_super){__extends(TanH,_super);function TanH(xTensor,yTensor){return _super.call(this,xTensor,yTensor,new activation_functions_1.TanHFunc())||this;}return TanH;}(ElementWiseActivation);exports.TanH=TanH;var Sigmoid=function(_super){__extends(Sigmoid,_super);function Sigmoid(xTensor,yTensor){return _super.call(this,xTensor,yTensor,new activation_functions_1.SigmoidFunc())||this;}return Sigmoid;}(ElementWiseActivation);exports.Sigmoid=Sigmoid;var Square=function(_super){__extends(Square,_super);function Square(xTensor,yTensor){return _super.call(this,xTensor,yTensor,new activation_functions_1.SquareFunc())||this;}return Square;}(ElementWiseActivation);exports.Square=Square;},{"../../math/activation_functions":46,"./op":26}],19:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var cost_functions_1=require("../../math/cost_functions");var ndarray_1=require("../../math/ndarray");var util=require("../../util");var graph_util=require("../graph_util");var op_1=require("./op");var ElementWiseCost=function(_super){__extends(ElementWiseCost,_super);function ElementWiseCost(x1Tensor,x2Tensor,yTensor,func){var _this=_super.call(this)||this;_this.x1Tensor=x1Tensor;_this.x2Tensor=x2Tensor;_this.yTensor=yTensor;_this.func=func;_this.oneOverNScalar=ndarray_1.Scalar.new(1/util.sizeFromShape(x1Tensor.shape));return _this;}ElementWiseCost.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);math.scope(function(keep){var elementWiseCost=_this.func.cost(math,x1,x2);var sum=math.sum(elementWiseCost);var result=math.scalarTimesArray(_this.oneOverNScalar,sum);inferenceArrays.set(_this.yTensor,keep(result));});};ElementWiseCost.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);math.scope(function(){if(graph_util.shouldBackProp(_this.x1Tensor)){gradientArrays.add(_this.x1Tensor,_this.func.der(math,x1,x2));}if(graph_util.shouldBackProp(_this.x2Tensor)){gradientArrays.add(_this.x2Tensor,_this.func.der(math,x2,x1));}});};ElementWiseCost.prototype.dispose=function(){this.func.dispose();this.oneOverNScalar.dispose();};return ElementWiseCost;}(op_1.Operation);exports.ElementWiseCost=ElementWiseCost;var MeanSquaredCost=function(_super){__extends(MeanSquaredCost,_super);function MeanSquaredCost(x1Tensor,x2Tensor,yTensor){return _super.call(this,x1Tensor,x2Tensor,yTensor,new cost_functions_1.SquareCostFunc())||this;}return MeanSquaredCost;}(ElementWiseCost);exports.MeanSquaredCost=MeanSquaredCost;},{"../../math/cost_functions":52,"../../math/ndarray":56,"../../util":88,"../graph_util":10,"./op":26}],20:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var graph_util=require("../graph_util");var op_1=require("./op");var Exp=function(_super){__extends(Exp,_super);function Exp(xTensor,yTensor){var _this=_super.call(this)||this;_this.xTensor=xTensor;_this.yTensor=yTensor;return _this;}Exp.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x=inferenceArrays.get(this.xTensor);math.scope(function(keep){inferenceArrays.set(_this.yTensor,keep(math.exp(x)));});};Exp.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var y=inferenceArrays.get(this.yTensor);var dy=gradientArrays.get(this.yTensor);math.scope(function(){if(graph_util.shouldBackProp(_this.xTensor)){gradientArrays.add(_this.xTensor,math.elementWiseMul(y,dy));}});};return Exp;}(op_1.Operation);exports.Exp=Exp;},{"../graph_util":10,"./op":26}],21:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var graph_util=require("../graph_util");var op_1=require("./op");var LinearCombination=function(_super){__extends(LinearCombination,_super);function LinearCombination(x1Tensor,x2Tensor,c1Tensor,c2Tensor,outTensor){var _this=_super.call(this)||this;_this.x1Tensor=x1Tensor;_this.x2Tensor=x2Tensor;_this.c1Tensor=c1Tensor;_this.c2Tensor=c2Tensor;_this.outTensor=outTensor;return _this;}LinearCombination.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);var c1=inferenceArrays.get(this.c1Tensor).asScalar();var c2=inferenceArrays.get(this.c2Tensor).asScalar();math.scope(function(keep){inferenceArrays.set(_this.outTensor,keep(math.scaledArrayAdd(c1,x1,c2,x2)));});};LinearCombination.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);var c1=inferenceArrays.get(this.c1Tensor);var c2=inferenceArrays.get(this.c2Tensor);var dy=gradientArrays.get(this.outTensor);math.scope(function(){if(graph_util.shouldBackProp(_this.x1Tensor)){gradientArrays.add(_this.x1Tensor,math.scalarTimesArray(c1,dy));}if(graph_util.shouldBackProp(_this.x2Tensor)){gradientArrays.add(_this.x2Tensor,math.scalarTimesArray(c2,dy));}if(graph_util.shouldBackProp(_this.c1Tensor)){var dotProduct1=math.elementWiseMul(x1,dy);gradientArrays.add(_this.c1Tensor,math.sum(dotProduct1));}if(graph_util.shouldBackProp(_this.c2Tensor)){var dotProduct2=math.elementWiseMul(x2,dy);gradientArrays.add(_this.c2Tensor,math.sum(dotProduct2));}});};return LinearCombination;}(op_1.Operation);exports.LinearCombination=LinearCombination;},{"../graph_util":10,"./op":26}],22:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var graph_util=require("../graph_util");var op_1=require("./op");var Log=function(_super){__extends(Log,_super);function Log(xTensor,yTensor){var _this=_super.call(this)||this;_this.xTensor=xTensor;_this.yTensor=yTensor;return _this;}Log.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x=inferenceArrays.get(this.xTensor);math.scope(function(keep){inferenceArrays.set(_this.yTensor,keep(math.log(x)));});};Log.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var x=inferenceArrays.get(this.xTensor);var dy=gradientArrays.get(this.yTensor);math.scope(function(){if(graph_util.shouldBackProp(_this.xTensor)){gradientArrays.add(_this.xTensor,math.divide(dy,x));}});};return Log;}(op_1.Operation);exports.Log=Log;},{"../graph_util":10,"./op":26}],23:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var math_1=require("../../math/math");var graph_util=require("../graph_util");var op_1=require("./op");var MatMul=function(_super){__extends(MatMul,_super);function MatMul(x1Tensor,x2Tensor,yTensor){var _this=_super.call(this)||this;_this.x1Tensor=x1Tensor;_this.x2Tensor=x2Tensor;_this.yTensor=yTensor;return _this;}MatMul.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);math.scope(function(keep){if(x1.shape.length===2&&x2.shape.length===2){inferenceArrays.set(_this.yTensor,keep(math.matMul(x1,x2)));}else if(x1.shape.length===2&&x2.shape.length===1){inferenceArrays.set(_this.yTensor,keep(math.matrixTimesVector(x1,x2)));}else if(x1.shape.length===1&&x2.shape.length===2){inferenceArrays.set(_this.yTensor,keep(math.vectorTimesMatrix(x1,x2)));}});};MatMul.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);var dy=gradientArrays.get(this.yTensor);if(x1.shape.length===1){x1=x1.reshape([1,x1.size]);dy=dy.reshape([1,dy.size]);}if(x2.shape.length===1){x2=x2.reshape([x2.size,1]);dy=dy.reshape([dy.size,1]);}math.scope(function(){if(graph_util.shouldBackProp(_this.x1Tensor)){var dx1=math.matMul(dy,x2,math_1.MatrixOrientation.REGULAR,math_1.MatrixOrientation.TRANSPOSED);gradientArrays.add(_this.x1Tensor,_this.x1Tensor.shape.length===1?dx1.as1D():dx1);}if(graph_util.shouldBackProp(_this.x2Tensor)){var dx2=math.matMul(x1,dy,math_1.MatrixOrientation.TRANSPOSED,math_1.MatrixOrientation.REGULAR);gradientArrays.add(_this.x2Tensor,_this.x2Tensor.shape.length===1?dx2.as1D():dx2);}});};return MatMul;}(op_1.Operation);exports.MatMul=MatMul;},{"../../math/math":53,"../graph_util":10,"./op":26}],24:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var conv_util=require("../../math/conv_util");var util=require("../../util");var op_1=require("./op");var MaxPool=function(_super){__extends(MaxPool,_super);function MaxPool(xTensor,yTensor,fieldSize,stride,pad){if(stride===void 0){stride=1;}var _this=_super.call(this)||this;_this.xTensor=xTensor;_this.yTensor=yTensor;_this.fieldSize=fieldSize;_this.stride=stride;if(pad!=null){_this.pad=pad;}else{_this.pad=conv_util.computeDefaultPad(xTensor.shape,_this.fieldSize,_this.stride);}util.assert(util.isInt(_this.pad),"The zero padding ("+_this.pad+") must be an integer. Change the "+"stride and/or zero pad parameters");return _this;}MaxPool.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x=inferenceArrays.get(this.xTensor);math.scope(function(keep){inferenceArrays.set(_this.yTensor,keep(math.maxPool(x,_this.fieldSize,_this.stride,_this.pad)));});};MaxPool.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var x=inferenceArrays.get(this.xTensor);var dy=gradientArrays.get(this.yTensor);math.scope(function(){gradientArrays.add(_this.xTensor,math.maxPoolBackprop(dy,x,_this.fieldSize,_this.stride,_this.pad));});};return MaxPool;}(op_1.Operation);exports.MaxPool=MaxPool;},{"../../math/conv_util":50,"../../util":88,"./op":26}],25:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var util=require("../../util");var graph_util=require("../graph_util");var op_1=require("./op");var Multiply=function(_super){__extends(Multiply,_super);function Multiply(x1Tensor,x2Tensor,yTensor){var _this=_super.call(this)||this;_this.x1Tensor=x1Tensor;_this.x2Tensor=x2Tensor;_this.yTensor=yTensor;util.assert(util.sizeFromShape(x1Tensor.shape)===1||util.sizeFromShape(x2Tensor.shape)===1||util.arraysEqual(x1Tensor.shape,x2Tensor.shape),'One of t1 or t2 must be a scalar, or t1 and t2 must have '+'the same shape');return _this;}Multiply.prototype.feedForward=function(math,inferenceArrays){var _this=this;var t1=inferenceArrays.get(this.x1Tensor);var t2=inferenceArrays.get(this.x2Tensor);math.scope(function(keep){var result;if(util.isScalarShape(t1.shape)){result=math.scalarTimesArray(t1,t2);}else if(util.isScalarShape(t2.shape)){result=math.scalarTimesArray(t2,t1);}else{result=math.elementWiseMul(t1,t2);}inferenceArrays.set(_this.yTensor,keep(result));});};Multiply.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var x1=inferenceArrays.get(this.x1Tensor);var x2=inferenceArrays.get(this.x2Tensor);var dy=gradientArrays.get(this.yTensor);math.scope(function(){if(graph_util.shouldBackProp(_this.x1Tensor)){if(util.isScalarShape(_this.x1Tensor.shape)){var mul=math.elementWiseMul(dy,x2);gradientArrays.add(_this.x1Tensor,math.sum(mul));}else if(util.isScalarShape(x2.shape)){gradientArrays.add(_this.x1Tensor,math.scalarTimesArray(x2,dy));}else{gradientArrays.add(_this.x1Tensor,math.elementWiseMul(x2,dy));}}if(graph_util.shouldBackProp(_this.x2Tensor)){if(util.isScalarShape(_this.x2Tensor.shape)){var mul=math.elementWiseMul(dy,x1);gradientArrays.add(_this.x2Tensor,math.sum(mul));}else if(util.isScalarShape(x1.shape)){gradientArrays.add(_this.x2Tensor,math.scalarTimesArray(x1,dy));}else{gradientArrays.add(_this.x2Tensor,math.elementWiseMul(x1,dy));}}});};return Multiply;}(op_1.Operation);exports.Multiply=Multiply;},{"../../util":88,"../graph_util":10,"./op":26}],26:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var Operation=function(){function Operation(){}Operation.prototype.disposeTransientArrays=function(inferenceArrays,gradientArrays){};Operation.prototype.dispose=function(){};return Operation;}();exports.Operation=Operation;},{}],27:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var util=require("../../util");var graph_util=require("../graph_util");var op_1=require("./op");var ReduceSum=function(_super){__extends(ReduceSum,_super);function ReduceSum(x,outTensor){var _this=_super.call(this)||this;_this.x=x;_this.outTensor=outTensor;util.assertShapesMatch(outTensor.shape,[]);return _this;}ReduceSum.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x=inferenceArrays.get(this.x);math.scope(function(keep){inferenceArrays.set(_this.outTensor,keep(math.sum(x)));});};ReduceSum.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;if(!graph_util.shouldBackProp(this.x)){return;}math.scope(function(){var dy=gradientArrays.get(_this.outTensor);if(_this.ones==null){var xArray=inferenceArrays.get(_this.x);_this.ones=ndarray_1.NDArray.zerosLike(xArray);_this.ones.fill(1);}gradientArrays.add(_this.x,math.scalarTimesArray(dy,_this.ones));});};return ReduceSum;}(op_1.Operation);exports.ReduceSum=ReduceSum;},{"../../math/ndarray":56,"../../util":88,"../graph_util":10,"./op":26}],28:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var util=require("../../util");var op_1=require("./op");var Reshape=function(_super){__extends(Reshape,_super);function Reshape(xTensor,yTensor){var _this=_super.call(this)||this;_this.xTensor=xTensor;_this.yTensor=yTensor;var xSize=util.sizeFromShape(xTensor.shape);var ySize=util.sizeFromShape(yTensor.shape);util.assert(xSize===ySize,"The input size ("+xSize+") and output size ("+ySize+") must match");return _this;}Reshape.prototype.feedForward=function(math,inferenceArrays){var _this=this;var x=inferenceArrays.get(this.xTensor);math.scope(function(keep){inferenceArrays.set(_this.yTensor,keep(x.reshape(_this.yTensor.shape)));});};Reshape.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var dy=gradientArrays.get(this.yTensor);math.scope(function(){gradientArrays.add(_this.xTensor,dy.reshape(_this.xTensor.shape));});};return Reshape;}(op_1.Operation);exports.Reshape=Reshape;},{"../../util":88,"./op":26}],29:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var util=require("../../util");var graph_1=require("../graph");var op_1=require("./op");var Softmax=function(_super){__extends(Softmax,_super);function Softmax(logitsTensor,output){var _this=_super.call(this)||this;_this.logitsTensor=logitsTensor;_this.output=output;return _this;}Softmax.prototype.feedForward=function(math,inferenceArrays){var _this=this;var logits=inferenceArrays.get(this.logitsTensor);return math.scope(function(keep){inferenceArrays.set(_this.output,keep(math.softmax(logits)));});};Softmax.prototype.backProp=function(){throw Error('Softmax backprop is not yet implemented');};return Softmax;}(op_1.Operation);exports.Softmax=Softmax;var SoftmaxCrossEntropyCost=function(_super){__extends(SoftmaxCrossEntropyCost,_super);function SoftmaxCrossEntropyCost(logitsTensor,labelTensor,yTensor){var _this=_super.call(this)||this;_this.logitsTensor=logitsTensor;_this.labelTensor=labelTensor;_this.yTensor=yTensor;_this.epsilon=ndarray_1.Scalar.new(1e-5);_this.softmaxTensor=new graph_1.Tensor(logitsTensor.shape);return _this;}SoftmaxCrossEntropyCost.prototype.feedForward=function(math,inferenceArrays){var _this=this;var logits=inferenceArrays.get(this.logitsTensor);var label=inferenceArrays.get(this.labelTensor);math.scope(function(keep){var softmaxResult=math.softmax(logits);inferenceArrays.set(_this.softmaxTensor,keep(softmaxResult));inferenceArrays.set(_this.yTensor,keep(crossEntropyCost(math,softmaxResult,label,_this.epsilon)));});};SoftmaxCrossEntropyCost.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var softmax=inferenceArrays.get(this.softmaxTensor);var label=inferenceArrays.get(this.labelTensor);math.scope(function(){gradientArrays.add(_this.logitsTensor,math.subtract(softmax,label));});};SoftmaxCrossEntropyCost.prototype.disposeTransientArrays=function(inferenceArrays,gradientArrays){inferenceArrays.disposeArray(this.softmaxTensor);};SoftmaxCrossEntropyCost.prototype.dispose=function(){this.epsilon.dispose();};return SoftmaxCrossEntropyCost;}(op_1.Operation);exports.SoftmaxCrossEntropyCost=SoftmaxCrossEntropyCost;function crossEntropyCost(math,y,target,epsilon){util.assert(y.size===target.size,'The output and target must be the same size');return math.scope(function(){var yPlusEps=math.scalarPlusArray(epsilon,y);var logOutput=math.log(yPlusEps);var tarLogOutput=math.elementWiseMul(target,logOutput);var costVector=math.neg(tarLogOutput);return math.sum(costVector);});}exports.crossEntropyCost=crossEntropyCost;},{"../../math/ndarray":56,"../../util":88,"../graph":9,"./op":26}],30:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var util=require("../../util");var graph_util=require("../graph_util");var op_1=require("./op");var Subtract=function(_super){__extends(Subtract,_super);function Subtract(t1,t2,outTensor){var _this=_super.call(this)||this;_this.t1=t1;_this.t2=t2;_this.outTensor=outTensor;util.assert(util.sizeFromShape(t1.shape)===1||util.sizeFromShape(t2.shape)===1||util.arraysEqual(t1.shape,t2.shape),'One of t1 or t2 must be a scalar, or t1 and t2 must have '+'the same shape');return _this;}Subtract.prototype.feedForward=function(math,inferenceArrays){var _this=this;var t1=inferenceArrays.get(this.t1);var t2=inferenceArrays.get(this.t2);math.scope(function(keep){var result;if(util.isScalarShape(t1.shape)){result=math.scalarMinusArray(t1,t2);}else if(util.isScalarShape(t2.shape)){result=math.arrayMinusScalar(t1,t2);}else{result=math.subtract(t1,t2);}inferenceArrays.set(_this.outTensor,keep(result));});};Subtract.prototype.backProp=function(math,inferenceArrays,gradientArrays){var _this=this;var dy=gradientArrays.get(this.outTensor);math.scope(function(){if(graph_util.shouldBackProp(_this.t1)){if(util.isScalarShape(_this.t1.shape)){var sum=math.sum(dy);if(_this.dySizeScalar==null){_this.dySizeScalar=ndarray_1.Scalar.new(dy.size);}gradientArrays.add(_this.t1,math.divide(sum,_this.dySizeScalar));}else{gradientArrays.add(_this.t1,math.clone(dy));}}if(graph_util.shouldBackProp(_this.t2)){if(util.isScalarShape(_this.t2.shape)){var sum=math.sum(dy);var negSum=math.neg(sum);if(_this.dySizeScalar==null){_this.dySizeScalar=ndarray_1.Scalar.new(dy.size);}gradientArrays.add(_this.t2,math.divide(negSum,_this.dySizeScalar));}else{gradientArrays.add(_this.t2,math.neg(dy));}}});};Subtract.prototype.dispose=function(){if(this.dySizeScalar!=null){this.dySizeScalar.dispose();}};return Subtract;}(op_1.Operation);exports.Subtract=Subtract;},{"../../math/ndarray":56,"../../util":88,"../graph_util":10,"./op":26}],31:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var tensor_array_map_1=require("../tensor_array_map");var optimizer_1=require("./optimizer");var AdadeltaOptimizer=function(_super){__extends(AdadeltaOptimizer,_super);function AdadeltaOptimizer(learningRate,gamma,specifiedVariableList){var _this=_super.call(this,learningRate,specifiedVariableList)||this;_this.learningRate=learningRate;_this.gamma=gamma;_this.accumulatedSquaredGradients=new tensor_array_map_1.TensorArrayMap();_this.accumulatedUpdates=new tensor_array_map_1.TensorArrayMap();_this.eps=ndarray_1.Scalar.new(1e-6);_this.g=ndarray_1.Scalar.new(_this.gamma);return _this;}AdadeltaOptimizer.prototype.beforeBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;_super.prototype.beforeBatch.call(this,math,batchSize,runtime,activationArrayMap,gradientArrayMap);if(this.accumulatedSquaredGradients.size()===0){this.variableNodes.forEach(function(node){_this.accumulatedSquaredGradients.set(node.output,ndarray_1.NDArray.zeros(node.output.shape));_this.accumulatedUpdates.set(node.output,ndarray_1.NDArray.zeros(node.output.shape));});}};AdadeltaOptimizer.prototype.afterBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;math.scope(function(keep){_this.variableNodes.forEach(function(node){var oldVariable=activationArrayMap.get(node.output);var gradient=_this.variableGradients.get(node.output);var oldCache=_this.accumulatedSquaredGradients.get(node.output);var oldUpdates=_this.accumulatedUpdates.get(node.output);var gradientSquare=math.multiply(gradient,gradient);var cache=math.scaledArrayAdd(_this.g,oldCache,math.subtract(_this.one,_this.g),gradientSquare);var updates=math.multiply(math.divide(math.sqrt(math.add(oldUpdates,_this.eps)),math.sqrt(math.add(oldCache,_this.eps))),gradient);var variable=math.scaledArrayAdd(_this.c,updates,_this.one,oldVariable);var updateSquare=math.multiply(updates,updates);var newUpdates=math.scaledArrayAdd(_this.g,oldUpdates,math.subtract(_this.one,_this.g),updateSquare);_this.accumulatedSquaredGradients.set(node.output,keep(cache));_this.accumulatedUpdates.set(node.output,keep(newUpdates));activationArrayMap.set(node.output,keep(variable));node.data=variable;oldVariable.dispose();oldCache.dispose();oldUpdates.dispose();});});this.variableGradients.dispose();this.variableGradients=new tensor_array_map_1.TensorArrayMap();};AdadeltaOptimizer.prototype.dispose=function(){_super.prototype.dispose.call(this);this.eps.dispose();this.g.dispose();this.accumulatedSquaredGradients.dispose();this.accumulatedUpdates.dispose();};return AdadeltaOptimizer;}(optimizer_1.Optimizer);exports.AdadeltaOptimizer=AdadeltaOptimizer;},{"../../math/ndarray":56,"../tensor_array_map":42,"./optimizer":36}],32:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var tensor_array_map_1=require("../tensor_array_map");var optimizer_1=require("./optimizer");var AdagradOptimizer=function(_super){__extends(AdagradOptimizer,_super);function AdagradOptimizer(learningRate,specifiedVariableList){var _this=_super.call(this,learningRate,specifiedVariableList)||this;_this.learningRate=learningRate;_this.accumulatedSquaredGradients=new tensor_array_map_1.TensorArrayMap();_this.eps=ndarray_1.Scalar.new(1e-6);return _this;}AdagradOptimizer.prototype.beforeBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;_super.prototype.beforeBatch.call(this,math,batchSize,runtime,activationArrayMap,gradientArrayMap);if(this.accumulatedSquaredGradients.size()===0){this.variableNodes.forEach(function(node){_this.accumulatedSquaredGradients.set(node.output,ndarray_1.NDArray.zeros(node.output.shape));});}};AdagradOptimizer.prototype.afterBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;math.scope(function(keep){_this.variableNodes.forEach(function(node){var oldVariable=activationArrayMap.get(node.output);var gradient=_this.variableGradients.get(node.output);var oldCache=_this.accumulatedSquaredGradients.get(node.output);var gradientSquare=math.multiply(gradient,gradient);var cache=math.add(oldCache,gradientSquare);var variable=math.scaledArrayAdd(_this.c,math.divide(gradient,math.add(math.sqrt(cache),_this.eps)),_this.one,oldVariable);_this.accumulatedSquaredGradients.set(node.output,keep(cache));activationArrayMap.set(node.output,keep(variable));node.data=variable;oldVariable.dispose();oldCache.dispose();});});this.variableGradients.dispose();this.variableGradients=new tensor_array_map_1.TensorArrayMap();};AdagradOptimizer.prototype.dispose=function(){_super.prototype.dispose.call(this);this.eps.dispose();this.accumulatedSquaredGradients.dispose();};return AdagradOptimizer;}(optimizer_1.Optimizer);exports.AdagradOptimizer=AdagradOptimizer;},{"../../math/ndarray":56,"../tensor_array_map":42,"./optimizer":36}],33:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var tensor_array_map_1=require("../tensor_array_map");var optimizer_1=require("./optimizer");var AdamOptimizer=function(_super){__extends(AdamOptimizer,_super);function AdamOptimizer(learningRate,beta1,beta2,specifiedVariableList){var _this=_super.call(this,learningRate,specifiedVariableList)||this;_this.learningRate=learningRate;_this.beta1=beta1;_this.beta2=beta2;_this.firstMoment=new tensor_array_map_1.TensorArrayMap();_this.secondMoment=new tensor_array_map_1.TensorArrayMap();_this.eps=ndarray_1.Scalar.new(1e-8);_this.b1=ndarray_1.Scalar.new(_this.beta1);_this.b2=ndarray_1.Scalar.new(_this.beta2);_this.accB1=ndarray_1.Scalar.new(_this.beta1);_this.accB2=ndarray_1.Scalar.new(_this.beta2);return _this;}AdamOptimizer.prototype.beforeBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;_super.prototype.beforeBatch.call(this,math,batchSize,runtime,activationArrayMap,gradientArrayMap);if(this.firstMoment.size()===0){this.variableNodes.forEach(function(node){_this.firstMoment.set(node.output,ndarray_1.NDArray.zeros(node.output.shape));});}if(this.secondMoment.size()===0){this.variableNodes.forEach(function(node){_this.secondMoment.set(node.output,ndarray_1.NDArray.zeros(node.output.shape));});}};AdamOptimizer.prototype.afterBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;math.scope(function(keep){_this.variableNodes.forEach(function(node){var oldVariable=activationArrayMap.get(node.output);var gradient=_this.variableGradients.get(node.output);var oldFirstMoment=_this.firstMoment.get(node.output);var oldSecondMoment=_this.secondMoment.get(node.output);var newFirstMoment=math.scaledArrayAdd(_this.b1,oldFirstMoment,math.subtract(_this.one,_this.b1),gradient);var gradientSquare=math.multiply(gradient,gradient);var newSecondMoment=math.scaledArrayAdd(_this.b2,oldSecondMoment,math.subtract(_this.one,_this.b2),gradientSquare);var biasCorrectedFirstMoment=math.divide(newFirstMoment,math.subtract(_this.one,_this.accB1));var biasCorrectedSecondMoment=math.divide(newSecondMoment,math.subtract(_this.one,_this.accB2));var variable=math.scaledArrayAdd(_this.c,math.divide(biasCorrectedFirstMoment,math.add(math.sqrt(biasCorrectedSecondMoment),_this.eps)),_this.one,oldVariable);activationArrayMap.set(node.output,keep(variable));node.data=variable;_this.firstMoment.set(node.output,keep(newFirstMoment));_this.secondMoment.set(node.output,keep(newSecondMoment));oldVariable.dispose();gradient.dispose();oldFirstMoment.dispose();oldSecondMoment.dispose();});_this.accB1=keep(math.multiply(_this.accB1,_this.b1));_this.accB2=keep(math.multiply(_this.accB2,_this.b2));});this.variableGradients.dispose();this.variableGradients=new tensor_array_map_1.TensorArrayMap();};AdamOptimizer.prototype.dispose=function(){_super.prototype.dispose.call(this);this.firstMoment.dispose();this.secondMoment.dispose();this.eps.dispose();this.b1.dispose();this.b2.dispose();this.accB1.dispose();this.accB2.dispose();};return AdamOptimizer;}(optimizer_1.Optimizer);exports.AdamOptimizer=AdamOptimizer;},{"../../math/ndarray":56,"../tensor_array_map":42,"./optimizer":36}],34:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var tensor_array_map_1=require("../tensor_array_map");var optimizer_1=require("./optimizer");var AdamaxOptimizer=function(_super){__extends(AdamaxOptimizer,_super);function AdamaxOptimizer(learningRate,beta1,beta2,specifiedVariableList){var _this=_super.call(this,learningRate,specifiedVariableList)||this;_this.learningRate=learningRate;_this.beta1=beta1;_this.beta2=beta2;_this.firstMoment=new tensor_array_map_1.TensorArrayMap();_this.weightedInfNorm=new tensor_array_map_1.TensorArrayMap();_this.b1=ndarray_1.Scalar.new(_this.beta1);_this.b2=ndarray_1.Scalar.new(_this.beta2);return _this;}AdamaxOptimizer.prototype.beforeBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;_super.prototype.beforeBatch.call(this,math,batchSize,runtime,activationArrayMap,gradientArrayMap);if(this.firstMoment.size()===0){this.variableNodes.forEach(function(node){_this.firstMoment.set(node.output,ndarray_1.NDArray.zeros(node.output.shape));});}if(this.weightedInfNorm.size()===0){this.variableNodes.forEach(function(node){_this.weightedInfNorm.set(node.output,ndarray_1.NDArray.zeros(node.output.shape));});}};AdamaxOptimizer.prototype.afterBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;math.scope(function(keep){_this.variableNodes.forEach(function(node){var oldVariable=activationArrayMap.get(node.output);var gradient=_this.variableGradients.get(node.output);var oldFirstMoment=_this.firstMoment.get(node.output);var oldWeightedInfNorm=_this.weightedInfNorm.get(node.output);var newFirstMoment=math.scaledArrayAdd(_this.b1,oldFirstMoment,math.subtract(_this.one,_this.b1),gradient);var ut0=math.multiply(_this.b2,oldWeightedInfNorm);var ut1=math.abs(gradient);var newWeightedInfNorm=math.add(math.relu(math.subtract(ut0,ut1)),ut1);var variable=math.scaledArrayAdd(_this.one,oldVariable,math.divide(_this.c,math.subtract(_this.one,_this.b1)),math.divide(newFirstMoment,newWeightedInfNorm));activationArrayMap.set(node.output,keep(variable));node.data=variable;_this.firstMoment.set(node.output,keep(newFirstMoment));_this.weightedInfNorm.set(node.output,keep(newWeightedInfNorm));oldVariable.dispose();gradient.dispose();oldFirstMoment.dispose();oldWeightedInfNorm.dispose();});});this.variableGradients.dispose();this.variableGradients=new tensor_array_map_1.TensorArrayMap();};AdamaxOptimizer.prototype.dispose=function(){_super.prototype.dispose.call(this);this.firstMoment.dispose();this.weightedInfNorm.dispose();this.eps.dispose();this.b1.dispose();this.b2.dispose();};return AdamaxOptimizer;}(optimizer_1.Optimizer);exports.AdamaxOptimizer=AdamaxOptimizer;},{"../../math/ndarray":56,"../tensor_array_map":42,"./optimizer":36}],35:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var tensor_array_map_1=require("../tensor_array_map");var sgd_optimizer_1=require("./sgd_optimizer");var MomentumOptimizer=function(_super){__extends(MomentumOptimizer,_super);function MomentumOptimizer(learningRate,momentum,specifiedVariableList){var _this=_super.call(this,learningRate,specifiedVariableList)||this;_this.learningRate=learningRate;_this.momentum=momentum;_this.variableVelocities=new tensor_array_map_1.TensorArrayMap();_this.m=ndarray_1.Scalar.new(_this.momentum);return _this;}MomentumOptimizer.prototype.beforeBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;_super.prototype.beforeBatch.call(this,math,batchSize,runtime,activationArrayMap,gradientArrayMap);if(this.variableVelocities.size()===0){this.variableNodes.forEach(function(node){_this.variableVelocities.set(node.output,ndarray_1.NDArray.zeros(node.output.shape));});}};MomentumOptimizer.prototype.afterBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;math.scope(function(keep){_this.variableNodes.forEach(function(node){var oldVariable=activationArrayMap.get(node.output);var gradient=_this.variableGradients.get(node.output);var oldVelocity=_this.variableVelocities.get(node.output);var velocity=math.scaledArrayAdd(_this.m,oldVelocity,_this.one,gradient);var variable=math.scaledArrayAdd(_this.c,velocity,_this.one,oldVariable);_this.variableVelocities.set(node.output,keep(velocity));activationArrayMap.set(node.output,keep(variable));node.data=variable;oldVariable.dispose();oldVelocity.dispose();});});this.variableGradients.dispose();this.variableGradients=new tensor_array_map_1.TensorArrayMap();};MomentumOptimizer.prototype.dispose=function(){_super.prototype.dispose.call(this);this.m.dispose();this.variableVelocities.dispose();};MomentumOptimizer.prototype.setMomentum=function(momentum){this.momentum=momentum;};return MomentumOptimizer;}(sgd_optimizer_1.SGDOptimizer);exports.MomentumOptimizer=MomentumOptimizer;},{"../../math/ndarray":56,"../tensor_array_map":42,"./sgd_optimizer":38}],36:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var session_util=require("../session_util");var tensor_array_map_1=require("../tensor_array_map");var Optimizer=function(){function Optimizer(learningRate,specifiedVariableList){this.learningRate=learningRate;this.variableGradients=new tensor_array_map_1.TensorArrayMap();this.one=ndarray_1.Scalar.new(1);if(specifiedVariableList!=null){this.specifiedVariableNodes=specifiedVariableList;}}Optimizer.prototype.beforeBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;this.variableNodes=this.specifiedVariableNodes==null?session_util.getVariableNodesFromEvaluationSet(runtime.nodes):this.specifiedVariableNodes;if(batchSize!==this.prevBatchSize){if(this.c!=null){this.c.dispose();}this.prevBatchSize=batchSize;this.c=ndarray_1.Scalar.new(-this.learningRate/batchSize);}this.variableNodes.forEach(function(node){return _this.variableGradients.set(node.output,ndarray_1.NDArray.zeros(node.output.shape));});};Optimizer.prototype.afterExample=function(math,runtime,activationArrayMap,gradientArrayMap){var _this=this;math.scope(function(keep){_this.variableNodes.forEach(function(node){var gradient=gradientArrayMap.get(node.output);var accumulatedGradient=_this.variableGradients.get(node.output);_this.variableGradients.set(node.output,keep(math.add(gradient,accumulatedGradient)));accumulatedGradient.dispose();});});};Optimizer.prototype.dispose=function(){if(this.c!=null){this.c.dispose();}this.one.dispose();};return Optimizer;}();exports.Optimizer=Optimizer;},{"../../math/ndarray":56,"../session_util":41,"../tensor_array_map":42}],37:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../../math/ndarray");var tensor_array_map_1=require("../tensor_array_map");var optimizer_1=require("./optimizer");var RMSPropOptimizer=function(_super){__extends(RMSPropOptimizer,_super);function RMSPropOptimizer(learningRate,gamma,specifiedVariableList){var _this=_super.call(this,learningRate,specifiedVariableList)||this;_this.learningRate=learningRate;_this.gamma=gamma;_this.accumulatedSquaredGradients=new tensor_array_map_1.TensorArrayMap();_this.eps=ndarray_1.Scalar.new(1e-6);_this.g=ndarray_1.Scalar.new(_this.gamma);return _this;}RMSPropOptimizer.prototype.beforeBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;_super.prototype.beforeBatch.call(this,math,batchSize,runtime,activationArrayMap,gradientArrayMap);if(this.accumulatedSquaredGradients.size()===0){this.variableNodes.forEach(function(node){_this.accumulatedSquaredGradients.set(node.output,ndarray_1.NDArray.zeros(node.output.shape));});}};RMSPropOptimizer.prototype.afterBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;math.scope(function(keep){_this.variableNodes.forEach(function(node){var oldVariable=activationArrayMap.get(node.output);var gradient=_this.variableGradients.get(node.output);var oldCache=_this.accumulatedSquaredGradients.get(node.output);var gradientSquare=math.multiply(gradient,gradient);var cache=math.scaledArrayAdd(_this.g,oldCache,math.subtract(_this.one,_this.g),gradientSquare);var variable=math.scaledArrayAdd(_this.c,math.divide(gradient,math.add(math.sqrt(cache),_this.eps)),_this.one,oldVariable);_this.accumulatedSquaredGradients.set(node.output,keep(cache));activationArrayMap.set(node.output,keep(variable));node.data=variable;oldVariable.dispose();oldCache.dispose();});});this.variableGradients.dispose();this.variableGradients=new tensor_array_map_1.TensorArrayMap();};RMSPropOptimizer.prototype.dispose=function(){_super.prototype.dispose.call(this);this.eps.dispose();this.g.dispose();this.accumulatedSquaredGradients.dispose();};return RMSPropOptimizer;}(optimizer_1.Optimizer);exports.RMSPropOptimizer=RMSPropOptimizer;},{"../../math/ndarray":56,"../tensor_array_map":42,"./optimizer":36}],38:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var tensor_array_map_1=require("../tensor_array_map");var optimizer_1=require("./optimizer");var SGDOptimizer=function(_super){__extends(SGDOptimizer,_super);function SGDOptimizer(learningRate,specifiedVariableList){var _this=_super.call(this,learningRate,specifiedVariableList)||this;_this.learningRate=learningRate;return _this;}SGDOptimizer.prototype.afterBatch=function(math,batchSize,runtime,activationArrayMap,gradientArrayMap){var _this=this;math.scope(function(keep){_this.variableNodes.forEach(function(node){var oldVariable=activationArrayMap.get(node.output);var gradient=_this.variableGradients.get(node.output);var variable=math.scaledArrayAdd(_this.c,gradient,_this.one,oldVariable);activationArrayMap.set(node.output,keep(variable));node.data=variable;oldVariable.dispose();});});this.variableGradients.dispose();this.variableGradients=new tensor_array_map_1.TensorArrayMap();};SGDOptimizer.prototype.dispose=function(){_super.prototype.dispose.call(this);};SGDOptimizer.prototype.setLearningRate=function(learningRate){this.learningRate=learningRate;};return SGDOptimizer;}(optimizer_1.Optimizer);exports.SGDOptimizer=SGDOptimizer;},{"../tensor_array_map":42,"./optimizer":36}],39:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function defaultCompare(a,b){if(a===b){return 0;}else if(a<b){return-1;}else{return 1;}}exports.defaultCompare=defaultCompare;var PriorityQueue=function(){function PriorityQueue(comparator,indexObserver){this.comparator=comparator;this.indexObserver=indexObserver;this.heap=[];}PriorityQueue.prototype.enqueue=function(t){this.heap.push(t);this.onIndexChanged(t,this.heap.length-1);this.siftUp(this.heap.length-1);};PriorityQueue.prototype.dequeue=function(){if(this.empty()){throw new Error('dequeue called on empty priority queue.');}var t=this.heap[0];this.swap(0,this.heap.length-1);this.heap.pop();this.siftDown(0);return t;};PriorityQueue.prototype.update=function(newT,index){var last=index===this.heap.length-1;if(!last){this.swap(index,this.heap.length-1);}this.heap.pop();if(!last){if(this.siftUpIndex(index)!==-1){this.siftUp(index);}else if(this.siftDownIndex(index)!==-1){this.siftDown(index);}}this.enqueue(newT);};PriorityQueue.prototype.empty=function(){return this.heap.length===0;};PriorityQueue.prototype.onIndexChanged=function(t,newIndex){if(this.indexObserver){this.indexObserver(t,newIndex);}};PriorityQueue.prototype.getParentIndex=function(index){if(index===0){return-1;}return Math.floor((index-1)/2);};PriorityQueue.prototype.getLeftChildIndex=function(index){var candidate=index*2+1;return candidate<this.heap.length?candidate:-1;};PriorityQueue.prototype.getRightChildIndex=function(index){var candidate=index*2+2;return candidate<this.heap.length?candidate:-1;};PriorityQueue.prototype.siftUpIndex=function(index){var parentIndex=this.getParentIndex(index);if(parentIndex===-1){return-1;}if(this.compare(parentIndex,index)>0){return parentIndex;}return-1;};PriorityQueue.prototype.siftUp=function(index){var siftIndex=this.siftUpIndex(index);while(siftIndex!==-1){this.swap(index,siftIndex);index=siftIndex;siftIndex=this.siftUpIndex(index);}};PriorityQueue.prototype.siftDownIndex=function(index){if(index>=this.heap.length){return-1;}var largestChildIndex=index;var leftChildIndex=this.getLeftChildIndex(index);if(leftChildIndex!==-1&&this.compare(leftChildIndex,largestChildIndex)<0){largestChildIndex=leftChildIndex;}var rightChildIndex=this.getRightChildIndex(index);if(rightChildIndex!==-1&&this.compare(rightChildIndex,largestChildIndex)<0){largestChildIndex=rightChildIndex;}return largestChildIndex===index?-1:largestChildIndex;};PriorityQueue.prototype.siftDown=function(index){var siftIndex=this.siftDownIndex(index);while(siftIndex!==-1){this.swap(index,siftIndex);index=siftIndex;siftIndex=this.siftDownIndex(index);}};PriorityQueue.prototype.compare=function(aIndex,bIndex){return this.comparator(this.heap[aIndex],this.heap[bIndex]);};PriorityQueue.prototype.swap=function(a,b){var temp=this.heap[a];this.heap[a]=this.heap[b];this.heap[b]=temp;this.onIndexChanged(this.heap[a],a);this.onIndexChanged(this.heap[b],b);};return PriorityQueue;}();exports.PriorityQueue=PriorityQueue;},{}],40:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../math/ndarray");var util=require("../util");var operation_emitter=require("./operation_emitter");var session_util=require("./session_util");var tensor_array_map_1=require("./tensor_array_map");var FeedDictionary=function(){function FeedDictionary(feedEntries){var _this=this;this.dict={};if(feedEntries){feedEntries.forEach(function(entry){return _this.dict[entry.tensor.id]=entry;});}}return FeedDictionary;}();exports.FeedDictionary=FeedDictionary;var CostReduction;(function(CostReduction){CostReduction[CostReduction["NONE"]=0]="NONE";CostReduction[CostReduction["SUM"]=1]="SUM";CostReduction[CostReduction["MEAN"]=2]="MEAN";})(CostReduction=exports.CostReduction||(exports.CostReduction={}));var Session=function(){function Session(graph,math){this.math=math;this.activationArrayMap=new tensor_array_map_1.TensorArrayMap();this.runtimeCache={};this.oneScalar=ndarray_1.Scalar.new(1);this.gradientArrayMap=new tensor_array_map_1.SummedTensorArrayMap(this.math);}Session.prototype.dispose=function(){var _this=this;this.activationArrayMap.dispose();Object.keys(this.runtimeCache).forEach(function(key){var runtime=_this.runtimeCache[key];if(runtime.operations){runtime.operations.forEach(function(op){return op.dispose();});}});this.runtimeCache={};if(this.batchSizeScalar!=null){this.batchSizeScalar.dispose();}this.oneScalar.dispose();};Session.prototype.evalAll=function(tensors,feedEntries){var _this=this;return this.math.scope(function(){var feed=new FeedDictionary(feedEntries);var runtime=_this.getOrCreateRuntime(tensors,feed);var activations=_this.activationArrayMap;session_util.disposeAndInitializeOperationOutputs(runtime.nodes,activations);session_util.disposeTransientOperationArrays(runtime.operations,_this.activationArrayMap,_this.gradientArrayMap);session_util.addPersistentArraysToTensorArrayMap(runtime.nodes,activations);session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed,activations,_this.math);runtime.operations.forEach(function(op){return op.feedForward(_this.math,activations);});var results=tensors.map(function(x){return activations.get(x);});tensors.forEach(function(x){return activations.delete(x);});session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed,activations,_this.math);return results;});};Session.prototype.eval=function(tensor,feedEntries){return this.evalAll([tensor],feedEntries)[0];};Session.prototype.train=function(costTensor,feedEntries,batchSize,optimizer,costReduction){var _this=this;if(costReduction===void 0){costReduction=CostReduction.NONE;}util.assert(util.isScalarShape(costTensor.shape),'Cost tensor for training must be a scalar value.');if(this.prevBatchSize!==batchSize){this.prevBatchSize=batchSize;this.batchSizeScalar=ndarray_1.Scalar.new(batchSize);}var feed=new FeedDictionary(feedEntries);session_util.throwIfFeedDictionaryContainsNDArrays(feed);var runtime=this.getOrCreateRuntime([costTensor],feed);var inferenceOperations=runtime.operations;var backPropOperations=runtime.operations.slice().reverse();var activations=this.activationArrayMap;var gradients=this.gradientArrayMap;gradients.nullify(costTensor);gradients.add(costTensor,this.oneScalar);session_util.addPersistentArraysToTensorArrayMap(runtime.nodes,activations);optimizer.beforeBatch(this.math,batchSize,runtime,activations,gradients);return this.math.scope(function(keep,track){var cost=track(ndarray_1.Scalar.new(0));for(var i=0;i<batchSize;++i){session_util.disposeAndInitializeOperationOutputs(runtime.nodes,activations);session_util.disposeAndInitializeOperationInputGradients(runtime.nodes,gradients);session_util.disposeTransientOperationArrays(runtime.operations,activations,gradients);session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed,activations,_this.math);inferenceOperations.forEach(function(op){return op.feedForward(_this.math,activations);});backPropOperations.forEach(function(op){return op.backProp(_this.math,activations,gradients);});optimizer.afterExample(_this.math,runtime,activations,gradients);session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed,activations,_this.math);cost=_this.updateCostForExample(cost,activations.get(costTensor),costReduction);}optimizer.afterBatch(_this.math,batchSize,runtime,activations,gradients);return _this.updateCostForBatch(cost,costReduction);});};Session.prototype.updateCostForExample=function(totalCost,currCost,costReduction){if(costReduction===CostReduction.MEAN||costReduction===CostReduction.SUM){return this.math.add(totalCost,currCost);}return totalCost;};Session.prototype.updateCostForBatch=function(totalCost,costReduction){if(costReduction===CostReduction.MEAN){return this.math.divide(totalCost,this.batchSizeScalar);}return totalCost;};Session.prototype.getOrCreateRuntime=function(tensors,feed){var key=this.makeRuntimeCacheKey(tensors,feed);var runtime=this.runtimeCache[key];if(runtime===undefined){var nodes=session_util.getOrderedEvaluationSetFromEvalTensor(tensors,feed);session_util.removeFeedDictionaryNodesFromEvaluationSet(feed,nodes);session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);var operations=operation_emitter.emitFromGraphNodes(nodes);runtime={nodes:nodes,operations:operations};this.runtimeCache[key]=runtime;}return runtime;};Session.prototype.makeRuntimeCacheKey=function(tensors,feed){return tensors.map(function(x){return x.id;}).sort().join('_')+'__'+Object.keys(feed.dict).sort().join('_');};return Session;}();exports.Session=Session;},{"../math/ndarray":56,"../util":88,"./operation_emitter":11,"./session_util":41,"./tensor_array_map":42}],41:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("../math/ndarray");var util=require("../util");var graph_1=require("./graph");var graph_util=require("./graph_util");function getTerminatingNodesFromFeedDictionary(feedDictionary){return Object.keys(feedDictionary.dict).map(function(tensorID){return feedDictionary.dict[+tensorID].tensor.node;});}exports.getTerminatingNodesFromFeedDictionary=getTerminatingNodesFromFeedDictionary;function getOrderedEvaluationSetFromEvalTensor(evalTensors,feedDictionary){var terminatingNodes=getTerminatingNodesFromFeedDictionary(feedDictionary);var evalNodes=evalTensors.map(function(x){return x.node;});var unorderedEvaluationSet=graph_util.getUnorderedEvaluationSet(evalNodes,terminatingNodes);var orderedEvaluationSet=graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);return orderedEvaluationSet;}exports.getOrderedEvaluationSetFromEvalTensor=getOrderedEvaluationSetFromEvalTensor;function addPersistentArraysToTensorArrayMap(evaluationSet,tensorArrayMap){evaluationSet.forEach(function(node){if(node instanceof graph_1.VariableNode||node instanceof graph_1.ConstantNode){tensorArrayMap.set(node.output,node.data);}});}exports.addPersistentArraysToTensorArrayMap=addPersistentArraysToTensorArrayMap;function getVariableNodesFromEvaluationSet(evaluationSet){var nodes=[];evaluationSet.forEach(function(node){if(node instanceof graph_1.VariableNode){nodes.push(node);}});return nodes;}exports.getVariableNodesFromEvaluationSet=getVariableNodesFromEvaluationSet;function throwIfFeedDictionaryContainsNDArrays(feedDictionary){Object.keys(feedDictionary.dict).forEach(function(tensorID){if(feedDictionary.dict[+tensorID].data instanceof ndarray_1.NDArray){throw new Error('training requires FeedDictionary entries to be InputProviders'+'and not NDArrays.');}});}exports.throwIfFeedDictionaryContainsNDArrays=throwIfFeedDictionaryContainsNDArrays;function loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed,activations,math){Object.keys(batchFeed.dict).forEach(function(tensorID){var feedEntry=batchFeed.dict[+tensorID];var data;if(feedEntry.data instanceof ndarray_1.NDArray){data=feedEntry.data;}else{var provider=feedEntry.data;data=provider.getNextCopy(math);}util.assert(util.arraysEqual(feedEntry.tensor.shape,data.shape),"Error loading FeedEntry: feeding NDArray of shape "+data.shape+" "+("does not match Tensor (id: "+feedEntry.tensor.id+") shape: ")+(feedEntry.tensor.shape+"."));activations.set(feedEntry.tensor,data);});}exports.loadInputsFromFeedDictionaryToTensorArrayMap=loadInputsFromFeedDictionaryToTensorArrayMap;function releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed,activations,math){Object.keys(batchFeed.dict).forEach(function(tensorID){var feedEntry=batchFeed.dict[+tensorID];if(!(feedEntry.data instanceof ndarray_1.NDArray)){var provider=feedEntry.data;var feedEntryArray=activations.get(feedEntry.tensor);provider.disposeCopy(math,feedEntryArray);}activations.delete(feedEntry.tensor);});}exports.releaseFeedDictionaryInputsFromTensorArrayMap=releaseFeedDictionaryInputsFromTensorArrayMap;function removeFeedDictionaryNodesFromEvaluationSet(feedDictionary,evaluationSet){var i=0;while(i<evaluationSet.length){var node=evaluationSet[i];if(feedDictionary.dict[node.output.id]!=null){evaluationSet.splice(i,1);}else{++i;}}}exports.removeFeedDictionaryNodesFromEvaluationSet=removeFeedDictionaryNodesFromEvaluationSet;function disposeAndInitializeOperationOutputs(evaluationSet,tensorArrayMap){evaluationSet.forEach(function(node){if(!graph_util.isInputNode(node)){if(!graph_util.isPassthroughNode(node,tensorArrayMap)){tensorArrayMap.disposeArray(node.output);}tensorArrayMap.set(node.output,null);}});}exports.disposeAndInitializeOperationOutputs=disposeAndInitializeOperationOutputs;function disposeAndInitializeOperationInputGradients(evaluationSet,gradients){evaluationSet.forEach(function(node){Object.keys(node.inputs).forEach(function(inputName){var input=node.inputs[inputName];if(gradients.get(input,true)!==gradients.get(node.output,true)){gradients.disposeArray(input);}gradients.nullify(input);});});}exports.disposeAndInitializeOperationInputGradients=disposeAndInitializeOperationInputGradients;function disposeTransientOperationArrays(operations,activations,gradients){operations.forEach(function(op){return op.disposeTransientArrays(activations,gradients);});}exports.disposeTransientOperationArrays=disposeTransientOperationArrays;function throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet){evaluationSet.forEach(function(node){if(node instanceof graph_1.PlaceholderNode){var shape='['+node.output.shape.join(', ')+']';throw new Error('Placeholder node "'+node.name+'" '+shape+' not present in feed dictionary.');}});}exports.throwErrorIfEvaluationSetContainsPlaceholderNodes=throwErrorIfEvaluationSetContainsPlaceholderNodes;},{"../math/ndarray":56,"../util":88,"./graph":9,"./graph_util":10}],42:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var TensorArrayMapBase=function(){function TensorArrayMapBase(){this.dict={};}TensorArrayMapBase.prototype.get=function(tensor,skipChecks){if(skipChecks===void 0){skipChecks=false;}if(!skipChecks&&this.dict[tensor.id]===undefined){throw new Error("tensor "+tensor.id+" not in array map.");}var nda=this.dict[tensor.id];if(!skipChecks&&nda===null){throw new Error("tensor "+tensor.id+" has null array.");}return nda;};TensorArrayMapBase.prototype.delete=function(tensor){delete this.dict[tensor.id];};TensorArrayMapBase.prototype.nullify=function(tensor){this.dict[tensor.id]=null;};TensorArrayMapBase.prototype.disposeArray=function(tensor){if(this.dict[tensor.id]===undefined){return;}var nda=this.dict[tensor.id];if(nda===null){return;}nda.dispose();this.dict[tensor.id]=null;};TensorArrayMapBase.prototype.size=function(){return Object.keys(this.dict).length;};TensorArrayMapBase.prototype.dispose=function(){var _this=this;Object.keys(this.dict).forEach(function(tensorID){var nda=_this.dict[+tensorID];if(nda){nda.dispose();}});this.dict={};};TensorArrayMapBase.prototype.hasNullArray=function(tensor){if(this.dict[tensor.id]===undefined){throw new Error("tensor "+tensor.id+" not in array map.");}return this.dict[tensor.id]===null;};return TensorArrayMapBase;}();exports.TensorArrayMapBase=TensorArrayMapBase;var TensorArrayMap=function(_super){__extends(TensorArrayMap,_super);function TensorArrayMap(){return _super!==null&&_super.apply(this,arguments)||this;}TensorArrayMap.prototype.set=function(tensor,array){this.dict[tensor.id]=array;};return TensorArrayMap;}(TensorArrayMapBase);exports.TensorArrayMap=TensorArrayMap;var SummedTensorArrayMap=function(_super){__extends(SummedTensorArrayMap,_super);function SummedTensorArrayMap(math){var _this=_super.call(this)||this;_this.math=math;return _this;}SummedTensorArrayMap.prototype.add=function(tensor,array){if(this.dict[tensor.id]==null){this.dict[tensor.id]=this.math.keep(array);}else{var oldValue=this.get(tensor);var newValue=this.math.keep(this.math.addStrict(oldValue,array));this.dict[tensor.id]=newValue;oldValue.dispose();}};return SummedTensorArrayMap;}(TensorArrayMapBase);exports.SummedTensorArrayMap=SummedTensorArrayMap;},{}],43:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var session_1=require("./graph/session");var ndarray_1=require("./math/ndarray");var DEFAULT_EVAL_INTERVAL_MS=1500;var DEFAULT_COST_INTERVAL_MS=500;var DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS=3000;var MetricReduction;(function(MetricReduction){MetricReduction[MetricReduction["SUM"]=0]="SUM";MetricReduction[MetricReduction["MEAN"]=1]="MEAN";})(MetricReduction=exports.MetricReduction||(exports.MetricReduction={}));var GraphRunner=function(){function GraphRunner(math,session,eventObserver){this.math=math;this.session=session;this.eventObserver=eventObserver;this.lastCostTimestamp=0;this.lastEvalTimestamp=0;this.totalIdleTimeMs=0;this.resetStatistics();this.zeroScalar=ndarray_1.Scalar.new(0);}GraphRunner.prototype.resetStatistics=function(){this.totalBatchesTrained=0;this.totalIdleTimeMs=0;this.lastStopTimestamp=null;};GraphRunner.prototype.train=function(costTensor,trainFeedEntries,batchSize,optimizer,numBatches,metricTensor,metricFeedEntries,metricBatchSize,metricReduction,evalIntervalMs,costIntervalMs){if(metricReduction===void 0){metricReduction=MetricReduction.MEAN;}if(evalIntervalMs===void 0){evalIntervalMs=DEFAULT_EVAL_INTERVAL_MS;}if(costIntervalMs===void 0){costIntervalMs=DEFAULT_COST_INTERVAL_MS;}this.costTensor=costTensor;this.trainFeedEntries=trainFeedEntries;this.metricTensor=metricTensor;this.metricFeedEntries=metricFeedEntries;if(metricBatchSize!=null&&this.metricBatchSize!==metricBatchSize){if(this.metricBatchSizeScalar!=null){this.metricBatchSizeScalar.dispose();}this.metricBatchSizeScalar=ndarray_1.Scalar.new(metricBatchSize);}this.metricBatchSize=metricBatchSize;this.metricReduction=metricReduction;this.batchSize=batchSize;this.optimizer=optimizer;this.metricIntervalMs=evalIntervalMs;this.costIntervalMs=costIntervalMs;this.currentTrainLoopNumBatches=numBatches;this.batchesTrainedThisRun=0;this.isTraining=true;this.trainStartTimestamp=performance.now();this.trainNetwork();};GraphRunner.prototype.stopTraining=function(){this.isTraining=false;this.lastStopTimestamp=performance.now();};GraphRunner.prototype.resumeTraining=function(){this.isTraining=true;if(this.lastStopTimestamp!=null){this.totalIdleTimeMs+=performance.now()-this.lastStopTimestamp;}this.trainNetwork();};GraphRunner.prototype.trainNetwork=function(){var _this=this;if(this.batchesTrainedThisRun===this.currentTrainLoopNumBatches){this.stopTraining();}if(!this.isTraining){if(this.eventObserver.doneTrainingCallback!=null){this.eventObserver.doneTrainingCallback();}return;}var start=performance.now();var shouldComputeCost=this.eventObserver.avgCostCallback!=null&&start-this.lastCostTimestamp>this.costIntervalMs;if(shouldComputeCost){this.lastCostTimestamp=start;}var costReduction=shouldComputeCost?session_1.CostReduction.MEAN:session_1.CostReduction.NONE;this.math.scope(function(keep){var avgCost=_this.session.train(_this.costTensor,_this.trainFeedEntries,_this.batchSize,_this.optimizer,costReduction);if(shouldComputeCost){var trainTime=performance.now()-start;_this.eventObserver.avgCostCallback(avgCost);if(_this.eventObserver.trainExamplesPerSecCallback!=null){var examplesPerSec=_this.batchSize*1000/trainTime;_this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);}}if(_this.eventObserver.metricCallback!=null&&_this.metricFeedEntries!=null&&start-_this.lastEvalTimestamp>_this.metricIntervalMs){_this.lastEvalTimestamp=start;if(_this.lastComputedMetric!=null){_this.lastComputedMetric.dispose();}_this.lastComputedMetric=_this.computeMetric();_this.eventObserver.metricCallback(_this.lastComputedMetric);}if(_this.eventObserver.totalTimeCallback!=null){_this.eventObserver.totalTimeCallback((start-_this.trainStartTimestamp)/1000);}_this.batchesTrainedThisRun++;_this.totalBatchesTrained++;if(_this.eventObserver.batchesTrainedCallback!=null){_this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);}});requestAnimationFrame(function(){return _this.trainNetwork();});};GraphRunner.prototype.infer=function(inferenceTensor,inferenceFeedEntries,inferenceExampleIntervalMs,inferenceExampleCount,numPasses){var _this=this;if(inferenceExampleIntervalMs===void 0){inferenceExampleIntervalMs=DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS;}if(inferenceExampleCount===void 0){inferenceExampleCount=5;}if(this.eventObserver.inferenceExamplesCallback==null&&this.eventObserver.inferenceExamplesPerSecCallback==null){throw new Error('Cannot start inference loop, no inference example or '+'examples/sec observer provided.');}for(var i=0;i<inferenceFeedEntries.length;i++){var feedEntry=inferenceFeedEntries[i];if(feedEntry.data instanceof ndarray_1.NDArray){throw new Error('Cannot start inference on the model runner with feed entries of '+'type NDArray. Please use InputProviders.');}}this.inferenceExampleIntervalMs=inferenceExampleIntervalMs;this.inferenceTensor=inferenceTensor;this.inferenceFeedEntries=inferenceFeedEntries;this.inferenceExampleCount=inferenceExampleCount;this.currentInferenceLoopNumPasses=numPasses;if(!this.isInferring){this.inferencePassesThisRun=0;requestAnimationFrame(function(){return _this.inferNetwork();});}this.isInferring=true;};GraphRunner.prototype.inferNetwork=function(){var _this=this;if(!this.isInferring||this.inferencePassesThisRun===this.currentInferenceLoopNumPasses){return;}this.math.scope(function(keep,track){var feeds=[];var inferenceValues=[];var start=performance.now();for(var i=0;i<_this.inferenceExampleCount;i++){var ndarrayFeedEntries=[];for(var j=0;j<_this.inferenceFeedEntries.length;j++){var feedEntry=_this.inferenceFeedEntries[j];ndarrayFeedEntries.push({tensor:feedEntry.tensor,data:track(feedEntry.data.getNextCopy(_this.math))});}feeds.push(ndarrayFeedEntries);inferenceValues.push(_this.session.eval(_this.inferenceTensor,ndarrayFeedEntries));}if(_this.eventObserver.inferenceExamplesPerSecCallback!=null){inferenceValues[inferenceValues.length-1].getValues();var inferenceExamplesPerSecTime=performance.now()-start;var examplesPerSec=_this.inferenceExampleCount*1000/inferenceExamplesPerSecTime;_this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);}if(_this.eventObserver.inferenceExamplesCallback!=null){_this.eventObserver.inferenceExamplesCallback(feeds,inferenceValues);}_this.inferencePassesThisRun++;});this.lastInferTimeoutID=window.setTimeout(function(){return _this.inferNetwork();},this.inferenceExampleIntervalMs);};GraphRunner.prototype.stopInferring=function(){this.isInferring=false;window.clearTimeout(this.lastInferTimeoutID);};GraphRunner.prototype.isInferenceRunning=function(){return this.isInferring;};GraphRunner.prototype.computeMetric=function(){var _this=this;if(this.metricFeedEntries==null){throw new Error('Cannot compute metric, no metric FeedEntries provided.');}var metric=this.zeroScalar;return this.math.scope(function(keep){for(var i=0;i<_this.metricBatchSize;i++){var metricValue=_this.session.eval(_this.metricTensor,_this.metricFeedEntries);metric=_this.math.add(metric,metricValue);}if(_this.metricReduction===MetricReduction.MEAN){metric=_this.math.divide(metric,_this.metricBatchSizeScalar);}return metric;});};GraphRunner.prototype.getTotalBatchesTrained=function(){return this.totalBatchesTrained;};GraphRunner.prototype.getLastComputedMetric=function(){return this.lastComputedMetric;};GraphRunner.prototype.setMath=function(math){this.math=math;};GraphRunner.prototype.setSession=function(session){this.session=session;};GraphRunner.prototype.setInferenceTensor=function(inferenceTensor){this.inferenceTensor=inferenceTensor;};GraphRunner.prototype.setInferenceExampleCount=function(inferenceExampleCount){this.inferenceExampleCount=inferenceExampleCount;};return GraphRunner;}();exports.GraphRunner=GraphRunner;},{"./graph/session":40,"./math/ndarray":56}],44:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var xhr_dataset=require("./data/xhr-dataset");exports.xhr_dataset=xhr_dataset;var environment=require("./environment");exports.environment=environment;var conv_util=require("./math/conv_util");exports.conv_util=conv_util;var gpgpu_util=require("./math/webgl/gpgpu_util");exports.gpgpu_util=gpgpu_util;var render_ndarray_gpu_util=require("./math/webgl/render_ndarray_gpu_util");exports.render_ndarray_gpu_util=render_ndarray_gpu_util;var webgl_util=require("./math/webgl/webgl_util");exports.webgl_util=webgl_util;var test_util=require("./test_util");exports.test_util=test_util;var util=require("./util");exports.util=util;var version_1=require("./version");exports.version=version_1.version;var checkpoint_loader_1=require("./data/checkpoint_loader");exports.CheckpointLoader=checkpoint_loader_1.CheckpointLoader;var dataset_1=require("./data/dataset");exports.InMemoryDataset=dataset_1.InMemoryDataset;var input_provider_1=require("./data/input_provider");exports.InCPUMemoryShuffledInputProviderBuilder=input_provider_1.InCPUMemoryShuffledInputProviderBuilder;exports.InGPUMemoryShuffledInputProviderBuilder=input_provider_1.InGPUMemoryShuffledInputProviderBuilder;var xhr_dataset_1=require("./data/xhr-dataset");exports.XhrDataset=xhr_dataset_1.XhrDataset;var environment_1=require("./environment");exports.ENV=environment_1.ENV;exports.Environment=environment_1.Environment;var graph_1=require("./graph/graph");exports.Graph=graph_1.Graph;exports.Tensor=graph_1.Tensor;var adadelta_optimizer_1=require("./graph/optimizers/adadelta_optimizer");exports.AdadeltaOptimizer=adadelta_optimizer_1.AdadeltaOptimizer;var adagrad_optimizer_1=require("./graph/optimizers/adagrad_optimizer");exports.AdagradOptimizer=adagrad_optimizer_1.AdagradOptimizer;var adam_optimizer_1=require("./graph/optimizers/adam_optimizer");exports.AdamOptimizer=adam_optimizer_1.AdamOptimizer;var adamax_optimizer_1=require("./graph/optimizers/adamax_optimizer");exports.AdamaxOptimizer=adamax_optimizer_1.AdamaxOptimizer;var momentum_optimizer_1=require("./graph/optimizers/momentum_optimizer");exports.MomentumOptimizer=momentum_optimizer_1.MomentumOptimizer;var optimizer_1=require("./graph/optimizers/optimizer");exports.Optimizer=optimizer_1.Optimizer;var rmsprop_optimizer_1=require("./graph/optimizers/rmsprop_optimizer");exports.RMSPropOptimizer=rmsprop_optimizer_1.RMSPropOptimizer;var sgd_optimizer_1=require("./graph/optimizers/sgd_optimizer");exports.SGDOptimizer=sgd_optimizer_1.SGDOptimizer;var session_1=require("./graph/session");exports.CostReduction=session_1.CostReduction;exports.Session=session_1.Session;var graph_runner_1=require("./graph_runner");exports.GraphRunner=graph_runner_1.GraphRunner;exports.MetricReduction=graph_runner_1.MetricReduction;var initializers_1=require("./initializers");exports.ConstantInitializer=initializers_1.ConstantInitializer;exports.NDArrayInitializer=initializers_1.NDArrayInitializer;exports.OnesInitializer=initializers_1.OnesInitializer;exports.RandomNormalInitializer=initializers_1.RandomNormalInitializer;exports.RandomTruncatedNormalInitializer=initializers_1.RandomTruncatedNormalInitializer;exports.RandomUniformInitializer=initializers_1.RandomUniformInitializer;exports.VarianceScalingInitializer=initializers_1.VarianceScalingInitializer;exports.ZerosInitializer=initializers_1.ZerosInitializer;var math_1=require("./math/math");exports.MatrixOrientation=math_1.MatrixOrientation;exports.NDArrayMath=math_1.NDArrayMath;var math_cpu_1=require("./math/math_cpu");exports.NDArrayMathCPU=math_cpu_1.NDArrayMathCPU;var math_gpu_1=require("./math/math_gpu");exports.NDArrayMathGPU=math_gpu_1.NDArrayMathGPU;var ndarray_1=require("./math/ndarray");exports.initializeGPU=ndarray_1.initializeGPU;var ndarray_2=require("./math/ndarray");exports.Array1D=ndarray_2.Array1D;exports.Array2D=ndarray_2.Array2D;exports.Array3D=ndarray_2.Array3D;exports.Array4D=ndarray_2.Array4D;exports.NDArray=ndarray_2.NDArray;exports.Scalar=ndarray_2.Scalar;var gpgpu_context_1=require("./math/webgl/gpgpu_context");exports.GPGPUContext=gpgpu_context_1.GPGPUContext;function exportToTopLevel(alias){setTimeout(function(){var w=window;if(w!=null&&w.deeplearn!=null&&w[alias]==null){w[alias]=w.deeplearn;}});}exportToTopLevel('dl');},{"./data/checkpoint_loader":3,"./data/dataset":4,"./data/input_provider":5,"./data/xhr-dataset":6,"./environment":8,"./graph/graph":9,"./graph/optimizers/adadelta_optimizer":31,"./graph/optimizers/adagrad_optimizer":32,"./graph/optimizers/adam_optimizer":33,"./graph/optimizers/adamax_optimizer":34,"./graph/optimizers/momentum_optimizer":35,"./graph/optimizers/optimizer":36,"./graph/optimizers/rmsprop_optimizer":37,"./graph/optimizers/sgd_optimizer":38,"./graph/session":40,"./graph_runner":43,"./initializers":45,"./math/conv_util":50,"./math/math":53,"./math/math_cpu":54,"./math/math_gpu":55,"./math/ndarray":56,"./math/webgl/gpgpu_context":67,"./math/webgl/gpgpu_util":69,"./math/webgl/render_ndarray_gpu_util":78,"./math/webgl/webgl_util":86,"./test_util":87,"./util":88,"./version":89}],45:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("./math/ndarray");var VarianceScalingInitializer=function(){function VarianceScalingInitializer(scale,mode,distribution){if(scale===void 0){scale=1.0;}if(mode===void 0){mode='fan_in';}if(distribution===void 0){distribution='normal';}this.scale=scale;this.mode=mode;this.distribution=distribution;}VarianceScalingInitializer.prototype.initialize=function(weightsShape,inputUnits,outputUnits){var n=0;if(this.mode==='fan_in'){n=inputUnits;}else if(this.mode==='fan_out'){n=outputUnits;}else if(this.mode==='fan_avg'){n=(inputUnits+outputUnits)/2;}else{throw new Error("Unexpected mode for variance scaling initializer: "+this.mode);}if(this.distribution==='normal'){return ndarray_1.NDArray.randTruncatedNormal(weightsShape,0.0,Math.sqrt(this.scale/n));}else if(this.distribution==='uniform'){return ndarray_1.NDArray.randUniform(weightsShape,0.0,Math.sqrt(3*this.scale/n));}else{throw new Error("Unexpected distribution for variance scaling initializer: "+(""+this.distribution));}};return VarianceScalingInitializer;}();exports.VarianceScalingInitializer=VarianceScalingInitializer;var ZerosInitializer=function(){function ZerosInitializer(){}ZerosInitializer.prototype.initialize=function(weightsShape,inputUnits,outputUnits){return ndarray_1.NDArray.zeros(weightsShape);};return ZerosInitializer;}();exports.ZerosInitializer=ZerosInitializer;var OnesInitializer=function(){function OnesInitializer(){}OnesInitializer.prototype.initialize=function(weightsShape,inputUnits,outputUnits){var values=ndarray_1.NDArray.zeros(weightsShape);values.fill(1);return values;};return OnesInitializer;}();exports.OnesInitializer=OnesInitializer;var ConstantInitializer=function(){function ConstantInitializer(value){if(value===void 0){value=0;}this.value=value;}ConstantInitializer.prototype.initialize=function(weightsShape,inputUnits,outputUnits){var values=ndarray_1.NDArray.zeros(weightsShape);values.fill(this.value);return values;};return ConstantInitializer;}();exports.ConstantInitializer=ConstantInitializer;var NDArrayInitializer=function(){function NDArrayInitializer(ndarray){this.ndarray=ndarray;}NDArrayInitializer.prototype.initialize=function(weightsShape,inputUnits,outputUnits){return this.ndarray;};return NDArrayInitializer;}();exports.NDArrayInitializer=NDArrayInitializer;var RandomNormalInitializer=function(){function RandomNormalInitializer(mean,stdev){if(mean===void 0){mean=0;}if(stdev===void 0){stdev=.05;}this.mean=mean;this.stdev=stdev;}RandomNormalInitializer.prototype.initialize=function(weightsShape,inputUnits,outputUnits){return ndarray_1.NDArray.randNormal(weightsShape,this.mean,this.stdev);};return RandomNormalInitializer;}();exports.RandomNormalInitializer=RandomNormalInitializer;var RandomTruncatedNormalInitializer=function(){function RandomTruncatedNormalInitializer(mean,stdev){if(mean===void 0){mean=0;}if(stdev===void 0){stdev=.05;}this.mean=mean;this.stdev=stdev;}RandomTruncatedNormalInitializer.prototype.initialize=function(weightsShape,inputUnits,outputUnits){return ndarray_1.NDArray.randTruncatedNormal(weightsShape,this.mean,this.stdev);};return RandomTruncatedNormalInitializer;}();exports.RandomTruncatedNormalInitializer=RandomTruncatedNormalInitializer;var RandomUniformInitializer=function(){function RandomUniformInitializer(minval,maxval){if(minval===void 0){minval=-.05;}if(maxval===void 0){maxval=.05;}this.minval=minval;this.maxval=maxval;}RandomUniformInitializer.prototype.initialize=function(weightsShape,inputUnits,outputUnits){return ndarray_1.NDArray.randUniform(weightsShape,this.minval,this.maxval);};return RandomUniformInitializer;}();exports.RandomUniformInitializer=RandomUniformInitializer;},{"./math/ndarray":56}],46:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("./ndarray");var TanHFunc=function(){function TanHFunc(){}TanHFunc.prototype.output=function(math,x){return math.scope(function(){return math.tanh(x);});};TanHFunc.prototype.der=function(math,x,y){return math.scope(function(){var ySquared=math.elementWiseMul(y,y);return math.scalarMinusArray(ndarray_1.Scalar.ONE,ySquared);});};return TanHFunc;}();exports.TanHFunc=TanHFunc;var ReLUFunc=function(){function ReLUFunc(){}ReLUFunc.prototype.output=function(math,x){return math.scope(function(){return math.relu(x);});};ReLUFunc.prototype.der=function(math,x,y){return math.scope(function(){return math.step(x);});};return ReLUFunc;}();exports.ReLUFunc=ReLUFunc;var SigmoidFunc=function(){function SigmoidFunc(){}SigmoidFunc.prototype.output=function(math,x){return math.scope(function(){return math.sigmoid(x);});};SigmoidFunc.prototype.der=function(math,x,y){return math.scope(function(){var ySquared=math.elementWiseMul(y,y);return math.subStrict(y,ySquared);});};return SigmoidFunc;}();exports.SigmoidFunc=SigmoidFunc;var SquareFunc=function(){function SquareFunc(){}SquareFunc.prototype.output=function(math,x){return math.scope(function(){return math.elementWiseMul(x,x);});};SquareFunc.prototype.der=function(math,x,y){return math.scope(function(){return math.scalarTimesArray(ndarray_1.Scalar.TWO,x);});};return SquareFunc;}();exports.SquareFunc=SquareFunc;},{"./ndarray":56}],47:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function axesAreInnerMostDims(axes,rank){for(var i=0;i<axes.length;++i){if(axes[axes.length-i-1]!==rank-1-i){return false;}}return true;}exports.axesAreInnerMostDims=axesAreInnerMostDims;function combineLocations(outputLoc,reduceLoc,axes){var rank=outputLoc.length+reduceLoc.length;var loc=[];var outIdx=0;var reduceIdx=0;for(var dim=0;dim<rank;dim++){if(axes.indexOf(dim)===-1){loc.push(outputLoc[outIdx++]);}else{loc.push(reduceLoc[reduceIdx++]);}}return loc;}exports.combineLocations=combineLocations;function computeOutAndReduceShapes(aShape,axes){var outShape=[];var rank=aShape.length;for(var dim=0;dim<rank;dim++){if(axes.indexOf(dim)===-1){outShape.push(aShape[dim]);}}var reduceShape=axes.map(function(dim){return aShape[dim];});return[outShape,reduceShape];}exports.computeOutAndReduceShapes=computeOutAndReduceShapes;function expandShapeToKeepDim(shape,axes){var reduceSubShape=axes.map(function(x){return 1;});return combineLocations(shape,reduceSubShape,axes);}exports.expandShapeToKeepDim=expandShapeToKeepDim;function parseAxisParam(axis,shape){if(axis==null){axis=shape.map(function(s,i){return i;});}else if(typeof axis==='number'){axis=[axis];}return axis;}exports.parseAxisParam=parseAxisParam;function assertAxesAreInnerMostDims(msg,axes,rank){if(!axesAreInnerMostDims(axes,rank)){throw new Error(msg+" supports only inner-most axes for now. "+("Got axes "+axes+" and rank-"+rank+" input."));}}exports.assertAxesAreInnerMostDims=assertAxesAreInnerMostDims;function getPermutedAxes(axes,rank){if(axesAreInnerMostDims(axes,rank)){return null;}var result=[];for(var i=0;i<rank;++i){if(axes.indexOf(i)===-1){result.push(i);}}axes.forEach(function(axis){return result.push(axis);});return result;}exports.getPermutedAxes=getPermutedAxes;function getInnerMostAxes(numAxes,rank){var res=[];for(var i=rank-numAxes;i<rank;++i){res.push(i);}return res;}exports.getInnerMostAxes=getInnerMostAxes;},{}],48:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function getBroadcastDims(inShape,outShape){var inRank=inShape.length;var dims=[];for(var i=0;i<inRank;i++){var dim=inRank-1-i;var a=inShape[dim]||1;var b=outShape[outShape.length-1-i]||1;if(b>1&&a===1){dims.unshift(dim);}}return dims;}exports.getBroadcastDims=getBroadcastDims;function broadcastDimsAreOuter(dims){for(var i=0;i<dims.length;i++){if(dims[i]!==i){return false;}}return true;}exports.broadcastDimsAreOuter=broadcastDimsAreOuter;function assertAndGetBroadcastShape(shapeA,shapeB){var result=[];var errMsg="Operands could not be broadcast together with shapes "+(shapeA+" and "+shapeB+".");var l=Math.max(shapeA.length,shapeB.length);for(var i=0;i<l;i++){var a=shapeA[shapeA.length-i-1]||1;var b=shapeB[shapeB.length-i-1]||1;if(a>1&&b>1&&a!==b){throw Error(errMsg);}result.unshift(Math.max(a,b));}return result;}exports.assertAndGetBroadcastShape=assertAndGetBroadcastShape;},{}],49:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../util");function assertParams(aShape,bShape,axis){var aRank=aShape.length;var bRank=bShape.length;util.assert(aShape.length===bShape.length,"Error in concat"+aRank+"D: rank of x1 ("+aRank+") and x2 ("+bRank+") "+"must be the same.");util.assert(axis>=0&&axis<aRank,"Error in concat"+aRank+"D: axis must be "+("between 0 and "+(aRank-1)+"."));for(var i=0;i<aRank;i++){util.assert(i===axis||aShape[i]===bShape[i],"Error in concat"+aRank+"D: Shape ("+aShape+") does not match "+("("+bShape+") along the non-concatenated axis "+i+"."));}}exports.assertParams=assertParams;function computeOutShape(x1Shape,x2Shape,axis){util.assert(x1Shape.length===x2Shape.length,'x1 and x2 should have the same rank.');var outputShape=x1Shape.slice();outputShape[axis]+=x2Shape[axis];return outputShape;}exports.computeOutShape=computeOutShape;},{"../util":88}],50:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../util");function computeConvInfo(inShape,filterHeight,filterWidth,outDepth,strideHeight,strideWidth,pad){if(typeof pad==='number'){var outShape_1=computeOutputShape3D(inShape,filterHeight,outDepth,strideHeight,pad);return{inShape:inShape,outShape:outShape_1,padInfo:{top:pad,bottom:pad,left:pad,right:pad},strideHeight:strideHeight,strideWidth:strideWidth,filterHeight:filterHeight,filterWidth:filterWidth};}var inHeight=inShape[0];var inWidth=inShape[1];var outShape;var padInfo;if(pad==='same'){var outHeight=Math.ceil(inHeight/strideHeight);var outWidth=Math.ceil(inWidth/strideWidth);outShape=[outHeight,outWidth,outDepth];var padAlongHeight=(outHeight-1)*strideHeight+filterHeight-inHeight;var padAlongWidth=(outWidth-1)*strideWidth+filterWidth-inWidth;var top_1=Math.floor(padAlongHeight/2);var bottom=padAlongHeight-top_1;var left=Math.floor(padAlongWidth/2);var right=padAlongWidth-left;padInfo={top:top_1,bottom:bottom,left:left,right:right};}else if(pad==='valid'){var outHeight=Math.ceil((inHeight-filterHeight+1)/strideHeight);var outWidth=Math.ceil((inWidth-filterWidth+1)/strideWidth);outShape=[outHeight,outWidth,outDepth];padInfo={top:0,bottom:0,left:0,right:0};}else{throw Error("Unknown padding parameter: "+pad);}return{inShape:inShape,outShape:outShape,padInfo:padInfo,strideHeight:strideHeight,strideWidth:strideWidth,filterHeight:filterHeight,filterWidth:filterWidth};}exports.computeConvInfo=computeConvInfo;function computeOutputShape3D(inShape,fieldSize,outDepth,stride,zeroPad){if(zeroPad==null){zeroPad=computeDefaultPad(inShape,fieldSize,stride);}var inputRows=inShape[0];var inputCols=inShape[1];var outputRows=(inputRows-fieldSize+2*zeroPad)/stride+1;util.assert(util.isInt(outputRows),"The output # of rows ("+outputRows+") must be an integer. Change the "+"stride and/or zero pad parameters");var outputCols=(inputCols-fieldSize+2*zeroPad)/stride+1;util.assert(util.isInt(outputCols),"The output # of columns ("+outputCols+") must be an integer. Change "+"the stride and/or zero pad parameters");return[outputRows,outputCols,outDepth];}exports.computeOutputShape3D=computeOutputShape3D;function computeDefaultPad(inputShape,fieldSize,stride){return Math.floor((inputShape[0]*(stride-1)-stride+fieldSize)/2);}exports.computeDefaultPad=computeDefaultPad;function computeTexShapeFrom3D(shapeRowColDepth){return[shapeRowColDepth[0],shapeRowColDepth[1]*shapeRowColDepth[2]];}exports.computeTexShapeFrom3D=computeTexShapeFrom3D;function computeWeightsShape4D(inputDepth,outputDepth,filterHeight,filterWidth){return[filterHeight,filterWidth,inputDepth,outputDepth];}exports.computeWeightsShape4D=computeWeightsShape4D;function computeDilatedRC(rc,origStride){var rowsDilated=(rc[0]-1)*origStride+1;var colsDilated=(rc[1]-1)*origStride+1;return[rowsDilated,colsDilated];}exports.computeDilatedRC=computeDilatedRC;},{"../util":88}],51:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function validateShapes(sourceSize,destSize){var srcArea=sourceSize[0]*sourceSize[1];var dstArea=destSize[0]*destSize[1];if(srcArea!==dstArea){var srcStr="["+sourceSize[0]+", "+sourceSize[1]+"]";var dstStr="["+destSize[0]+", "+destSize[1]+"]";throw new Error("copy2D shapes have different areas:\n  sourceSize "+srcStr+(", area "+srcArea+"\n  destSize "+dstStr+", area "+dstArea));}}exports.validateShapes=validateShapes;},{}],52:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ndarray_1=require("./ndarray");var SquareCostFunc=function(){function SquareCostFunc(){this.halfOne=ndarray_1.Scalar.new(0.5);}SquareCostFunc.prototype.cost=function(math,x1,x2){var diff=math.subStrict(x1,x2);var diffSquared=math.elementWiseMul(diff,diff);var result=math.scalarTimesArray(this.halfOne,diffSquared);diff.dispose();diffSquared.dispose();return result;};SquareCostFunc.prototype.der=function(math,x1,x2){return math.subStrict(x1,x2);};SquareCostFunc.prototype.dispose=function(){this.halfOne.dispose();};return SquareCostFunc;}();exports.SquareCostFunc=SquareCostFunc;},{"./ndarray":56}],53:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../util");var axis_util=require("./axis_util");var broadcast_util=require("./broadcast_util");var concat_util=require("./concat_util");var conv_util=require("./conv_util");var copy2d_util=require("./copy2d_util");var ndarray_1=require("./ndarray");var slice_util=require("./slice_util");var SumTypesMap;(function(SumTypesMap){SumTypesMap["float32"]="float32";SumTypesMap["int32"]="int32";SumTypesMap["bool"]="int32";})(SumTypesMap=exports.SumTypesMap||(exports.SumTypesMap={}));var NDArrayMath=function(){function NDArrayMath(safeMode){this.safeMode=safeMode;this.ndarrayScopes=[];this.ndarraysToKeep=[];this.activeScopeNDArraysToKeep=[];this.debugMode=false;}NDArrayMath.prototype.scope=function(scopeFn){var _this=this;this.startScope();var keepFn=function keepFn(ndarray){return _this.keep(ndarray);};var trackFn=function trackFn(ndarray){return _this.track(ndarray);};var result=scopeFn(keepFn,trackFn);if(result instanceof Promise){result.then(function(r){return _this.endScope(r);});return result;}else{this.endScope(result);return result;}};NDArrayMath.prototype.enableDebugMode=function(){this.debugMode=true;console.warn('Debugging mode is ON. The output of every math call will '+'be downloaded to CPU and checked for NaNs. '+'This significantly impacts performance.');};NDArrayMath.prototype.startScope=function(){var newScope=[];this.ndarrayScopes.push(newScope);this.activeScope=newScope;var newNDArraysToKeep=[];this.ndarraysToKeep.push(newNDArraysToKeep);this.activeScopeNDArraysToKeep=newNDArraysToKeep;};NDArrayMath.prototype.extractNDArraysFromScopeResult=function(result){if(result==null){return[];}if(result instanceof ndarray_1.NDArray){return[result];}var list=[];var resultObj=result;for(var k in resultObj){var val=resultObj[k];if(val instanceof ndarray_1.NDArray){list.push(val);}}return list;};NDArrayMath.prototype.endScope=function(result){var _this=this;var arraysToKeep=this.activeScopeNDArraysToKeep;var resultArrays=this.extractNDArraysFromScopeResult(result);arraysToKeep=arraysToKeep.concat(resultArrays);for(var i=0;i<this.activeScope.length;i++){var ndarray=this.activeScope[i];if(this.isNDArrayDataInList(ndarray,arraysToKeep)){continue;}ndarray.dispose();}this.ndarrayScopes.pop();this.activeScope=this.ndarrayScopes.length===0?null:this.ndarrayScopes[this.ndarrayScopes.length-1];resultArrays.forEach(function(val){if(!_this.isNDArrayDataInList(val,_this.activeScopeNDArraysToKeep)){_this.track(val);}});this.ndarraysToKeep.pop();this.activeScopeNDArraysToKeep=this.ndarraysToKeep.length===0?null:this.ndarraysToKeep[this.ndarraysToKeep.length-1];};NDArrayMath.prototype.isNDArrayDataInList=function(ndarray,ndarrayList){for(var i=0;i<ndarrayList.length;i++){if(ndarrayList[i].getData()===ndarray.getData()){return true;}}return false;};NDArrayMath.prototype.keep=function(result){if(this.activeScope==null){if(this.safeMode){throw new Error('You are using math in safe mode. Enclose all '+'math.method() calls inside a scope: '+'math.scope(() => {math.method();...}) to avoid memory '+'leaks.');}return result;}this.activeScopeNDArraysToKeep.push(result);return result;};NDArrayMath.prototype.checkForNaN=function(vals,dtype,name){for(var i=0;i<vals.length;i++){if(util.isValNaN(vals[i],dtype)){throw Error("The result of the last math."+name+" has NaNs.");}}};NDArrayMath.prototype.track=function(result){if(this.activeScope==null){if(this.safeMode){throw new Error('You are using math in safe mode. Enclose all '+'math.method() calls inside a scope: '+'math.scope(() => {math.method();...}) to avoid memory '+'leaks.');}return result;}this.activeScope.push(result);return result;};NDArrayMath.prototype.dispose=function(){};NDArrayMath.prototype.matMul=function(a,b,aOrientation,bOrientation){var _this=this;if(aOrientation===void 0){aOrientation=MatrixOrientation.REGULAR;}if(bOrientation===void 0){bOrientation=MatrixOrientation.REGULAR;}var innerShapeA=aOrientation===MatrixOrientation.REGULAR?a.shape[1]:a.shape[0];var innerShapeB=bOrientation===MatrixOrientation.REGULAR?b.shape[0]:b.shape[1];util.assert(a.rank===2&&b.rank===2,"Error in matMul: inputs must be rank 2, got ranks "+a.rank+("and "+b.rank+"."));util.assert(innerShapeA===innerShapeB,"Error in matMul: inner shapes ("+innerShapeA+") and ("+(innerShapeB+") of NDArrays with shapes "+a.shape+" and ")+(b.shape+" and orientations "+MatrixOrientation[aOrientation])+(" and "+MatrixOrientation[bOrientation]+" must match."));return this.executeOp('matMul',function(){return _this.matMulInternal(a,b,aOrientation,bOrientation);});};NDArrayMath.prototype.executeOp=function(name,f){var start;if(this.debugMode){start=performance.now();}var result=f();if(this.debugMode){var vals=result.getValues();var time=util.rightPad(performance.now()-start+"ms",9);var paddedName=util.rightPad(name,25);var rank=result.rank;var size=result.size;var shape=util.rightPad(result.shape.toString(),14);console.log("%c"+paddedName+"\t%c"+time+"\t%c"+rank+"D "+shape+"\t%c"+size,'font-weight:bold','color:red','color:blue','color: orange');this.checkForNaN(vals,result.dtype,name);}return this.track(result);};NDArrayMath.prototype.vectorTimesMatrix=function(v,matrix){util.assert(v.rank===1,"Error in vectorTimesMatrix: first input must be rank 1, but got "+("rank "+v.rank+"."));util.assert(matrix.rank===2,"Error in vectorTimesMatrix: second input must be rank 2, but got "+("rank "+matrix.rank+"."));util.assert(v.size===matrix.shape[0],"Error in vectorTimesMatrix: size of vector ("+v.size+") "+("must match first dimension of matrix ("+matrix.shape[0]+")"));return this.matMul(v.as2D(1,-1),matrix).as1D();};NDArrayMath.prototype.matrixTimesVector=function(matrix,v){util.assert(v.rank===1,"Error in matrixTimesVector: second input must rank 1, but got "+("rank "+v.rank+"."));util.assert(matrix.rank===2,"Error in matrixTimesVector: first input must be a rank 2, but got "+("rank "+matrix.rank+"."));util.assert(v.size===matrix.shape[1],"Error in matrixTimesVector: size of first rank 1 input "+v.size+" "+"must match inner dimension of second rank 2 input, but got "+("shape "+matrix.shape+"."));return this.matMul(matrix,v.as2D(-1,1)).as1D();};NDArrayMath.prototype.dotProduct=function(v1,v2){util.assert(v1.rank===1&&v2.rank===1,"Error in dotProduct: inputs must be rank 1, but got ranks "+(v1.rank+" and "+v2.rank+"."));util.assert(v1.size===v2.size,"Error in dotProduct: size of inputs ("+v1.size+") and ("+(v2.size+") must match."));return this.matMul(v1.as2D(1,-1),v2.as2D(-1,1)).asScalar();};NDArrayMath.prototype.outerProduct=function(v1,v2){util.assert(v1.rank===1&&v2.rank===1,"Error in outerProduct: inputs must be rank 1, but got ranks "+(v1.rank+" and "+v2.rank+"."));return this.matMul(v1.as2D(-1,1),v2.as2D(1,-1));};NDArrayMath.prototype.clone=function(ndarray){var _this=this;return this.executeOp('clone',function(){return _this.cloneInternal(ndarray);});};NDArrayMath.prototype.reshape=function(ndarray,newShape){console.warn('math.reshape() is deprecated. Please call reshape() '+'directly on the ndarray object');return ndarray.reshape(newShape);};NDArrayMath.prototype.slice1D=function(input,begin,size){var _this=this;slice_util.assertParamsValid(input,[begin],[size]);return this.executeOp('slice1D',function(){return _this.slice1DInternal(input,begin,size);});};NDArrayMath.prototype.slice2D=function(input,begin,size){var _this=this;slice_util.assertParamsValid(input,begin,size);return this.executeOp('slice2D',function(){return _this.slice2DInternal(input,begin,size);});};NDArrayMath.prototype.slice3D=function(input,begin,size){var _this=this;slice_util.assertParamsValid(input,begin,size);return this.executeOp('slice3D',function(){return _this.slice3DInternal(input,begin,size);});};NDArrayMath.prototype.slice4D=function(input,begin,size){var _this=this;slice_util.assertParamsValid(input,begin,size);return this.executeOp('slice4D',function(){return _this.slice4DInternal(input,begin,size);});};NDArrayMath.prototype.copy2D=function(source,sourceBegin,sourceSize,dest,destBegin,destSize){var _this=this;util.assert(sourceBegin[0]+sourceSize[0]<=source.shape[0]&&sourceBegin[1]+sourceSize[1]<=source.shape[1],"Error in copy2D: requested source start position "+sourceBegin+" "+("and source size "+sourceSize+" would overflow source NDArray")+("of shape "+source.shape+"."));util.assert(destBegin[0]+destSize[0]<=dest.shape[0]&&destBegin[1]+destSize[1]<=dest.shape[1],"Error in copy2D: requested dest start position "+destBegin+" "+("and source size "+destSize+" would overflow dest NDArray of")+("shape "+dest.shape+"."));copy2d_util.validateShapes(sourceSize,destSize);this.executeOp('copy2D',function(){_this.copy2DInternal(source,sourceBegin,sourceSize,dest,destBegin,destSize);return dest;});};NDArrayMath.prototype.concat1D=function(a,b){var _this=this;concat_util.assertParams(a.shape,b.shape,0);return this.executeOp('concat1D',function(){return _this.concat1DInternal(a,b);});};NDArrayMath.prototype.concat2D=function(a,b,axis){var _this=this;concat_util.assertParams(a.shape,b.shape,axis);return this.executeOp('concat2D',function(){return _this.concat2DInternal(a,b,axis);});};NDArrayMath.prototype.concat3D=function(ndarray1,ndarray2,axis){var _this=this;concat_util.assertParams(ndarray1.shape,ndarray2.shape,axis);return this.executeOp('concat3D',function(){return _this.concat3DInternal(ndarray1,ndarray2,axis);});};NDArrayMath.prototype.concat4D=function(ndarray1,ndarray2,axis){var _this=this;concat_util.assertParams(ndarray1.shape,ndarray2.shape,axis);return this.executeOp('concat4D',function(){return _this.concat4DInternal(ndarray1,ndarray2,axis);});};NDArrayMath.prototype.logSumExp=function(input,axis,keepDims){var _this=this;if(axis===void 0){axis=null;}if(keepDims===void 0){keepDims=false;}var axes=axis_util.parseAxisParam(axis,input.shape);var permutedAxes=axis_util.getPermutedAxes(axes,input.rank);return this.executeOp('logSumExp',function(){if(permutedAxes!=null){input=_this.transpose(input,permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,input.rank);}var res=_this.logSumExpInternal(input,axes);if(keepDims){var newShape=axis_util.expandShapeToKeepDim(res.shape,axes);return res.reshape(newShape);}return res;});};NDArrayMath.prototype.sum=function(input,axis,keepDims){var _this=this;if(axis===void 0){axis=null;}if(keepDims===void 0){keepDims=false;}var axes=axis_util.parseAxisParam(axis,input.shape);var permutedAxes=axis_util.getPermutedAxes(axes,input.rank);return this.executeOp('sum',function(){if(permutedAxes!=null){input=_this.transpose(input,permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,input.rank);}var res=_this.sumInternal(input,axes);if(keepDims){var newShape=axis_util.expandShapeToKeepDim(res.shape,axes);return res.reshape(newShape);}return res;});};NDArrayMath.prototype.mean=function(x,axis,keepDims){var _this=this;if(axis===void 0){axis=null;}if(keepDims===void 0){keepDims=false;}var axes=axis_util.parseAxisParam(axis,x.shape);var shapes=axis_util.computeOutAndReduceShapes(x.shape,axes);var reduceShape=shapes[1];var reduceSize=util.sizeFromShape(reduceShape);return this.executeOp('mean',function(){return _this.scope(function(keep,track){var res=_this.divide(x,track(ndarray_1.Scalar.new(reduceSize)));return _this.sum(res,axis,keepDims);});});};NDArrayMath.prototype.argMin=function(input,axis){var _this=this;if(axis===void 0){axis=null;}var axes=axis_util.parseAxisParam(axis,input.shape);var permutedAxes=axis_util.getPermutedAxes(axes,input.rank);return this.executeOp('argMin',function(){if(permutedAxes!=null){input=_this.transpose(input,permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,input.rank);}return _this.argMinInternal(input,axes);});};NDArrayMath.prototype.argMax=function(input,axis){var _this=this;if(axis===void 0){axis=null;}var axes=axis_util.parseAxisParam(axis,input.shape);var permutedAxes=axis_util.getPermutedAxes(axes,input.rank);return this.executeOp('argMax',function(){if(permutedAxes!=null){input=_this.transpose(input,permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,input.rank);}return _this.argMaxInternal(input,axes);});};NDArrayMath.prototype.argMaxEquals=function(x1,x2){var _this=this;util.assertShapesMatch(x1.shape,x2.shape,'Error in argMaxEquals: ');return this.executeOp('argMaxEquals',function(){return _this.scope(function(){return _this.equal(_this.argMax(x1),_this.argMax(x2));});});};NDArrayMath.prototype.equal=function(x,y){var _this=this;return this.executeOp('equal',function(){return _this.equalInternal(x,y);});};NDArrayMath.prototype.equalStrict=function(x,y){util.assertShapesMatch(x.shape,y.shape,'Error in equalStrict: ');return this.equal(x,y);};NDArrayMath.prototype.topK=function(ndarray,k){var _this=this;util.assert(k<=ndarray.size,"Error in topK: k value ("+k+") must be less than size of input "+("ndarray, got shape "+ndarray.shape+"."));var result;this.executeOp('topK',function(){result=_this.topKInternal(ndarray,k);return result.values;});this.track(result.indices);return result;};NDArrayMath.prototype.min=function(input,axis,keepDims){var _this=this;if(axis===void 0){axis=null;}if(keepDims===void 0){keepDims=false;}var axes=axis_util.parseAxisParam(axis,input.shape);var permutedAxes=axis_util.getPermutedAxes(axes,input.rank);return this.executeOp('min',function(){if(permutedAxes!=null){input=_this.transpose(input,permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,input.rank);}var res=_this.minInternal(input,axes);if(keepDims){var newShape=axis_util.expandShapeToKeepDim(res.shape,axes);return res.reshape(newShape);}return res;});};NDArrayMath.prototype.max=function(input,axis,keepDims){var _this=this;if(axis===void 0){axis=null;}if(keepDims===void 0){keepDims=false;}var axes=axis_util.parseAxisParam(axis,input.shape);var permutedAxes=axis_util.getPermutedAxes(axes,input.rank);return this.executeOp('max',function(){if(permutedAxes!=null){input=_this.transpose(input,permutedAxes);axes=axis_util.getInnerMostAxes(axes.length,input.rank);}var res=_this.maxInternal(input,axes);if(keepDims){var newShape=axis_util.expandShapeToKeepDim(res.shape,axes);return res.reshape(newShape);}return res;});};NDArrayMath.prototype.softmax=function(logits,dim){var _this=this;if(dim===void 0){dim=-1;}if(dim===-1){dim=logits.rank-1;}if(dim!==logits.rank-1){throw Error('Softmax along a non-last dimension is not yet supported. '+("Logits was rank "+logits.rank+" and dim was "+dim));}return this.executeOp('softmax',function(){return _this.scope(function(){var lse=_this.logSumExp(logits,[dim],true);var logResult=_this.subtract(logits,lse);return _this.exp(logResult);});});};NDArrayMath.prototype.switchDim=function(a,newDim){return this.transpose(a,newDim);};NDArrayMath.prototype.transpose=function(a,perm){var _this=this;if(perm==null){perm=a.shape.map(function(s,i){return i;}).reverse();}util.assert(a.rank===perm.length,"Error in transpose: rank of input "+a.rank+" "+("must match length of perm "+perm+"."));return this.executeOp('transpose',function(){return _this.transposeInternal(a,perm);});};NDArrayMath.prototype.scalarPlusArray=function(c,a){util.assert(c.size===1,"Error in scalarPlusArray: first argument must be rank 0, but got "+("rank "+c.rank+"."));return this.add(c,a);};NDArrayMath.prototype.scalarMinusArray=function(c,a){util.assert(c.size===1,"Error in scalarMinusArray: first argument must be rank 0, but got "+("rank "+c.rank+"."));return this.subtract(c,a);};NDArrayMath.prototype.arrayMinusScalar=function(a,c){util.assert(c.size===1,"Error in arrayMinusScalar: second argument must be rank 0, but "+("got rank "+c.rank+"."));return this.subtract(a,c);};NDArrayMath.prototype.neg=function(a){var _this=this;return this.executeOp('neg',function(){return _this.negInternal(a);});};NDArrayMath.prototype.add=function(a,b){var _this=this;broadcast_util.assertAndGetBroadcastShape(a.shape,b.shape);return this.executeOp('add',function(){return _this.addInternal(a,b);});};NDArrayMath.prototype.addStrict=function(a,b){util.assertShapesMatch(a.shape,b.shape,'Error in addStrict: ');return this.add(a,b);};NDArrayMath.prototype.subtract=function(a,b){var _this=this;broadcast_util.assertAndGetBroadcastShape(a.shape,b.shape);return this.executeOp('subtract',function(){return _this.subtractInternal(a,b);});};NDArrayMath.prototype.sub=function(a,b){return this.subtract(a,b);};NDArrayMath.prototype.subStrict=function(a,b){util.assertShapesMatch(a.shape,b.shape,'Error in subStrict: ');return this.subtract(a,b);};NDArrayMath.prototype.multiply=function(a,b){var _this=this;broadcast_util.assertAndGetBroadcastShape(a.shape,b.shape);return this.executeOp('multiply',function(){return _this.multiplyInternal(a,b);});};NDArrayMath.prototype.elementWiseMul=function(a,b){return this.multiplyStrict(a,b);};NDArrayMath.prototype.multiplyStrict=function(a,b){util.assertShapesMatch(a.shape,b.shape,'Error in multiplyStrict: ');return this.multiply(a,b);};NDArrayMath.prototype.divide=function(a,b){var _this=this;broadcast_util.assertAndGetBroadcastShape(a.shape,b.shape);return this.executeOp('divide',function(){return _this.divideInternal(a,b);});};NDArrayMath.prototype.divideStrict=function(a,b){util.assertShapesMatch(a.shape,b.shape,'Error in divideStrict: ');return this.divide(a,b);};NDArrayMath.prototype.scalarDividedByArray=function(c,a){util.assert(c.size===1,"Error in scalarDividedByArray: first argument must be rank 0, but "+("got NDArray of rank "+c.rank+"."));return this.divide(c,a);};NDArrayMath.prototype.arrayDividedByScalar=function(a,c){util.assert(c.size===1,"Error in arrayDividedByScalar: second argument must be rank 0, "+("but got NDArray of rank "+c.rank+"."));return this.divide(a,c);};NDArrayMath.prototype.ceil=function(ndarray){var _this=this;return this.executeOp('ceil',function(){return _this.ceilInternal(ndarray);});};NDArrayMath.prototype.floor=function(ndarray){var _this=this;return this.executeOp('floor',function(){return _this.floorInternal(ndarray);});};NDArrayMath.prototype.exp=function(ndarray){var _this=this;return this.executeOp('exp',function(){return _this.expInternal(ndarray);});};NDArrayMath.prototype.log=function(ndarray){var _this=this;return this.executeOp('log',function(){return _this.logInternal(ndarray);});};NDArrayMath.prototype.sqrt=function(ndarray){var _this=this;return this.executeOp('sqrt',function(){return _this.sqrtInternal(ndarray);});};NDArrayMath.prototype.square=function(x){var _this=this;return this.executeOp('square',function(){return _this.squareInternal(x);});};NDArrayMath.prototype.abs=function(ndarray){var _this=this;return this.executeOp('abs',function(){return _this.absInternal(ndarray);});};NDArrayMath.prototype.clip=function(ndarray,min,max){var _this=this;util.assert(min<=max,"Error in clip: min ("+min+") must be"+("less than or equal to max ("+max+")."));return this.executeOp('clip',function(){return _this.clipInternal(ndarray,min,max);});};NDArrayMath.prototype.relu=function(ndarray){var _this=this;return this.executeOp('relu',function(){return _this.reluInternal(ndarray);});};NDArrayMath.prototype.elu=function(ndarray){var _this=this;return this.executeOp('elu',function(){return _this.eluInternal(ndarray);});};NDArrayMath.prototype.leakyRelu=function(ndarray,alpha){var _this=this;if(alpha===void 0){alpha=0.2;}return this.executeOp('leakyRelu',function(){return _this.leakyReluInternal(ndarray,alpha);});};NDArrayMath.prototype.sigmoid=function(ndarray){var _this=this;return this.executeOp('sigmoid',function(){return _this.sigmoidInternal(ndarray);});};NDArrayMath.prototype.sin=function(ndarray){var _this=this;return this.executeOp('sin',function(){return _this.sinInternal(ndarray);});};NDArrayMath.prototype.cos=function(ndarray){var _this=this;return this.executeOp('cos',function(){return _this.cosInternal(ndarray);});};NDArrayMath.prototype.tan=function(ndarray){var _this=this;return this.executeOp('tan',function(){return _this.tanInternal(ndarray);});};NDArrayMath.prototype.asin=function(ndarray){var _this=this;return this.executeOp('asin',function(){return _this.asinInternal(ndarray);});};NDArrayMath.prototype.acos=function(ndarray){var _this=this;return this.executeOp('acos',function(){return _this.acosInternal(ndarray);});};NDArrayMath.prototype.atan=function(ndarray){var _this=this;return this.executeOp('atan',function(){return _this.atanInternal(ndarray);});};NDArrayMath.prototype.sinh=function(ndarray){var _this=this;return this.executeOp('sinh',function(){return _this.sinhInternal(ndarray);});};NDArrayMath.prototype.cosh=function(ndarray){var _this=this;return this.executeOp('cosh',function(){return _this.coshInternal(ndarray);});};NDArrayMath.prototype.tanh=function(ndarray){var _this=this;return this.executeOp('tanh',function(){return _this.tanhInternal(ndarray);});};NDArrayMath.prototype.step=function(ndarray){var _this=this;return this.executeOp('step',function(){return _this.stepInternal(ndarray);});};NDArrayMath.prototype.scaledArrayAdd=function(c1,a,c2,b){var _this=this;util.assert(c1.size===1,"Error in scaledArrayAdd: first argument must rank 0, but got "+(" rank "+c1.rank+"."));util.assert(c2.size===1,"Error in scaledArrayAdd: third argument must be rank 0, but got "+("NDArray of rank "+c2.rank+"."));util.assertShapesMatch(a.shape,b.shape,'Error in scaledArrayAdd: ');return this.executeOp('scaledArrayAdd',function(){return _this.scaledArrayAddInternal(c1,a,c2,b);});};NDArrayMath.prototype.scalarTimesArray=function(c,a){util.assert(c.size===1,"Error in arrayDividedByScalar: first argument must be rank 0, but "+("got rank "+c.rank+"."));return this.multiply(c,a);};NDArrayMath.prototype.elementWiseMulBroadcast=function(a,b){util.assert(a.rank===2,"Error in elementWiseMulBroadcast: first argument must be "+("rank 2, but got rank "+a.rank+"."));util.assert(b.rank===2,"Error in elementWiseMulBroadcast: second argument must be "+("rank 2, but got rank "+b.rank+"."));return this.multiply(a,b);};NDArrayMath.prototype.conv2d=function(x,filter,bias,strides,pad){var _this=this;util.assert(x.rank===3,"Error in conv2d: x must be rank 3, but got rank "+x.rank+".");util.assert(filter.rank===4,"Error in conv2d: filter must be rank 4, but got rank "+(filter.rank+"."));if(bias!=null){util.assert(bias.rank===1,"Error in conv2d: bias must be rank 1, but got rank "+(bias.rank+"."));}util.assert(x.shape[2]===filter.shape[2],"Error in conv2d: depth of input ("+x.shape[2]+") must match  "+("input depth for filter "+filter.shape[2]+"."));var filterHeight=filter.shape[0];var filterWidth=filter.shape[1];var outDepth=filter.shape[3];var _a=parseTupleParam(strides),strideHeight=_a[0],strideWidth=_a[1];var convInfo=conv_util.computeConvInfo(x.shape,filterHeight,filterWidth,outDepth,strideHeight,strideWidth,pad);return this.executeOp('conv2d',function(){return _this.conv2dInternal(x,filter,bias,convInfo);});};NDArrayMath.prototype.conv2dBackProp=function(x,dy,filter,strides,pad){var dw=this.conv2dDerFilter(x,dy,filter.shape,strides,pad);var db=this.conv2dDerBias(dy);var dx=this.conv2dDerInput(x.shape,dy,filter,strides,pad);return{db:db,dw:dw,dx:dx};};NDArrayMath.prototype.conv2dDerInput=function(inShape,dy,filter,strides,pad){var _this=this;var inDepth=inShape[2];var outDepth=dy.shape[2];util.assert(inShape.length===3,"Error in conv2dDerInput: x must be rank 3, but got rank "+(inShape.length+"."));util.assert(dy.rank===3,"Error in conv2dDerInput: dy must be rank 3, but got "+("rank "+dy.rank));util.assert(filter.rank===4,"Error in conv2dDerInput: filter must be rank 4, but got "+("rank "+filter.rank));util.assert(inDepth===filter.shape[2],"Error in conv2dDerInput: depth of input ("+inDepth+") must "+("match input depth for filter "+filter.shape[2]+"."));util.assert(outDepth===filter.shape[3],"Error in conv2dDerInput: depth of output ("+outDepth+") must"+("match output depth for filter "+filter.shape[3]+"."));var filterHeight=filter.shape[0];var filterWidth=filter.shape[1];var _a=parseTupleParam(strides),strideHeight=_a[0],strideWidth=_a[1];var convInfo=conv_util.computeConvInfo(inShape,filterHeight,filterWidth,outDepth,strideHeight,strideWidth,pad);return this.executeOp('conv2dDerInput',function(){return _this.conv2dDerInputInternal(dy,filter,convInfo);});};NDArrayMath.prototype.conv2dDerBias=function(dy){return this.track(this.conv2dDerBiasInternal(dy));};NDArrayMath.prototype.conv2dDerFilter=function(x,dy,filterSize,strides,pad){util.assert(x.rank===3,"Error in conv2dDerFilter: x must be rank 3, but got shape "+(x.shape+"."));util.assert(dy.rank===3,"Error in conv2dDerFilter: dy must be rank 3, but got shape "+(dy.shape+"."));util.assert(filterSize.length===4,"Error in conv2dDerFilter: filterSize must be length 4, but got "+(filterSize+"."));util.assert(x.shape[2]===filterSize[2],"Error in conv2dDerFilter: depth of x "+x.shape[2]+") must "+("match input depth in filter ("+filterSize[2]+"."));util.assert(dy.shape[2]===filterSize[3],"Error in conv2dDerFilter: depth of dy ("+dy.shape[2]+") must "+("match output depth for filter ("+filterSize[3]+")."));var filterHeight=filterSize[0];var filterWidth=filterSize[1];var outDepth=filterSize[3];var _a=parseTupleParam(strides),strideHeight=_a[0],strideWidth=_a[1];var convInfo=conv_util.computeConvInfo(x.shape,filterHeight,filterWidth,outDepth,strideHeight,strideWidth,pad);return this.track(this.conv2dDerFilterInternal(x,dy,convInfo));};NDArrayMath.prototype.conv2dTranspose=function(x,filter,outputShape,strides,pad){return this.conv2dDerInput(outputShape,x,filter,strides,pad);};NDArrayMath.prototype.maxPool=function(x,filterSize,strides,pad){var _this=this;util.assert(x.rank===3,"Error in maxPool: x must be rank 3 but got rank "+x.rank+".");var _a=parseTupleParam(filterSize),filterHeight=_a[0],filterWidth=_a[1];var outDepth=x.shape[2];var _b=parseTupleParam(strides),strideHeight=_b[0],strideWidth=_b[1];var convInfo=conv_util.computeConvInfo(x.shape,filterHeight,filterWidth,outDepth,strideHeight,strideWidth,pad);return this.executeOp('maxPool',function(){return _this.maxPoolInternal(x,convInfo);});};NDArrayMath.prototype.maxPoolBackprop=function(dy,x,filterSize,strides,pad){var _this=this;util.assert(dy.rank===3,"Error in maxPoolBackprop: dy must be rank 3 but got rank "+(dy.rank+"."));util.assert(x.rank===3,"Error in maxPoolBackprop: x must be rank 3 but got rank "+(x.rank+"."));var _a=parseTupleParam(filterSize),filterHeight=_a[0],filterWidth=_a[1];var outDepth=x.shape[2];var _b=parseTupleParam(strides),strideHeight=_b[0],strideWidth=_b[1];var convInfo=conv_util.computeConvInfo(x.shape,filterHeight,filterWidth,outDepth,strideHeight,strideWidth,pad);return this.executeOp('maxPoolBackprop',function(){return _this.maxPoolBackpropInternal(dy,x,convInfo);});};NDArrayMath.prototype.minPool=function(x,filterSize,strides,pad){var _this=this;util.assert(x.rank===3,"Error in minPool: x must be rank 3 but got rank "+x.rank+".");var _a=parseTupleParam(filterSize),filterHeight=_a[0],filterWidth=_a[1];var outDepth=x.shape[2];var _b=parseTupleParam(strides),strideHeight=_b[0],strideWidth=_b[1];var convInfo=conv_util.computeConvInfo(x.shape,filterHeight,filterWidth,outDepth,strideHeight,strideWidth,pad);return this.executeOp('minPool',function(){return _this.minPoolInternal(x,convInfo);});};NDArrayMath.prototype.avgPool=function(x,filterSize,strides,pad){var _this=this;util.assert(x.rank===3,"Error in avgPool: x must be rank 3 but got rank "+x.rank+".");var _a=parseTupleParam(filterSize),filterHeight=_a[0],filterWidth=_a[1];var outDepth=x.shape[2];var _b=parseTupleParam(strides),strideHeight=_b[0],strideWidth=_b[1];var convInfo=conv_util.computeConvInfo(x.shape,filterHeight,filterWidth,outDepth,strideHeight,strideWidth,pad);return this.executeOp('avgPool',function(){return _this.avgPoolInternal(x,convInfo);});};NDArrayMath.prototype.resizeBilinear3D=function(x,newShape2D,alignCorners){var _this=this;if(alignCorners===void 0){alignCorners=false;}util.assert(x.rank===3,"Error in resizeBilinear3D: x must be rank 3 but got rank "+x.rank+".");util.assert(newShape2D.length===2,"Error in resizeBilinear3D: new shape must 2D, but got shape "+(newShape2D+"."));return this.executeOp('resizeBilinear3D',function(){return _this.resizeBilinear3DInternal(x,newShape2D,alignCorners);});};NDArrayMath.prototype.batchNormalization3D=function(x,mean,variance,varianceEpsilon,scale,offset){var _this=this;if(varianceEpsilon===void 0){varianceEpsilon=.001;}util.assert(x.rank===3,"Error in batchNormalization3D: x must be rank 3 but got rank "+(x.rank+"."));util.assert(mean.rank===3||mean.rank===1,"Error in batchNormalization3D: mean must be rank 3 or rank 1 but "+("got rank "+mean.rank+"."));util.assert(variance.rank===3||variance.rank===1,"Error in batchNormalization3D: variance must be rank 3 or rank 1 "+("but got rank "+variance.rank+"."));if(scale!=null){util.assert(scale.rank===3||scale.rank===1,"Error in batchNormalization3D: scale must be rank 3 or rank 1 "+("but got rank "+scale.rank+"."));}if(offset!=null){util.assert(offset.rank===3||offset.rank===1,"Error in batchNormalization3D: offset must be rank 3 or rank 1 "+("but got rank "+offset.rank+"."));}return this.executeOp('batchNorm3D',function(){return _this.batchNormalization3DInternal(x,mean,variance,varianceEpsilon,scale,offset);});};NDArrayMath.prototype.multiRNNCell=function(lstmCells,data,c,h){var res=this.scope(function(){var input=data;var newStates=[];for(var i=0;i<lstmCells.length;i++){var output=lstmCells[i](input,c[i],h[i]);newStates.push(output[0]);newStates.push(output[1]);input=output[1];}return newStates;});var newC=[];var newH=[];for(var i=0;i<res.length;i+=2){newC.push(res[i]);newH.push(res[i+1]);}return[newC,newH];};NDArrayMath.prototype.basicLSTMCell=function(forgetBias,lstmKernel,lstmBias,data,c,h){var _this=this;var res=this.scope(function(){var combined=_this.concat2D(data,h,1);var weighted=_this.matMul(combined,lstmKernel);var res=_this.add(weighted,lstmBias);var batchSize=res.shape[0];var sliceCols=res.shape[1]/4;var sliceSize=[batchSize,sliceCols];var i=_this.slice2D(res,[0,0],sliceSize);var j=_this.slice2D(res,[0,sliceCols],sliceSize);var f=_this.slice2D(res,[0,sliceCols*2],sliceSize);var o=_this.slice2D(res,[0,sliceCols*3],sliceSize);var newC=_this.addStrict(_this.multiplyStrict(c,_this.sigmoid(_this.scalarPlusArray(forgetBias,f))),_this.multiplyStrict(_this.sigmoid(i),_this.tanh(j)));var newH=_this.multiplyStrict(_this.tanh(newC),_this.sigmoid(o));return[newC,newH];});return[res[0],res[1]];};NDArrayMath.prototype.multinomial=function(probabilities,numSamples,seed){var _this=this;var numOutcomes=probabilities.size;if(numOutcomes<2){throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+(numOutcomes+"."));}if(probabilities.rank>2){throw new Error("Rank of probabilities must be 1 or 2, but is "+probabilities.rank);}seed=seed||Math.random();var origRank=probabilities.rank;if(probabilities.rank===1){probabilities=probabilities.as2D(1,-1);}return this.executeOp('multinomial',function(){var res=_this.multinomialInternal(probabilities,numSamples,seed);if(origRank===1){return res.as1D();}return res;});};NDArrayMath.prototype.oneHot=function(indices,depth,onValue,offValue){var _this=this;if(onValue===void 0){onValue=1;}if(offValue===void 0){offValue=0;}if(depth<2){throw new Error("Error in oneHot: depth must be >=2, but it is "+depth);}return this.executeOp('oneHot',function(){return _this.oneHotInternal(indices,depth,onValue,offValue);});};NDArrayMath.prototype.moments=function(x,axis,keepDims){var _this=this;if(axis===void 0){axis=null;}if(keepDims===void 0){keepDims=false;}var axes=axis_util.parseAxisParam(axis,x.shape);var result=this.scope(function(){var mean=_this.mean(x,axes,keepDims);var keepDimsShape=mean.shape;if(!keepDims){keepDimsShape=axis_util.expandShapeToKeepDim(mean.shape,axes);}var devSquared=_this.square(_this.subtract(x,mean.reshape(keepDimsShape)));var variance=_this.mean(devSquared,axes,keepDims);return{mean:mean,variance:variance};});return result;};return NDArrayMath;}();exports.NDArrayMath=NDArrayMath;var MatrixOrientation;(function(MatrixOrientation){MatrixOrientation[MatrixOrientation["REGULAR"]=0]="REGULAR";MatrixOrientation[MatrixOrientation["TRANSPOSED"]=1]="TRANSPOSED";})(MatrixOrientation=exports.MatrixOrientation||(exports.MatrixOrientation={}));function parseTupleParam(param){return typeof param==='number'?[param,param]:param;}},{"../util":88,"./axis_util":47,"./broadcast_util":48,"./concat_util":49,"./conv_util":50,"./copy2d_util":51,"./ndarray":56,"./slice_util":57}],54:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var seedrandom=require("seedrandom");var util=require("../util");var axis_util=require("./axis_util");var broadcast_util=require("./broadcast_util");var concat_util=require("./concat_util");var conv_util=require("./conv_util");var copy2D_util=require("./copy2d_util");var math_1=require("./math");var ndarray_1=require("./ndarray");var NDArrayMathCPU=function(_super){__extends(NDArrayMathCPU,_super);function NDArrayMathCPU(safeMode){if(safeMode===void 0){safeMode=false;}return _super.call(this,safeMode)||this;}NDArrayMathCPU.prototype.cloneInternal=function(ndarray){return ndarray_1.NDArray.make(ndarray.shape,{values:new Float32Array(ndarray.getValues())});};NDArrayMathCPU.prototype.slice1DInternal=function(input,begin,size){var newVals=input.getValues().slice(begin,begin+size);return ndarray_1.Array1D.new(newVals);};NDArrayMathCPU.prototype.slice2DInternal=function(input,begin,size){var result=ndarray_1.Array2D.zeros(size);var startI=begin[0],startJ=begin[1];for(var i=0;i<size[0];++i){for(var j=0;j<size[1];++j){var val=input.get(i+startI,j+startJ);result.set(val,i,j);}}return result;};NDArrayMathCPU.prototype.slice3DInternal=function(input,begin,size){var result=ndarray_1.Array3D.zeros(size);var startI=begin[0],startJ=begin[1],startK=begin[2];for(var i=0;i<size[0];++i){for(var j=0;j<size[1];++j){for(var k=0;k<size[2];++k){var val=input.get(i+startI,j+startJ,k+startK);result.set(val,i,j,k);}}}return result;};NDArrayMathCPU.prototype.slice4DInternal=function(input,begin,size){var result=ndarray_1.Array4D.zeros(size);var startI=begin[0],startJ=begin[1],startK=begin[2],startL=begin[3];for(var i=0;i<size[0];++i){for(var j=0;j<size[1];++j){for(var k=0;k<size[2];++k){for(var l=0;l<size[3];++l){var val=input.get(i+startI,j+startJ,k+startK,l+startL);result.set(val,i,j,k,l);}}}}return result;};NDArrayMathCPU.prototype.copy2DInternal=function(source,sourceBeginRowCol,sourceSizeRowCol,dest,destBeginRowCol,destSizeRowCol){copy2D_util.validateShapes(sourceSizeRowCol,destSizeRowCol);var srcValues=source.getValues();var dstValues=dest.getValues();var n=sourceSizeRowCol[0]*sourceSizeRowCol[1];for(var i=0;i<n;++i){var srcRow=sourceBeginRowCol[0]+Math.floor(i/sourceSizeRowCol[1]);var srcCol=sourceBeginRowCol[1]+i%sourceSizeRowCol[1];var srcOff=srcRow*source.shape[1]+srcCol;var dstRow=destBeginRowCol[0]+Math.floor(i/destSizeRowCol[1]);var dstCol=destBeginRowCol[1]+i%destSizeRowCol[1];var dstOff=dstRow*dest.shape[1]+dstCol;dstValues[dstOff]=srcValues[srcOff];}};NDArrayMathCPU.prototype.concat1DInternal=function(a,b){var outShape=concat_util.computeOutShape(a.shape,b.shape,0);var result=ndarray_1.Array1D.zeros(outShape);var aVals=a.getValues();var bVals=b.getValues();var vals=result.getValues();vals.set(aVals,0);vals.set(bVals,a.size);return result;};NDArrayMathCPU.prototype.concat2DInternal=function(a,b,axis){var outShape=concat_util.computeOutShape(a.shape,b.shape,axis);var result=ndarray_1.Array2D.zeros(outShape);if(axis===0){var aVals=a.getValues();var bVals=b.getValues();var vals=result.getValues();vals.set(aVals,0);vals.set(bVals,a.size);return result;}for(var i=0;i<outShape[0];++i){for(var j=0;j<outShape[1];++j){var index=[i,j];var value=void 0;if(index[axis]<a.shape[axis]){value=a.get(i,j);}else{index[axis]-=a.shape[axis];var i2=index[0],j2=index[1];value=b.get(i2,j2);}result.set(value,i,j);}}return result;};NDArrayMathCPU.prototype.concat3DInternal=function(a,b,axis){var outShape=concat_util.computeOutShape(a.shape,b.shape,axis);var result=ndarray_1.Array3D.zeros(outShape);if(axis===0){var aVals=a.getValues();var bVals=b.getValues();var vals=result.getValues();vals.set(aVals,0);vals.set(bVals,a.size);return result;}for(var i=0;i<outShape[0];++i){for(var j=0;j<outShape[1];++j){for(var k=0;k<outShape[2];++k){var index=[i,j,k];var value=void 0;if(index[axis]<a.shape[axis]){value=a.get(i,j,k);}else{index[axis]-=a.shape[axis];var i2=index[0],j2=index[1],k2=index[2];value=b.get(i2,j2,k2);}result.set(value,i,j,k);}}}return result;};NDArrayMathCPU.prototype.concat4DInternal=function(a,b,axis){var outShape=concat_util.computeOutShape(a.shape,b.shape,axis);var result=ndarray_1.Array4D.zeros(outShape);if(axis===0){var aVals=a.getValues();var bVals=b.getValues();var vals=result.getValues();vals.set(aVals,0);vals.set(bVals,a.size);return result;}for(var i=0;i<outShape[0];++i){for(var j=0;j<outShape[1];++j){for(var k=0;k<outShape[2];++k){for(var l=0;l<outShape[3];++l){var index=[i,j,k,l];var value=void 0;if(index[axis]<a.shape[axis]){value=a.get(i,j,k,l);}else{index[axis]-=a.shape[axis];var i2=index[0],j2=index[1],k2=index[2],l2=index[3];value=b.get(i2,j2,k2,l2);}result.set(value,i,j,k,l);}}}}return result;};NDArrayMathCPU.prototype.scaledArrayAddInternal=function(c1,a,c2,b){var c1Val=c1.get();var c2Val=c2.get();return this.broadcastedBinaryOp(a,b,'float32',function(aVal,bVal){return c1Val*aVal+c2Val*bVal;});};NDArrayMathCPU.prototype.negInternal=function(a){return this.scalarTimesArray(ndarray_1.Scalar.NEG_ONE,a);};NDArrayMathCPU.prototype.addInternal=function(a,b){return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE,a,ndarray_1.Scalar.ONE,b);};NDArrayMathCPU.prototype.subtractInternal=function(a,b){return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE,a,ndarray_1.Scalar.NEG_ONE,b);};NDArrayMathCPU.prototype.matMulInternal=function(a,b,aOrientation,bOrientation){if(aOrientation===void 0){aOrientation=math_1.MatrixOrientation.REGULAR;}if(bOrientation===void 0){bOrientation=math_1.MatrixOrientation.REGULAR;}var sharedDim=aOrientation===math_1.MatrixOrientation.REGULAR?a.shape[1]:a.shape[0];var leftDim=aOrientation===math_1.MatrixOrientation.REGULAR?a.shape[0]:a.shape[1];var rightDim=bOrientation===math_1.MatrixOrientation.REGULAR?b.shape[1]:b.shape[0];var normalGetter=function normalGetter(matrix,i,j){return matrix.get(i,j);};var transposedGetter=function transposedGetter(matrix,i,j){return matrix.get(j,i);};var aGetter=aOrientation===math_1.MatrixOrientation.REGULAR?normalGetter:transposedGetter;var bGetter=bOrientation===math_1.MatrixOrientation.REGULAR?normalGetter:transposedGetter;var values=new Float32Array(leftDim*rightDim);var index=0;for(var i=0;i<leftDim;++i){for(var j=0;j<rightDim;++j){var sum=0;for(var k=0;k<sharedDim;++k){sum+=aGetter(a,i,k)*bGetter(b,k,j);}values[index++]=sum;}}return ndarray_1.Array2D.new([leftDim,rightDim],values);};NDArrayMathCPU.prototype.multiplyInternal=function(a,b){var newShape=broadcast_util.assertAndGetBroadcastShape(a.shape,b.shape);var newValues=new Float32Array(util.sizeFromShape(newShape));var aValues=a.getValues();var bValues=b.getValues();for(var i=0;i<newValues.length;++i){newValues[i]=aValues[i%a.size]*bValues[i%b.size];}return ndarray_1.NDArray.make(newShape,{values:newValues});};NDArrayMathCPU.prototype.divideInternal=function(a,b){var newShape=broadcast_util.assertAndGetBroadcastShape(a.shape,b.shape);var newValues=new Float32Array(util.sizeFromShape(newShape));var aValues=a.getValues();var bValues=b.getValues();for(var i=0;i<newValues.length;++i){newValues[i]=aValues[i%a.size]/bValues[i%b.size];}return ndarray_1.NDArray.make(newShape,{values:newValues},'float32');};NDArrayMathCPU.prototype.sumInternal=function(input,axes){axis_util.assertAxesAreInnerMostDims('sum',axes,input.rank);var _a=axis_util.computeOutAndReduceShapes(input.shape,axes),outShape=_a[0],reduceShape=_a[1];var resultDtype=math_1.SumTypesMap[input.dtype];var result=ndarray_1.NDArray.zeros(outShape,resultDtype);var reduceSize=util.sizeFromShape(reduceShape);var vals=result.getValues();var aVals=input.getValues();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var sum=0;for(var j=0;j<reduceSize;++j){sum+=aVals[offset+j];}vals[i]=sum;}return result;};NDArrayMathCPU.prototype.argMinInternal=function(input,axes){axis_util.assertAxesAreInnerMostDims('argMax',axes,input.rank);var _a=axis_util.computeOutAndReduceShapes(input.shape,axes),outShape=_a[0],reduceShape=_a[1];var result=ndarray_1.NDArray.zeros(outShape,'int32');var reduceSize=util.sizeFromShape(reduceShape);var vals=result.getValues();var aVals=input.getValues();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var min=aVals[offset];var minIndex=0;for(var j=0;j<reduceSize;++j){var value=aVals[offset+j];if(isNaN(value)){minIndex=util.NAN_INT32;break;}if(value<min){min=value;minIndex=j;}}vals[i]=minIndex;}return result;};NDArrayMathCPU.prototype.argMaxInternal=function(input,axes){axis_util.assertAxesAreInnerMostDims('argMax',axes,input.rank);var _a=axis_util.computeOutAndReduceShapes(input.shape,axes),outShape=_a[0],reduceShape=_a[1];var result=ndarray_1.NDArray.zeros(outShape,'int32');var reduceSize=util.sizeFromShape(reduceShape);var vals=result.getValues();var aVals=input.getValues();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var max=aVals[offset];var maxIndex=0;for(var j=0;j<reduceSize;++j){var value=aVals[offset+j];if(isNaN(value)){maxIndex=util.NAN_INT32;break;}if(value>max){max=value;maxIndex=j;}}vals[i]=maxIndex;}return result;};NDArrayMathCPU.prototype.equalInternal=function(a,b){return this.broadcastedBinaryOp(a,b,'bool',function(aVal,bVal){if(util.isValNaN(aVal,a.dtype)||util.isValNaN(bVal,b.dtype)){return util.getNaN('bool');}else{return aVal===bVal?1:0;}});};NDArrayMathCPU.prototype.topKInternal=function(ndarray,k){var values=ndarray.getValues();var valuesAndIndices=[];for(var i=0;i<values.length;i++){valuesAndIndices.push({value:values[i],index:i});}valuesAndIndices.sort(function(a,b){return b.value-a.value;});var topkValues=new Float32Array(k);var topkIndices=new Float32Array(k);for(var i=0;i<k;i++){topkValues[i]=valuesAndIndices[i].value;topkIndices[i]=valuesAndIndices[i].index;}return{values:ndarray_1.Array1D.new(topkValues),indices:ndarray_1.Array1D.new(topkIndices)};};NDArrayMathCPU.prototype.minInternal=function(input,axes){axis_util.assertAxesAreInnerMostDims('min',axes,input.rank);var _a=axis_util.computeOutAndReduceShapes(input.shape,axes),outShape=_a[0],reduceShape=_a[1];var result=ndarray_1.NDArray.zeros(outShape,input.dtype);var reduceSize=util.sizeFromShape(reduceShape);var vals=result.getValues();var aVals=input.getValues();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var min=aVals[0];for(var j=0;j<reduceSize;++j){var value=aVals[offset+j];if(isNaN(value)){min=Number.NaN;break;}if(value<min){min=value;}}vals[i]=min;}return result;};NDArrayMathCPU.prototype.maxInternal=function(input,axes){axis_util.assertAxesAreInnerMostDims('max',axes,input.rank);var _a=axis_util.computeOutAndReduceShapes(input.shape,axes),outShape=_a[0],reduceShape=_a[1];var result=ndarray_1.NDArray.zeros(outShape,input.dtype);var reduceSize=util.sizeFromShape(reduceShape);var vals=result.getValues();var aVals=input.getValues();for(var i=0;i<vals.length;++i){var offset=i*reduceSize;var max=aVals[offset];for(var j=0;j<reduceSize;++j){var value=aVals[offset+j];if(isNaN(value)){max=Number.NaN;break;}if(value>max){max=value;}}vals[i]=max;}return result;};NDArrayMathCPU.prototype.ceilInternal=function(ndarray){var values=ndarray.getValues();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){newValues[i]=Math.ceil(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:newValues});};NDArrayMathCPU.prototype.floorInternal=function(ndarray){var values=ndarray.getValues();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){newValues[i]=Math.floor(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:newValues});};NDArrayMathCPU.prototype.expInternal=function(ndarray){var values=ndarray.getValues();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){newValues[i]=Math.exp(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:newValues});};NDArrayMathCPU.prototype.logInternal=function(ndarray){var values=ndarray.getValues();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){var value=values[i];newValues[i]=Math.log(value);}return ndarray_1.NDArray.make(ndarray.shape,{values:newValues});};NDArrayMathCPU.prototype.sqrtInternal=function(ndarray){var values=ndarray.getValues();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){var value=values[i];newValues[i]=Math.sqrt(value);}return ndarray_1.NDArray.make(ndarray.shape,{values:newValues});};NDArrayMathCPU.prototype.squareInternal=function(x){var values=x.getValues();var newValues=new Float32Array(values.length);for(var i=0;i<values.length;++i){var value=values[i];newValues[i]=value*value;}return ndarray_1.NDArray.make(x.shape,{values:newValues});};NDArrayMathCPU.prototype.logSumExpInternal=function(input,axes){axis_util.assertAxesAreInnerMostDims('logSumExp',axes,input.rank);var xMax=this.max(input,axes,true);var a=this.subtract(input,xMax);var b=this.exp(a);var c=this.sum(b,axes);var d=this.log(c);var result=this.add(xMax.reshape(d.shape),d);return result;};NDArrayMathCPU.prototype.reluInternal=function(input){var res=ndarray_1.NDArray.zeros(input.shape,input.dtype);var resVals=res.getValues();var inVals=input.getValues();for(var i=0;i<inVals.length;++i){var val=inVals[i];if(util.isValNaN(val,input.dtype)){resVals[i]=util.getNaN(res.dtype);}else{resVals[i]=Math.max(0,inVals[i]);}}return res;};NDArrayMathCPU.prototype.eluInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.dataSync();for(var i=0;i<values.length;++i){var v=values[i];if(v>=0){resultValues[i]=v;}else{resultValues[i]=Math.exp(v)-1;}}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.leakyReluInternal=function(ndarray,alpha){var resultValues=new Float32Array(ndarray.size);var values=ndarray.dataSync();for(var i=0;i<values.length;i++){var v=values[i];if(v>=0){resultValues[i]=v;}else{resultValues[i]=alpha*v;}}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.clipInternal=function(ndarray,min,max){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=Math.min(max,Math.max(min,values[i]));}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.absInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=Math.abs(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.sigmoidInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=1/(1+Math.exp(-values[i]));}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.sinInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=Math.sin(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.cosInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=Math.cos(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.tanInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=Math.tan(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.asinInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=Math.asin(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.acosInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=Math.acos(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.atanInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=Math.atan(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.sinhInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=Math.sinh(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.coshInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=Math.cosh(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.tanhInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){resultValues[i]=util.tanh(values[i]);}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.stepInternal=function(ndarray){var resultValues=new Float32Array(ndarray.size);var values=ndarray.getValues();for(var i=0;i<values.length;++i){var value=values[i];resultValues[i]=value>0?1:value<0?0:value;}return ndarray_1.NDArray.make(ndarray.shape,{values:resultValues});};NDArrayMathCPU.prototype.conv2dInternal=function(x,filter,bias,convInfo){var _a=x.shape,xRows=_a[0],xCols=_a[1],inputDepth=_a[2];var filterHeight=filter.shape[0];var filterWidth=filter.shape[1];var outDepth=filter.shape[3];var padLeft=convInfo.padInfo.left;var padTop=convInfo.padInfo.top;var y=ndarray_1.Array3D.zeros(convInfo.outShape);for(var d2=0;d2<outDepth;++d2){for(var yR=0;yR<y.shape[0];++yR){var xRCorner=yR*convInfo.strideHeight-padLeft;var xRMin=Math.max(0,xRCorner);var xRMax=Math.min(xRows,filterHeight+xRCorner);for(var yC=0;yC<y.shape[1];++yC){var xCCorner=yC*convInfo.strideWidth-padTop;var xCMin=Math.max(0,xCCorner);var xCMax=Math.min(xCols,filterWidth+xCCorner);var dotProd=0;for(var xR=xRMin;xR<xRMax;++xR){var wR=xR-xRCorner;for(var xC=xCMin;xC<xCMax;++xC){var wC=xC-xCCorner;for(var d1=0;d1<inputDepth;++d1){var pixel=x.get(xR,xC,d1);var weight=filter.get(wR,wC,d1,d2);dotProd+=pixel*weight;}}}var biasVal=bias!=null?bias.get(d2):0;y.set(dotProd+biasVal,yR,yC,d2);}}}return y;};NDArrayMathCPU.prototype.conv2dDerInputInternal=function(dy,filter,convInfo){var inDepth=filter.shape[2];var outDepth=filter.shape[3];var yRows=dy.shape[0];var yCols=dy.shape[1];var filterHeight=filter.shape[0];var filterWidth=filter.shape[1];var topPad=filterHeight-1-convInfo.padInfo.top;var leftPad=filterWidth-1-convInfo.padInfo.left;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var dx=ndarray_1.Array3D.zeros(convInfo.inShape);for(var d1=0;d1<inDepth;++d1){for(var xR=0;xR<dx.shape[0];++xR){var xRCorner=xR-leftPad;var xRMin=Math.max(0,Math.ceil(xRCorner/strideHeight));var yRMax=Math.min(yRows,(filterHeight+xRCorner)/strideHeight);for(var xC=0;xC<dx.shape[1];++xC){var xCCorner=xC-topPad;var xCMin=Math.max(0,Math.ceil(xCCorner/strideWidth));var yCMax=Math.min(yCols,(filterWidth+xCCorner)/strideWidth);var dotProd=0;for(var yR=xRMin;yR<yRMax;++yR){var wR=yR*strideHeight-xRCorner;for(var yC=xCMin;yC<yCMax;++yC){var wC=yC*strideWidth-xCCorner;for(var d2=0;d2<outDepth;++d2){var pixel=dy.get(yR,yC,d2);var weight=filter.get(filterHeight-1-wR,filterWidth-1-wC,d1,d2);dotProd+=pixel*weight;}}}dx.set(dotProd,xR,xC,d1);}}}return dx;};NDArrayMathCPU.prototype.conv2dDerFilterInternal=function(x,dY,convInfo){var inputDepth=x.shape[2];var outputDepth=dY.shape[2];var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var weightsShape=conv_util.computeWeightsShape4D(inputDepth,outputDepth,filterHeight,filterWidth);var dW=ndarray_1.Array4D.zeros(weightsShape);var yNumRows=dY.shape[0];var yNumCols=dY.shape[1];var xNumRows=x.shape[0];var xNumCols=x.shape[1];var leftPad=convInfo.padInfo.left;var topPad=convInfo.padInfo.top;for(var wR=0;wR<filterHeight;++wR){var yRMin=Math.max(0,Math.ceil((topPad-wR)/strideHeight));var yRMax=Math.min(yNumRows,(xNumRows+topPad-wR)/strideHeight);for(var wC=0;wC<filterWidth;++wC){var yCMin=Math.max(0,Math.ceil((leftPad-wC)/strideWidth));var yCMax=Math.min(yNumCols,(xNumCols+leftPad-wC)/strideWidth);for(var d1=0;d1<inputDepth;++d1){for(var d2=0;d2<outputDepth;++d2){var dotProd=0;for(var yR=yRMin;yR<yRMax;++yR){var xR=wR+yR*strideHeight-topPad;for(var yC=yCMin;yC<yCMax;++yC){var xC=wC+yC*strideWidth-leftPad;dotProd+=x.get(xR,xC,d1)*dY.get(yR,yC,d2);}}dW.set(dotProd,wR,wC,d1,d2);}}}}return dW;};NDArrayMathCPU.prototype.conv2dDerBiasInternal=function(dY){var outputDepth=dY.shape[2];var numRows=dY.shape[0];var numCols=dY.shape[1];var values=new Float32Array(outputDepth);for(var d2=0;d2<outputDepth;++d2){var sum=0;for(var r=0;r<numRows;++r){for(var c=0;c<numCols;++c){sum+=dY.get(r,c,d2);}}values[d2]=sum;}return ndarray_1.Array1D.new(values);};NDArrayMathCPU.prototype.transposeInternal=function(a,perm){var newShape=new Array(a.rank);for(var i=0;i<newShape.length;i++){newShape[i]=a.shape[perm[i]];}var resultValues=new Float32Array(a.size);var values=a.getValues();var result=ndarray_1.NDArray.make(newShape,{values:resultValues});for(var i=0;i<a.size;++i){var loc=a.indexToLoc(i);var newLoc=new Array(loc.length);for(var i_1=0;i_1<newLoc.length;i_1++){newLoc[i_1]=loc[perm[i_1]];}var newIndex=result.locToIndex(newLoc);resultValues[newIndex]=values[i];}return result;};NDArrayMathCPU.prototype.pool=function(x,convInfo,poolType){var _a=x.shape,xRows=_a[0],xCols=_a[1],depth=_a[2];var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var y=ndarray_1.Array3D.zeros(convInfo.outShape);var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;for(var d=0;d<depth;++d){for(var yR=0;yR<y.shape[0];++yR){var xRCorner=yR*strideHeight-padTop;var xRMin=Math.max(0,xRCorner);var xRMax=Math.min(xRows,filterHeight+xRCorner);for(var yC=0;yC<y.shape[1];++yC){var xCCorner=yC*strideWidth-padLeft;var xCMin=Math.max(0,xCCorner);var xCMax=Math.min(xCols,filterWidth+xCCorner);var minMaxValue=poolType==='max'?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;var avgValue=0;for(var xR=xRMin;xR<xRMax;++xR){for(var xC=xCMin;xC<xCMax;++xC){var pixel=x.get(xR,xC,d);if(isNaN(pixel)){minMaxValue=NaN;avgValue=NaN;break;}if(poolType==='max'&&pixel>minMaxValue||poolType==='min'&&pixel<minMaxValue){minMaxValue=pixel;}else if(poolType==='avg'){avgValue+=pixel/(filterHeight*filterWidth);}}if(isNaN(minMaxValue)){break;}}y.set(poolType==='avg'?avgValue:minMaxValue,yR,yC,d);}}}return y;};NDArrayMathCPU.prototype.maxPoolInternal=function(x,convInfo){return this.pool(x,convInfo,'max');};NDArrayMathCPU.prototype.maxPoolPositions=function(x,convInfo){var _a=x.shape,xRows=_a[0],xCols=_a[1],depth=_a[2];var outputShape=convInfo.outShape;var maxPositions=ndarray_1.Array3D.zeros(outputShape);var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;for(var d=0;d<depth;++d){for(var yR=0;yR<outputShape[0];++yR){var xRCorner=yR*strideHeight-padTop;var xRMin=Math.max(0,xRCorner);var xRMax=Math.min(xRows,filterHeight+xRCorner);for(var yC=0;yC<outputShape[1];++yC){var xCCorner=yC*strideWidth-padLeft;var xCMin=Math.max(0,xCCorner);var xCMax=Math.min(xCols,filterWidth+xCCorner);var maxValue=Number.NEGATIVE_INFINITY;var maxPosition=-1;for(var xR=xRMin;xR<xRMax;++xR){var wR=xR-xRCorner;for(var xC=xCMin;xC<xCMax;++xC){var wC=xC-xCCorner;var pixel=x.get(xR,xC,d);if(pixel>maxValue){maxValue=pixel;maxPosition=wR*filterWidth+wC;}}}maxPositions.set(maxPosition,yR,yC,d);}}}return maxPositions;};NDArrayMathCPU.prototype.maxPoolBackpropInternal=function(dy,x,convInfo){var maxPositions=this.maxPoolPositions(x,convInfo);var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var padLeft=filterWidth-1-convInfo.padInfo.left;var padTop=filterHeight-1-convInfo.padInfo.top;var _a=dy.shape,dyRows=_a[0],dyCols=_a[1],depth=_a[2];var dx=ndarray_1.Array3D.zeros(x.shape);for(var d=0;d<depth;++d){for(var dxR=0;dxR<dx.shape[0];++dxR){for(var dxC=0;dxC<dx.shape[1];++dxC){var dyRCorner=dxR-padTop;var dyCCorner=dxC-padLeft;var dotProd=0;for(var wR=0;wR<filterHeight;++wR){var dyR=(dyRCorner+wR)/strideHeight;if(dyR<0||dyR>=dyRows||Math.floor(dyR)!==dyR){continue;}for(var wC=0;wC<filterWidth;++wC){var dyC=(dyCCorner+wC)/strideWidth;if(dyC<0||dyC>=dyCols||Math.floor(dyC)!==dyC){continue;}var maxPos=filterHeight*filterWidth-1-maxPositions.get(dyR,dyC,d);var curPos=wR*filterWidth+wC;var mask=maxPos===curPos?1:0;if(mask===0){continue;}var pixel=dy.get(dyR,dyC,d);dotProd+=pixel*mask;}}dx.set(dotProd,dxR,dxC,d);}}}return dx;};NDArrayMathCPU.prototype.minPoolInternal=function(x,convInfo){return this.pool(x,convInfo,'min');};NDArrayMathCPU.prototype.avgPoolInternal=function(x,convInfo){return this.pool(x,convInfo,'avg');};NDArrayMathCPU.prototype.resizeBilinear3DInternal=function(x,newShape2D,alignCorners){var output=ndarray_1.Array3D.zeros([newShape2D[0],newShape2D[1],x.shape[2]]);var effectiveInputSize=alignCorners?[x.shape[0]-1,x.shape[1]-1,x.shape[2]]:x.shape;var effectiveOutputSize=alignCorners?[output.shape[0]-1,output.shape[1]-1,output.shape[2]]:output.shape;for(var r=0;r<output.shape[0];r++){for(var c=0;c<output.shape[1];c++){for(var d=0;d<output.shape[2];d++){var sourceFracRow=effectiveInputSize[0]*r/effectiveOutputSize[0];var sourceFracCol=effectiveInputSize[1]*c/effectiveOutputSize[1];var sourceRowFloor=Math.floor(sourceFracRow);var sourceRowCeil=Math.min(x.shape[0]-1,Math.ceil(sourceFracRow));var sourceColFloor=Math.floor(sourceFracCol);var sourceColCeil=Math.min(x.shape[1]-1,Math.ceil(sourceFracCol));var topLeft=x.get(sourceRowFloor,sourceColFloor,d);var bottomLeft=x.get(sourceRowCeil,sourceColFloor,d);var topRight=x.get(sourceRowFloor,sourceColCeil,d);var bottomRight=x.get(sourceRowCeil,sourceColCeil,d);var rowFrac=sourceFracRow-sourceRowFloor;var colFrac=sourceFracCol-sourceColFloor;var top_1=topLeft+(topRight-topLeft)*colFrac;var bottom=bottomLeft+(bottomRight-bottomLeft)*colFrac;var newValue=top_1+(bottom-top_1)*rowFrac;output.set(newValue,r,c,d);}}}return output;};NDArrayMathCPU.prototype.batchNormalization3DInternal=function(x,mean,variance,varianceEpsilon,scale,offset){if(varianceEpsilon===void 0){varianceEpsilon=.001;}var xValues=x.getValues();var meanValues=mean.getValues();var varianceValues=variance.getValues();var scaleValues=scale?scale.getValues():new Float32Array([1]);var offsetValues=offset?offset.getValues():new Float32Array([0]);var outValues=new Float32Array(xValues.length);for(var i=0;i<xValues.length;i++){outValues[i]=offsetValues[i%offsetValues.length]+(xValues[i]-meanValues[i%meanValues.length])*scaleValues[i%scaleValues.length]/Math.sqrt(varianceValues[i%varianceValues.length]+varianceEpsilon);}return ndarray_1.Array3D.new(x.shape,outValues);};NDArrayMathCPU.prototype.multinomialInternal=function(probabilities,numSamples,seed){var batchSize=probabilities.shape[0];var numEvents=probabilities.shape[1];var res=ndarray_1.Array2D.zeros([batchSize,numSamples],'int32');var resVals=res.getValues();var probVals=probabilities.getValues();for(var b=0;b<batchSize;++b){var offset=b*numEvents;var cdf=new Float32Array(numEvents-1);cdf[0]=probVals[offset];for(var event_1=1;event_1<cdf.length;++event_1){cdf[event_1]=cdf[event_1-1]+probVals[offset+event_1];}var random=seedrandom.alea(seed.toString());var outOffset=b*numSamples;for(var sampleId=0;sampleId<numSamples;++sampleId){var r=random();resVals[outOffset+sampleId]=cdf.length;for(var event_2=0;event_2<cdf.length;event_2++){if(r<cdf[event_2]){resVals[outOffset+sampleId]=event_2;break;}}}}return res;};NDArrayMathCPU.prototype.oneHotInternal=function(indices,depth,onValue,offValue){var res=new Float32Array(indices.size*depth);res.fill(offValue);for(var event_3=0;event_3<indices.size;++event_3){res[event_3*depth+indices.get(event_3)]=onValue;}return ndarray_1.Array2D.new([indices.size,depth],res);};NDArrayMathCPU.prototype.broadcastedBinaryOp=function(a,b,dtype,op){var newShape=broadcast_util.assertAndGetBroadcastShape(a.shape,b.shape);var result=ndarray_1.NDArray.zeros(newShape,dtype);var newValues=result.getValues();var aValues=a.getValues();var bValues=b.getValues();var aBroadcastDims=broadcast_util.getBroadcastDims(a.shape,newShape);var bBroadcastDims=broadcast_util.getBroadcastDims(b.shape,newShape);var _loop_1=function _loop_1(i){var loc=result.indexToLoc(i);var aLoc=loc.slice(-a.rank);aBroadcastDims.forEach(function(d){return aLoc[d]=0;});var aIndex=a.locToIndex(aLoc);var bLoc=loc.slice(-b.rank);bBroadcastDims.forEach(function(d){return bLoc[d]=0;});var bIndex=b.locToIndex(bLoc);newValues[i]=op(aValues[aIndex],bValues[bIndex]);};for(var i=0;i<newValues.length;++i){_loop_1(i);}return result;};return NDArrayMathCPU;}(math_1.NDArrayMath);exports.NDArrayMathCPU=NDArrayMathCPU;},{"../util":88,"./axis_util":47,"./broadcast_util":48,"./concat_util":49,"./conv_util":50,"./copy2d_util":51,"./math":53,"./ndarray":56,"seedrandom":90}],55:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var math_1=require("./math");var ndarray=require("./ndarray");var ndarray_1=require("./ndarray");var addscaledmat_gpu_1=require("./webgl/addscaledmat_gpu");var argminmax_gpu_1=require("./webgl/argminmax_gpu");var batchnorm_gpu_1=require("./webgl/batchnorm_gpu");var binaryop_gpu=require("./webgl/binaryop_gpu");var binaryop_gpu_1=require("./webgl/binaryop_gpu");var clip_gpu_1=require("./webgl/clip_gpu");var concat_gpu_1=require("./webgl/concat_gpu");var conv_backprop_gpu_1=require("./webgl/conv_backprop_gpu");var conv_gpu_1=require("./webgl/conv_gpu");var copy_gpu_1=require("./webgl/copy_gpu");var gpgpu_context_1=require("./webgl/gpgpu_context");var gpgpu_math=require("./webgl/gpgpu_math");var gpgpu_util=require("./webgl/gpgpu_util");var logsumexp_gpu_1=require("./webgl/logsumexp_gpu");var max_pool_backprop_gpu_1=require("./webgl/max_pool_backprop_gpu");var minmax_gpu_1=require("./webgl/minmax_gpu");var mulmat_gpu_1=require("./webgl/mulmat_gpu");var multinomial_gpu_1=require("./webgl/multinomial_gpu");var onehot_gpu_1=require("./webgl/onehot_gpu");var pool_gpu_1=require("./webgl/pool_gpu");var reducesum_gpu_1=require("./webgl/reducesum_gpu");var resize_bilinear_gpu_1=require("./webgl/resize_bilinear_gpu");var slice_gpu_1=require("./webgl/slice_gpu");var texture_manager_1=require("./webgl/texture_manager");var transpose_gpu_1=require("./webgl/transpose_gpu");var unary_op=require("./webgl/unaryop_gpu");var unaryop_gpu_1=require("./webgl/unaryop_gpu");var webgl_util=require("./webgl/webgl_util");var NDArrayMathGPU=function(_super){__extends(NDArrayMathGPU,_super);function NDArrayMathGPU(gpgpu,safeMode){if(safeMode===void 0){safeMode=false;}var _this=_super.call(this,safeMode)||this;_this.binaryCache={};if(gpgpu==null){var gl=gpgpu_util.createWebGLContext();_this.gpgpu=new gpgpu_context_1.GPGPUContext(gl);_this.gpgpuCreatedLocally=true;}else{_this.gpgpu=gpgpu;_this.gpgpuCreatedLocally=false;}_this.textureManager=new texture_manager_1.TextureManager(_this.gpgpu);ndarray.initializeGPU(_this.gpgpu,_this.textureManager);return _this;}NDArrayMathGPU.prototype.getGPGPUContext=function(){return this.gpgpu;};NDArrayMathGPU.prototype.cloneInternal=function(a){var texShape=a.getTextureShapeRC();var source=a.as2D(texShape[0],texShape[1]);var output=this.makeOutputArray(texShape,a.dtype);this.copy2D(source,[0,0],texShape,output,[0,0],texShape);return output.reshape(a.shape);};NDArrayMathGPU.prototype.slice1DInternal=function(input,begin,size){var program=new slice_gpu_1.SliceProgram([size]);var customSetup=program.getCustomSetupFunc([begin]);return this.compileAndRun(program,[input],null,customSetup);};NDArrayMathGPU.prototype.slice2DInternal=function(input,begin,size){var program=new slice_gpu_1.SliceProgram(size);var customSetup=program.getCustomSetupFunc(begin);return this.compileAndRun(program,[input],null,customSetup);};NDArrayMathGPU.prototype.slice3DInternal=function(input,begin,size){var program=new slice_gpu_1.SliceProgram(size);var customSetup=program.getCustomSetupFunc(begin);return this.compileAndRun(program,[input],null,customSetup);};NDArrayMathGPU.prototype.slice4DInternal=function(input,begin,size){var program=new slice_gpu_1.SliceProgram(size);var customSetup=program.getCustomSetupFunc(begin);return this.compileAndRun(program,[input],null,customSetup);};NDArrayMathGPU.prototype.copy2DInternal=function(source,sourceBeginRowCol,sourceSizeRowCol,dest,destBeginRowCol,destSizeRowCol){var program=new copy_gpu_1.Copy2DProgram(sourceSizeRowCol[1],destSizeRowCol[1]);var customSetup=program.getCustomSetupFunc(sourceBeginRowCol,destBeginRowCol,destSizeRowCol);this.compileAndRun(program,[source],dest,customSetup);};NDArrayMathGPU.prototype.concat1DInternal=function(a,b){var program=new concat_gpu_1.ConcatProgram(a.shape,b.shape,0);return this.compileAndRun(program,[a,b]);};NDArrayMathGPU.prototype.concat2DInternal=function(a,b,axis){var program=new concat_gpu_1.ConcatProgram(a.shape,b.shape,axis);return this.compileAndRun(program,[a,b]);};NDArrayMathGPU.prototype.concat3DInternal=function(x1,x2,axis){var program=new concat_gpu_1.ConcatProgram(x1.shape,x2.shape,axis);return this.compileAndRun(program,[x1,x2]);};NDArrayMathGPU.prototype.concat4DInternal=function(x1,x2,axis){var program=new concat_gpu_1.ConcatProgram(x1.shape,x2.shape,axis);return this.compileAndRun(program,[x1,x2]);};NDArrayMathGPU.prototype.scaledArrayAddInternal=function(c1,a,c2,b){var program=new addscaledmat_gpu_1.AddScaledMatProgram(a.shape,b.shape);return this.compileAndRun(program,[a,b,c1,c2]);};NDArrayMathGPU.prototype.negInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.NEG);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.makeOutputArray=function(shape,dtype){var textureShapeRC=webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl,shape);var texture=this.textureManager.acquireTexture(textureShapeRC);return ndarray_1.NDArray.make(shape,{texture:texture,textureShapeRC:textureShapeRC},dtype);};NDArrayMathGPU.prototype.compileAndRun=function(program,inputs,output,customSetup){var _this=this;if(output==null){output=this.makeOutputArray(program.outputShape,inputs[0].dtype);}var key=gpgpu_math.makeShaderKey(program,inputs,output);var binary=this.getAndSaveBinary(key,function(){return gpgpu_math.compileProgram(_this.gpgpu,program,inputs,output);});gpgpu_math.runProgram(binary,inputs,output,customSetup);return output;};NDArrayMathGPU.prototype.matMulInternal=function(a,b,aOrientation,bOrientation){var program=new mulmat_gpu_1.MatMulProgram(a.shape,b.shape,aOrientation,bOrientation);return this.compileAndRun(program,[a,b]);};NDArrayMathGPU.prototype.multiplyInternal=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL,a.shape,b.shape);return this.compileAndRun(program,[a,b]);};NDArrayMathGPU.prototype.batchNormalization3DInternal=function(x,mean,variance,varianceEpsilon,scale,offset){var inputs=[x,mean,variance];if(varianceEpsilon==null){varianceEpsilon=0.000001;}var offsetShape=null;if(offset!=null){offsetShape=offset.shape;inputs.push(offset);}var scaleShape=null;if(scale!=null){scaleShape=scale.shape;inputs.push(scale);}var program=new batchnorm_gpu_1.BatchNormProgram(x.shape,mean.shape,variance.shape,offsetShape,scaleShape,varianceEpsilon);return this.compileAndRun(program,inputs);};NDArrayMathGPU.prototype.transposeInternal=function(a,perm){var program=new transpose_gpu_1.TransposeProgram(a.shape,perm);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.sumInternal=function(a,axes){var program=new reducesum_gpu_1.ReduceSumProgram(a.shape,axes);var output=this.makeOutputArray(program.outputShape,math_1.SumTypesMap[a.dtype]);return this.compileAndRun(program,[a],output);};NDArrayMathGPU.prototype.argMinInternal=function(a,axes){var program=new argminmax_gpu_1.ArgMinMaxProgram(a.shape,axes,'min');var output=this.makeOutputArray(program.outputShape,'int32');return this.compileAndRun(program,[a],output);};NDArrayMathGPU.prototype.argMaxInternal=function(a,axes){var program=new argminmax_gpu_1.ArgMinMaxProgram(a.shape,axes,'max');var output=this.makeOutputArray(program.outputShape,'int32');return this.compileAndRun(program,[a],output);};NDArrayMathGPU.prototype.equalInternal=function(x,y){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL,x.shape,y.shape);var output=this.makeOutputArray(program.outputShape,'bool');return this.compileAndRun(program,[x,y],output);};NDArrayMathGPU.prototype.topKInternal=function(ndarray,k){throw new Error('topK GPU not yet implemented!');};NDArrayMathGPU.prototype.minInternal=function(a,axes){var program=new minmax_gpu_1.MinMaxProgram(a.shape,axes,'min');return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.maxInternal=function(a,axes){var program=new minmax_gpu_1.MinMaxProgram(a.shape,axes,'max');return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.divideInternal=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.DIV,a.shape,b.shape);var output=this.makeOutputArray(program.outputShape,'float32');return this.compileAndRun(program,[a,b],output);};NDArrayMathGPU.prototype.addInternal=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD,a.shape,b.shape);return this.compileAndRun(program,[a,b]);};NDArrayMathGPU.prototype.subtractInternal=function(a,b){var program=new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB,a.shape,b.shape);return this.compileAndRun(program,[a,b]);};NDArrayMathGPU.prototype.logSumExpInternal=function(a,axes){var program=new logsumexp_gpu_1.LogSumExpProgram(a.shape,axes);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.ceilInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.CEIL);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.floorInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.FLOOR);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.expInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.EXP);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.logInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.LOG);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.sqrtInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.SQRT);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.squareInternal=function(x){var program=new unaryop_gpu_1.UnaryOpProgram(x.shape,unary_op.SQUARE);return this.compileAndRun(program,[x]);};NDArrayMathGPU.prototype.reluInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.RELU);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.eluInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.ELU);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.leakyReluInternal=function(a,alpha){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.LEAKY_RELU(alpha));return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.clipInternal=function(a,min,max){var program=new clip_gpu_1.ClipProgram(a.shape,min,max);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.absInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.ABS);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.sigmoidInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.SIGMOID);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.sinInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.SIN);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.cosInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.COS);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.tanInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.TAN);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.asinInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.ASIN);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.acosInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.ACOS);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.atanInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.ATAN);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.sinhInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.SINH);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.coshInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.COSH);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.tanhInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.TANH);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.stepInternal=function(a){var program=new unaryop_gpu_1.UnaryOpProgram(a.shape,unary_op.STEP);return this.compileAndRun(program,[a]);};NDArrayMathGPU.prototype.conv2dInternal=function(x,filter,bias,convInfo){var program=new conv_gpu_1.Conv2DProgram(convInfo,bias!=null);var inputs=bias!=null?[x,filter,bias]:[x,filter];return this.compileAndRun(program,inputs);};NDArrayMathGPU.prototype.conv2dDerInputInternal=function(dy,filter,convInfo){var program=new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);return this.compileAndRun(program,[dy,filter]);};NDArrayMathGPU.prototype.conv2dDerFilterInternal=function(x,dY,convInfo){var program=new conv_backprop_gpu_1.Conv2DDerWeightsProgram(convInfo);return this.compileAndRun(program,[x,dY]);};NDArrayMathGPU.prototype.conv2dDerBiasInternal=function(dY){var program=new conv_backprop_gpu_1.Conv2DDerBiasProgram(dY.shape);return this.compileAndRun(program,[dY]);};NDArrayMathGPU.prototype.maxPoolInternal=function(x,convInfo){var program=new pool_gpu_1.Pool2DProgram(convInfo,'max',false);return this.compileAndRun(program,[x]);};NDArrayMathGPU.prototype.minPoolInternal=function(x,convInfo){var program=new pool_gpu_1.Pool2DProgram(convInfo,'min',false);return this.compileAndRun(program,[x]);};NDArrayMathGPU.prototype.avgPoolInternal=function(x,convInfo){var program=new pool_gpu_1.Pool2DProgram(convInfo,'avg',false);return this.compileAndRun(program,[x]);};NDArrayMathGPU.prototype.maxPoolBackpropInternal=function(dy,x,convInfo){var getPositions=true;var maxPoolPositionsProgram=new pool_gpu_1.Pool2DProgram(convInfo,'max',getPositions);var maxPoolPositions=this.compileAndRun(maxPoolPositionsProgram,[x]);var maxPoolBackPropProgram=new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);var result=this.compileAndRun(maxPoolBackPropProgram,[dy,maxPoolPositions]);maxPoolPositions.dispose();return result;};NDArrayMathGPU.prototype.resizeBilinear3DInternal=function(x,newShape2D,alignCorners){var program=new resize_bilinear_gpu_1.ResizeBilinear3DProgram(x.shape,newShape2D,alignCorners);return this.compileAndRun(program,[x]);};NDArrayMathGPU.prototype.multinomialInternal=function(probs,numSamples,seed){var batchSize=probs.shape[0];var numOutcomes=probs.shape[1];var program=new multinomial_gpu_1.MultinomialProgram(batchSize,numOutcomes,numSamples);var output=this.makeOutputArray(program.outputShape,'int32');var customSetup=program.getCustomSetupFunc(seed);return this.compileAndRun(program,[probs],output,customSetup);};NDArrayMathGPU.prototype.oneHotInternal=function(indices,depth,onValue,offValue){var program=new onehot_gpu_1.OneHotProgram(indices.size,depth,onValue,offValue);return this.compileAndRun(program,[indices]);};NDArrayMathGPU.prototype.getAndSaveBinary=function(key,getBinary){if(!(key in this.binaryCache)){this.binaryCache[key]=getBinary();}return this.binaryCache[key];};NDArrayMathGPU.prototype.getTextureManager=function(){return this.textureManager;};NDArrayMathGPU.prototype.dispose=function(){for(var key in this.binaryCache){this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);}this.textureManager.dispose();if(this.gpgpuCreatedLocally){this.gpgpu.dispose();}};return NDArrayMathGPU;}(math_1.NDArrayMath);exports.NDArrayMathGPU=NDArrayMathGPU;},{"./math":53,"./ndarray":56,"./webgl/addscaledmat_gpu":58,"./webgl/argminmax_gpu":59,"./webgl/batchnorm_gpu":60,"./webgl/binaryop_gpu":61,"./webgl/clip_gpu":62,"./webgl/concat_gpu":63,"./webgl/conv_backprop_gpu":64,"./webgl/conv_gpu":65,"./webgl/copy_gpu":66,"./webgl/gpgpu_context":67,"./webgl/gpgpu_math":68,"./webgl/gpgpu_util":69,"./webgl/logsumexp_gpu":70,"./webgl/max_pool_backprop_gpu":71,"./webgl/minmax_gpu":72,"./webgl/mulmat_gpu":73,"./webgl/multinomial_gpu":74,"./webgl/onehot_gpu":75,"./webgl/pool_gpu":76,"./webgl/reducesum_gpu":77,"./webgl/resize_bilinear_gpu":79,"./webgl/slice_gpu":81,"./webgl/texture_manager":83,"./webgl/transpose_gpu":84,"./webgl/unaryop_gpu":85,"./webgl/webgl_util":86}],56:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator["throw"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value);}).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=y[op[0]&2?"return":op[0]?"throw":"next"])&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[0,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../environment");var util=require("../util");var tex_util_1=require("./webgl/tex_util");var webgl_util=require("./webgl/webgl_util");exports.GPGPU=null;exports.TEXTURE_MANAGER=null;var DType;(function(DType){DType["float32"]="float32";DType["int32"]="int32";DType["bool"]="bool";})(DType=exports.DType||(exports.DType={}));function initializeGPU(gpgpu,textureManager){exports.GPGPU=gpgpu;exports.TEXTURE_MANAGER=textureManager;}exports.initializeGPU=initializeGPU;function throwIfGPUNotInitialized(){if(exports.GPGPU==null||exports.TEXTURE_MANAGER==null){throw new Error('GPU not intialized.');}}var NDArray=function(){function NDArray(shape,data,dtype){util.assert(data.values!=null||data.texture!=null,'Either `values` or `texture` must be defined');util.assert(data.texture==null||data.textureShapeRC!=null,'`textureShape` must be defined when `texture` is defined');this.size=util.sizeFromShape(shape);if(data.values!=null){util.assert(this.size===data.values.length,"Constructing ndarray of shape ("+this.size+") should match the "+("length of values ("+data.values.length+")"));}this.shape=shape;if(data.textureType==null){data.textureType=tex_util_1.TextureType.DEFAULT;}this.ndarrayData=data;this.dtype=dtype||'float32';var dim=this.shape.length;if(dim<2){this.strides=[];}else{this.strides=new Array(dim-1);this.strides[dim-2]=this.shape[dim-1];for(var i=dim-3;i>=0;--i){this.strides[i]=this.strides[i+1]*this.shape[i+1];}}}NDArray.zeros=function(shape,dtype){var values=makeZerosTypedArray(util.sizeFromShape(shape),dtype);return NDArray.make(shape,{values:values},dtype);};NDArray.zerosLike=function(another){return NDArray.zeros(another.shape,another.dtype);};NDArray.like=function(another){var newValues=copyTypedArray(another.getValues(),another.dtype);return NDArray.make(another.shape,{values:newValues},another.dtype);};NDArray.make=function(shape,data,dtype){switch(shape.length){case 0:return new Scalar(data,dtype);case 1:return new Array1D(data,dtype);case 2:return new Array2D(shape,data,dtype);case 3:return new Array3D(shape,data,dtype);case 4:return new Array4D(shape,data,dtype);default:return new NDArray(shape,data,dtype);}};NDArray.fromPixels=function(pixels,numChannels){if(numChannels===void 0){numChannels=3;}if(numChannels>4){throw new Error('Cannot construct NDArray with more than 4 channels from pixels.');}var shape=[pixels.height,pixels.width,numChannels];var textureShapeRC=[shape[0],shape[1]];var texture=exports.TEXTURE_MANAGER.acquireTexture(textureShapeRC);var textureType=tex_util_1.TextureType.RGBA_COLOR;exports.GPGPU.uploadPixelDataToTexture(texture,pixels);return Array3D.make(shape,{texture:texture,textureShapeRC:textureShapeRC,textureType:textureType});};NDArray.prototype.reshape=function(newShape){newShape=util.inferFromImplicitShape(newShape,this.size);if(util.arraysEqual(this.shape,newShape)){return this;}util.assert(this.size===util.sizeFromShape(newShape),'new shape and old shape must have the same number of elements.');return NDArray.make(newShape,this.ndarrayData,this.dtype);};NDArray.prototype.flatten=function(){if(this instanceof Array1D){return this;}return this.as1D();};NDArray.prototype.asScalar=function(){util.assert(this.size===1,'The array must have only 1 element.');return this.reshape([]);};NDArray.prototype.as1D=function(){return this.reshape([this.size]);};NDArray.prototype.as2D=function(rows,columns){return this.reshape([rows,columns]);};NDArray.prototype.as3D=function(rows,columns,depth){return this.reshape([rows,columns,depth]);};NDArray.prototype.as4D=function(rows,columns,depth,depth2){return this.reshape([rows,columns,depth,depth2]);};NDArray.prototype.asType=function(dtype){var newData=this.getData();if(newData.values!=null){newData={values:toTypedArray(newData.values,dtype)};}return NDArray.make(this.shape,newData,dtype);};Object.defineProperty(NDArray.prototype,"rank",{get:function get(){return this.shape.length;},enumerable:true,configurable:true});NDArray.prototype.get=function(){var locs=[];for(var _i=0;_i<arguments.length;_i++){locs[_i]=arguments[_i];}var index=locs[locs.length-1];for(var i=0;i<locs.length-1;++i){index+=this.strides[i]*locs[i];}return this.getValues()[index];};NDArray.prototype.add=function(value){var locs=[];for(var _i=1;_i<arguments.length;_i++){locs[_i-1]=arguments[_i];}this.set.apply(this,[this.get.apply(this,locs)+value].concat(locs));};NDArray.prototype.set=function(value){var locs=[];for(var _i=1;_i<arguments.length;_i++){locs[_i-1]=arguments[_i];}var index=locs[locs.length-1];for(var i=0;i<locs.length-1;++i){index+=this.strides[i]*locs[i];}this.getValues()[index]=value;};NDArray.prototype.val=function(){var locs=[];for(var _i=0;_i<arguments.length;_i++){locs[_i]=arguments[_i];}return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.data()];case 1:_a.sent();return[2,this.get.apply(this,locs)];}});});};NDArray.prototype.locToIndex=function(locs){var index=locs[locs.length-1];for(var i=0;i<locs.length-1;++i){index+=this.strides[i]*locs[i];}return index;};NDArray.prototype.indexToLoc=function(index){var locs=new Array(this.shape.length);for(var i=0;i<locs.length-1;++i){locs[i]=Math.floor(index/this.strides[i]);index-=locs[i]*this.strides[i];}locs[locs.length-1]=index;return locs;};NDArray.prototype.fill=function(value){this.getValues().fill(value);};NDArray.prototype.getData=function(){return this.ndarrayData;};NDArray.prototype.getValues=function(){return this.dataSync();};NDArray.prototype.getValuesAsync=function(){return this.data();};NDArray.prototype.data=function(){return __awaiter(this,void 0,void 0,function(){var _a,queryFn;return __generator(this,function(_b){switch(_b.label){case 0:if(this.ndarrayData.values!=null){return[2,this.ndarrayData.values];}if(!(environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')&&this.ndarrayData.textureType===tex_util_1.TextureType.DEFAULT))return[3,2];_a=this.ndarrayData;return[4,exports.GPGPU.downloadMatrixFromTextureAsync(this.ndarrayData.texture,this.ndarrayData.textureShapeRC[0],this.ndarrayData.textureShapeRC[1])];case 1:_a.values=_b.sent();return[2,this.ndarrayData.values];case 2:if(!!environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED'))return[3,4];return[4,this.dataSync()];case 3:return[2,_b.sent()];case 4:queryFn=function queryFn(){};return[4,exports.GPGPU.runQuery(queryFn)];case 5:_b.sent();return[2,this.dataSync()];}});});};NDArray.prototype.dataSync=function(){if(this.ndarrayData.values==null){throwIfGPUNotInitialized();var values=void 0;if(this.ndarrayData.textureType===tex_util_1.TextureType.DEFAULT){values=exports.GPGPU.downloadMatrixFromTexture(this.ndarrayData.texture,this.ndarrayData.textureShapeRC[0],this.ndarrayData.textureShapeRC[1]);}else{values=exports.GPGPU.downloadMatrixFromRGBAColorTexture(this.ndarrayData.texture,this.ndarrayData.textureShapeRC[0],this.ndarrayData.textureShapeRC[1],this.shape[2]);}this.ndarrayData.values=float32ToTypedArray(values,this.dtype);this.disposeTexture();}return this.ndarrayData.values;};NDArray.prototype.uploadToGPU=function(preferredTexShape){throwIfGPUNotInitialized();this.ndarrayData.textureShapeRC=webgl_util.getTextureShapeFromLogicalShape(exports.GPGPU.gl,this.shape,preferredTexShape);this.ndarrayData.texture=exports.TEXTURE_MANAGER.acquireTexture(this.ndarrayData.textureShapeRC);this.ndarrayData.textureType=tex_util_1.TextureType.DEFAULT;exports.GPGPU.uploadMatrixToTexture(this.ndarrayData.texture,this.ndarrayData.textureShapeRC[0],this.ndarrayData.textureShapeRC[1],typedArrayToFloat32(this.ndarrayData.values,this.dtype));this.ndarrayData.values=null;};NDArray.prototype.getTexture=function(preferredShapeRC){if(this.ndarrayData.texture==null){this.uploadToGPU(preferredShapeRC);}return this.ndarrayData.texture;};NDArray.prototype.getTextureShapeRC=function(preferredShapeRC){if(this.ndarrayData.textureShapeRC==null){this.uploadToGPU(preferredShapeRC);}return this.ndarrayData.textureShapeRC;};NDArray.prototype.dispose=function(){this.ndarrayData.values=null;this.shape=null;if(this.ndarrayData.texture!=null){this.disposeTexture();}};NDArray.prototype.disposeTexture=function(){throwIfGPUNotInitialized();exports.TEXTURE_MANAGER.releaseTexture(this.ndarrayData.texture,this.ndarrayData.textureShapeRC);this.ndarrayData.texture=null;this.ndarrayData.textureShapeRC=null;this.ndarrayData.textureType=null;};NDArray.prototype.inGPU=function(){return this.ndarrayData.texture!=null;};NDArray.prototype.equals=function(t){return this.dtype===t.dtype&&util.arraysEqual(this.shape,t.shape)&&util.arraysEqual(this.getValues(),t.getValues());};NDArray.rand=function(shape,randFunction){var size=util.sizeFromShape(shape);var values=new Float32Array(size);for(var i=0;i<size;i++){values[i]=randFunction();}return NDArray.make(shape,{values:values});};NDArray.randNormal=function(shape,mean,stdDev){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}return NDArray.rand(shape,function(){return util.randGauss(mean,stdDev);});};NDArray.randTruncatedNormal=function(shape,mean,stdDev){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}return NDArray.rand(shape,function(){return util.randGauss(mean,stdDev,true);});};NDArray.randUniform=function(shape,a,b){return NDArray.rand(shape,function(){return util.randUniform(a,b);});};return NDArray;}();exports.NDArray=NDArray;var Scalar=function(_super){__extends(Scalar,_super);function Scalar(data,dtype){var _this=this;if(data.texture!=null){data.textureShapeRC=[1,1];}_this=_super.call(this,[],data,dtype)||this;return _this;}Scalar.new=function(value,dtype){var values=[value];return new Scalar({values:toTypedArray(values,dtype)},dtype);};Scalar.prototype.get=function(){return this.getValues()[0];};Scalar.prototype.val=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.data()];case 1:_a.sent();return[2,this.get()];}});});};Scalar.prototype.set=function(value){this.getValues()[0]=value;};Scalar.prototype.add=function(value){this.getValues()[0]+=value;};Scalar.prototype.asType=function(dtype){return _super.prototype.asType.call(this,dtype);};Scalar.prototype.locToIndex=function(loc){return 0;};Scalar.prototype.indexToLoc=function(index){return[];};Scalar.ZERO=Scalar.new(0);Scalar.ONE=Scalar.new(1);Scalar.TWO=Scalar.new(2);Scalar.NEG_ONE=Scalar.new(-1);return Scalar;}(NDArray);exports.Scalar=Scalar;var Array1D=function(_super){__extends(Array1D,_super);function Array1D(data,dtype){var _this=this;var shape=data.values!=null?[data.values.length]:[util.sizeFromShape(data.textureShapeRC)];_this=_super.call(this,shape,data,dtype)||this;return _this;}Array1D.new=function(values,dtype){if(!instanceofTypedArray(values)){var inferredShape=util.inferShape(values);util.assert(inferredShape.length===1,"Error constructing Array1D. Shape of values "+inferredShape+" is "+"not 1 dimensional.");}return new Array1D({values:toTypedArray(values,dtype)},dtype);};Array1D.prototype.get=function(i){return this.getValues()[i];};Array1D.prototype.set=function(value,i){this.getValues()[i]=value;};Array1D.prototype.val=function(i){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.data()];case 1:_a.sent();return[2,this.get(i)];}});});};Array1D.prototype.add=function(value,i){this.getValues()[i]+=value;};Array1D.prototype.locToIndex=function(loc){return loc[0];};Array1D.prototype.indexToLoc=function(index){return[index];};Array1D.prototype.asType=function(dtype){return _super.prototype.asType.call(this,dtype);};Array1D.zeros=function(shape,dtype){return NDArray.zeros(shape,dtype);};Array1D.randNormal=function(shape,mean,stdDev){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}return NDArray.rand(shape,function(){return util.randGauss(mean,stdDev);});};Array1D.randTruncatedNormal=function(shape,mean,stdDev){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}return NDArray.rand(shape,function(){return util.randGauss(mean,stdDev,true);});};Array1D.randUniform=function(shape,a,b){return NDArray.rand(shape,function(){return util.randUniform(a,b);});};return Array1D;}(NDArray);exports.Array1D=Array1D;var Array2D=function(_super){__extends(Array2D,_super);function Array2D(shape,data,dtype){var _this=this;util.assert(shape.length===2,'Shape should be of length 2');_this=_super.call(this,shape,data,dtype)||this;_this.stride0=_this.strides[0];return _this;}Array2D.new=function(shape,values,dtype){if(!instanceofTypedArray(values)){var inferredShape=util.inferShape(values);if(inferredShape.length>1){util.assertShapesMatch(shape,inferredShape,"Error when constructing Array2D. Shape of values "+(inferredShape+" does not match the provided shape ")+(shape+". "));}}return new Array2D(shape,{values:toTypedArray(values,dtype)},dtype);};Array2D.prototype.get=function(i,j){return this.getValues()[this.stride0*i+j];};Array2D.prototype.set=function(value,i,j){this.getValues()[this.stride0*i+j]=value;};Array2D.prototype.add=function(value,i,j){this.getValues()[this.stride0*i+j]+=value;};Array2D.prototype.val=function(i,j){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.data()];case 1:_a.sent();return[2,this.get(i,j)];}});});};Array2D.prototype.locToIndex=function(locs){return this.stride0*locs[0]+locs[1];};Array2D.prototype.indexToLoc=function(index){return[Math.floor(index/this.stride0),index%this.stride0];};Array2D.prototype.asType=function(dtype){return _super.prototype.asType.call(this,dtype);};Array2D.zeros=function(shape,dtype){return NDArray.zeros(shape,dtype);};Array2D.randNormal=function(shape,mean,stdDev){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}return NDArray.rand(shape,function(){return util.randGauss(mean,stdDev);});};Array2D.randTruncatedNormal=function(shape,mean,stdDev){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}return NDArray.rand(shape,function(){return util.randGauss(mean,stdDev,true);});};Array2D.randUniform=function(shape,a,b){return NDArray.rand(shape,function(){return util.randUniform(a,b);});};return Array2D;}(NDArray);exports.Array2D=Array2D;var Array3D=function(_super){__extends(Array3D,_super);function Array3D(shape,data,dtype){var _this=this;util.assert(shape.length===3,'Shape should be of length 3');_this=_super.call(this,shape,data,dtype)||this;_this.stride0=_this.strides[0];_this.stride1=_this.strides[1];return _this;}Array3D.new=function(shape,values,dtype){if(!instanceofTypedArray(values)){var inferredShape=util.inferShape(values);if(inferredShape.length>1){util.assertShapesMatch(shape,inferredShape,"Error when constructing Array3D. Shape of values "+(inferredShape+" does not match the provided shape ")+(shape+". "));}}return new Array3D(shape,{values:toTypedArray(values,dtype)},dtype);};Array3D.prototype.get=function(i,j,k){return this.getValues()[this.stride0*i+this.stride1*j+k];};Array3D.prototype.set=function(value,i,j,k){this.getValues()[this.stride0*i+this.stride1*j+k]=value;};Array3D.prototype.val=function(i,j,k){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.data()];case 1:_a.sent();return[2,this.get(i,j,k)];}});});};Array3D.prototype.add=function(value,i,j,k){this.getValues()[this.stride0*i+this.stride1*j+k]+=value;};Array3D.prototype.locToIndex=function(locs){return this.stride0*locs[0]+this.stride1*locs[1]+locs[2];};Array3D.prototype.indexToLoc=function(index){var i=Math.floor(index/this.stride0);index-=i*this.stride0;return[i,Math.floor(index/this.stride1),index%this.stride1];};Array3D.prototype.asType=function(dtype){return _super.prototype.asType.call(this,dtype);};Array3D.zeros=function(shape,dtype){return NDArray.zeros(shape,dtype);};Array3D.randNormal=function(shape,mean,stdDev){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}return NDArray.rand(shape,function(){return util.randGauss(mean,stdDev);});};Array3D.randTruncatedNormal=function(shape,mean,stdDev){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}return NDArray.rand(shape,function(){return util.randGauss(mean,stdDev,true);});};Array3D.randUniform=function(shape,a,b){return NDArray.rand(shape,function(){return util.randUniform(a,b);});};return Array3D;}(NDArray);exports.Array3D=Array3D;var Array4D=function(_super){__extends(Array4D,_super);function Array4D(shape,data,dtype){var _this=this;util.assert(shape.length===4,'Shape should be of length 4');_this=_super.call(this,shape,data,dtype)||this;_this.stride0=_this.strides[0];_this.stride1=_this.strides[1];_this.stride2=_this.strides[2];return _this;}Array4D.new=function(shape,values,dtype){if(!instanceofTypedArray(values)){var inferredShape=util.inferShape(values);if(inferredShape.length>1){util.assertShapesMatch(shape,inferredShape,"Error when constructing Array4D. Shape of values "+(inferredShape+" does not match the provided shape ")+(shape+". "));}}return new Array4D(shape,{values:toTypedArray(values,dtype)},dtype);};Array4D.prototype.get=function(i,j,k,l){return this.getValues()[this.stride0*i+this.stride1*j+this.stride2*k+l];};Array4D.prototype.set=function(value,i,j,k,l){this.getValues()[this.stride0*i+this.stride1*j+this.stride2*k+l]=value;};Array4D.prototype.val=function(i,j,k,l){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.data()];case 1:_a.sent();return[2,this.get(i,j,k,l)];}});});};Array4D.prototype.add=function(value,i,j,k,l){this.getValues()[this.stride0*i+this.stride1*j+this.stride2*k+l]+=value;};Array4D.prototype.locToIndex=function(locs){return this.stride0*locs[0]+this.stride1*locs[1]+this.stride2*locs[2]+locs[3];};Array4D.prototype.indexToLoc=function(index){var i=Math.floor(index/this.stride0);index-=i*this.stride0;var j=Math.floor(index/this.stride1);index-=j*this.stride1;return[i,j,Math.floor(index/this.stride2),index%this.stride2];};Array4D.prototype.asType=function(dtype){return _super.prototype.asType.call(this,dtype);};Array4D.zeros=function(shape,dtype){return NDArray.zeros(shape,dtype);};Array4D.randNormal=function(shape,mean,stdDev){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}return NDArray.rand(shape,function(){return util.randGauss(mean,stdDev);});};Array4D.randTruncatedNormal=function(shape,mean,stdDev){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}return NDArray.rand(shape,function(){return util.randGauss(mean,stdDev,true);});};Array4D.randUniform=function(shape,a,b){return NDArray.rand(shape,function(){return util.randUniform(a,b);});};return Array4D;}(NDArray);exports.Array4D=Array4D;function copyTypedArray(array,dtype){if(dtype==null||dtype==='float32'){return new Float32Array(array);}else if(dtype==='int32'){return new Int32Array(array);}else if(dtype==='bool'){var bool=new Uint8Array(array.length);for(var i=0;i<bool.length;++i){var val=array[i];if(util.isValNaN(val,'bool')){bool[i]=util.getNaN('bool');}else if(val){bool[i]=1;}}return bool;}else{throw new Error("Unknown data type "+dtype);}}function instanceofTypedArray(a){return a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array;}function noConversionNeeded(a,dtype){return a instanceof Float32Array&&dtype==='float32'||a instanceof Int32Array&&dtype==='int32'||a instanceof Uint8Array&&dtype==='bool';}function toTypedArray(a,dtype){if(noConversionNeeded(a,dtype)){return a;}if(Array.isArray(a)){a=util.flatten(a);}return copyTypedArray(a,dtype);}function makeZerosTypedArray(size,dtype){if(dtype==null||dtype==='float32'){return new Float32Array(size);}else if(dtype==='int32'){return new Int32Array(size);}else if(dtype==='bool'){return new Uint8Array(size);}else{throw new Error("Unknown data type "+dtype);}}function typedArrayToFloat32(a,dtype){if(a instanceof Float32Array){return a;}else{var res=new Float32Array(a.length);for(var i=0;i<res.length;i++){var val=a[i];res[i]=util.isValNaN(val,dtype)?NaN:val;}return res;}}function float32ToTypedArray(a,dtype){if(dtype==='float32'){return a;}else if(dtype==='int32'||dtype==='bool'){var result=dtype==='int32'?new Int32Array(a.length):new Uint8Array(a.length);for(var i=0;i<result.length;++i){var val=a[i];val=isNaN(val)?util.getNaN(dtype):Math.round(val);result[i]=val;}return result;}else{throw new Error("Unknown dtype "+dtype);}}},{"../environment":8,"../util":88,"./webgl/tex_util":82,"./webgl/webgl_util":86}],57:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../util");function assertParamsValid(input,begin,size){util.assert(input.rank===begin.length,"Error in slice"+input.rank+"D: Length of begin "+begin+" must "+("match the rank of the array ("+input.rank+")."));util.assert(input.rank===size.length,"Error in slice"+input.rank+"D: Length of size "+size+" must "+("match the rank of the array ("+input.rank+")."));for(var i=0;i<input.rank;++i){util.assert(begin[i]+size[i]<=input.shape[i],"Error in slice"+input.rank+"D: begin["+i+"] + size["+i+"] "+("("+(begin[i]+size[i])+") would overflow input.shape["+i+"] ("+input.shape[i]+")"));}}exports.assertParamsValid=assertParamsValid;},{"../util":88}],58:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var broadcast_util=require("../broadcast_util");var AddScaledMatProgram=function(){function AddScaledMatProgram(aShape,bShape){this.variableNames=['A','B','c1','c2'];this.supportsBroadcasting=true;this.outputShape=broadcast_util.assertAndGetBroadcastShape(aShape,bShape);this.userCode="\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        float c1 = getC1();\n        float c2 = getC2();\n        setOutput(dot(vec2(c1, c2), vec2(a, b)));\n      }\n    ";}return AddScaledMatProgram;}();exports.AddScaledMatProgram=AddScaledMatProgram;},{"../broadcast_util":48}],59:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../../util");var axis_util=require("../axis_util");function getArgMinMaxSnippet(op,texName,size){var compOp=op==='min'?'<':'>';return"\n    float getArgMinMax"+texName+"() {\n      int bestIndex = 0;\n      float bestValue = get"+texName+"Flat(0);\n\n      for (int i = 0; i < "+size+"; i++) {\n        float candidate = get"+texName+"Flat(i);\n        if (isNaN(candidate)) {\n          return candidate;\n        }\n        if (candidate "+compOp+" bestValue) {\n          bestValue = candidate;\n          bestIndex = i;\n        }\n      }\n      return float(bestIndex);\n    }\n  ";}exports.getArgMinMaxSnippet=getArgMinMaxSnippet;var ArgMinMaxProgram=function(){function ArgMinMaxProgram(shape,axes,opType){this.variableNames=['A'];var _a=axis_util.computeOutAndReduceShapes(shape,axes),outShape=_a[0],reduceShape=_a[1];this.outputShape=outShape;this.numBatchDims=outShape.length;var size=util.sizeFromShape(reduceShape);var aSnippet=getArgMinMaxSnippet(opType,'A',size);this.userCode="\n      "+aSnippet+"\n\n      void main() {\n        setOutput(getArgMinMaxA());\n      }\n    ";}return ArgMinMaxProgram;}();exports.ArgMinMaxProgram=ArgMinMaxProgram;},{"../../util":88,"../axis_util":47}],60:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var broadcast_util=require("../broadcast_util");var BatchNormProgram=function(){function BatchNormProgram(xShape,meanShape,varianceShape,offsetShape,scaleShape,varianceEpsilon){this.outputShape=[];this.supportsBroadcasting=true;this.variableNames=['x','mean','variance'];broadcast_util.assertAndGetBroadcastShape(xShape,meanShape);broadcast_util.assertAndGetBroadcastShape(xShape,varianceShape);var offsetSnippet='0.0';if(offsetShape!=null){broadcast_util.assertAndGetBroadcastShape(xShape,offsetShape);this.variableNames.push('offset');offsetSnippet='getOffsetAtOutCoords()';}var scaleSnippet='1.0';if(scaleShape!=null){broadcast_util.assertAndGetBroadcastShape(xShape,scaleShape);this.variableNames.push('scale');scaleSnippet='getScaleAtOutCoords()';}this.outputShape=xShape;this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+offsetSnippet+";\n        float scale = "+scaleSnippet+";\n        float inv = scale / sqrt(variance + float("+varianceEpsilon+"));\n        setOutput((x - mean) * inv + offset);\n      }\n    ";}return BatchNormProgram;}();exports.BatchNormProgram=BatchNormProgram;},{"../broadcast_util":48}],61:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var broadcast_util=require("../broadcast_util");exports.ADD='return a + b;';exports.SUB='return a - b;';exports.MUL='return a * b;';exports.DIV='return a / b;';exports.EQUAL="\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n  return float(a == b);\n";var BinaryOpProgram=function(){function BinaryOpProgram(op,aShape,bShape){this.variableNames=['A','B'];this.supportsBroadcasting=true;this.outputShape=broadcast_util.assertAndGetBroadcastShape(aShape,bShape);this.userCode="\n      float binaryOperation(float a, float b) {\n        "+op+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";}return BinaryOpProgram;}();exports.BinaryOpProgram=BinaryOpProgram;},{"../broadcast_util":48}],62:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ClipProgram=function(){function ClipProgram(aShape,min,max){this.variableNames=['A'];this.outputShape=aShape;var minFixed=min.toFixed(20);var maxFixed=max.toFixed(20);this.userCode="\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, "+minFixed+", "+maxFixed+"));\n      }\n    ";}return ClipProgram;}();exports.ClipProgram=ClipProgram;},{}],63:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var concat_util=require("../concat_util");var ConcatProgram=function(){function ConcatProgram(aShape,bShape,axis){this.variableNames=['A','B'];this.outputShape=[];var yAxes=['yR','yC','yD','yW'];var concatAxis=yAxes[axis];this.outputShape=concat_util.computeOutShape(aShape,bShape,axis);var dType=getDataType(aShape.length);var unpackSnippet=getUnpack(aShape.length);var sampleCoords=getSampleCoords(aShape.length);this.userCode="\n      void main() {\n        "+dType+" coords = getOutputCoords();\n        "+unpackSnippet+"\n\n        float value = 0.0;\n        if ("+concatAxis+" < "+aShape[axis]+") {\n          value = getA("+sampleCoords+");\n        } else {\n          "+concatAxis+" -= "+aShape[axis]+";\n          value = getB("+sampleCoords+");\n        }\n\n        setOutput(value);\n      }\n    ";}return ConcatProgram;}();exports.ConcatProgram=ConcatProgram;function getSampleCoords(rank){if(rank===1){return'yR';}else if(rank===2){return'yR, yC';}else if(rank===3){return'yR, yC, yD';}else if(rank===4){return'yR, yC, yD, yW';}else{throw Error("Concat for rank "+rank+" is not yet supported");}}function getUnpack(rank){var res=rank===1?'int yR = coords;':'int yR = coords.x;';if(rank>1){res+='\nint yC = coords.y;';}if(rank>2){res+='\nint yD = coords.z;';}if(rank>3){res+='\nint yW = coords.w;';}if(rank>4){throw Error("Concat for rank "+rank+" is not yet supported");}return res;}function getDataType(rank){if(rank===1){return'int';}else if(rank===2){return'ivec2';}else if(rank===3){return'ivec3';}else if(rank===4){return'ivec4';}else{throw Error("Concat for rank "+rank+" is not yet supported");}}},{"../concat_util":49}],64:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var conv_util=require("../conv_util");var Conv2DDerWeightsProgram=function(){function Conv2DDerWeightsProgram(convInfo){this.variableNames=['x','dy'];var _a=convInfo.outShape,yNumRows=_a[0],yNumCols=_a[1],outDepth=_a[2];var _b=convInfo.inShape,xNumRows=_b[0],xNumCols=_b[1],inDepth=_b[2];var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;this.outputShape=conv_util.computeWeightsShape4D(inDepth,outDepth,convInfo.filterHeight,convInfo.filterWidth);var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int yR = 0; yR < "+yNumRows+"; yR++) {\n          int xR = wR + yR * "+strideHeight+" - "+padTop+";\n\n          if (xR < 0 || xR >= "+xNumRows+") {\n            continue;\n          }\n\n          for (int yC = 0; yC < "+yNumCols+"; yC++) {\n            int xC = wC + yC * "+strideWidth+" - "+padLeft+";\n\n            if (xC < 0 || xC >= "+xNumCols+") {\n              continue;\n            }\n\n            float dyValue = getDy(yR, yC, d2);\n            float xValue = getX(xR, xC, d1);\n            dotProd += (xValue * dyValue);\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";}return Conv2DDerWeightsProgram;}();exports.Conv2DDerWeightsProgram=Conv2DDerWeightsProgram;var Conv2DDerInputProgram=function(){function Conv2DDerInputProgram(convInfo){this.variableNames=['dy','W'];var _a=convInfo.outShape,yRows=_a[0],yCols=_a[1],outDepth=_a[2];this.outputShape=convInfo.inShape;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var padTop=filterHeight-1-convInfo.padInfo.top;var padLeft=filterWidth-1-convInfo.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d1 = coords.z;\n\n        ivec2 dyCorner = coords.xy - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n          if (dyR < 0.0 || dyR >= "+yRows+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+filterHeight+" - 1 - wR;\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n            if (dyC < 0.0 || dyC >= "+yCols+".0 || fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+filterWidth+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+outDepth+"; d2++) {\n              float xValue = getDy(idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";}return Conv2DDerInputProgram;}();exports.Conv2DDerInputProgram=Conv2DDerInputProgram;var Conv2DDerBiasProgram=function(){function Conv2DDerBiasProgram(yShape){this.variableNames=['dy'];var yNumRows=yShape[0],yNumCols=yShape[1],outputDepth=yShape[2];this.outputShape=[outputDepth];this.userCode="\n      void main() {\n        int d2 = getOutputCoords();\n\n        float derBias = 0.0;\n        for (int yR = 0; yR < "+yNumRows+"; yR++) {\n          for (int yC = 0; yC < "+yNumCols+"; yC++) {\n            derBias += getDy(yR, yC, d2);\n          }\n        }\n        setOutput(derBias);\n      }\n    ";}return Conv2DDerBiasProgram;}();exports.Conv2DDerBiasProgram=Conv2DDerBiasProgram;},{"../conv_util":50}],65:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var Conv2DProgram=function(){function Conv2DProgram(convInfo,hasBias){this.variableNames=['x','W'];if(hasBias){this.variableNames.push('bias');}this.outputShape=convInfo.outShape;var biasSnippet=hasBias?'dotProd += getBias(d2);':'';var _a=convInfo.inShape,xNumRows=_a[0],xNumCols=_a[1],inputDepth=_a[2];var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var inputDepthNearestVec4=Math.floor(inputDepth/4)*4;var inputDepthVec4Remainder=inputDepth%4;this.userCode="\n      const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d2 = coords.z;\n\n        ivec2 xRCCorner = coords.xy * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+xNumRows+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= "+xNumCols+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+inputDepthNearestVec4+"; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(xR, xC, d1),\n                getX(xR, xC, d1 + 1),\n                getX(xR, xC, d1 + 2),\n                getX(xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if ("+(inputDepthVec4Remainder===1)+") {\n              dotProd +=\n                getX(xR, xC, "+inputDepthNearestVec4+") *\n                getW(wR, wC, "+inputDepthNearestVec4+", d2);\n            } else if ("+(inputDepthVec4Remainder===2)+") {\n              vec2 xValues = vec2(\n                getX(xR, xC, "+inputDepthNearestVec4+"),\n                getX(xR, xC, "+inputDepthNearestVec4+" + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, "+inputDepthNearestVec4+", d2),\n                getW(wR, wC, "+inputDepthNearestVec4+" + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if ("+(inputDepthVec4Remainder===3)+") {\n              vec3 xValues = vec3(\n                getX(xR, xC, "+inputDepthNearestVec4+"),\n                getX(xR, xC, "+inputDepthNearestVec4+" + 1),\n                getX(xR, xC, "+inputDepthNearestVec4+" + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, "+inputDepthNearestVec4+", d2),\n                getW(wR, wC, "+inputDepthNearestVec4+" + 1, d2),\n                getW(wR, wC, "+inputDepthNearestVec4+" + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        "+biasSnippet+"\n        setOutput(dotProd);\n      }\n    ";}return Conv2DProgram;}();exports.Conv2DProgram=Conv2DProgram;},{}],66:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var Copy2DProgram=function(){function Copy2DProgram(srcNumCols,destNumCols){this.variableNames=['source'];this.outputShape=null;this.userCode="\n      uniform ivec2 sourceStart;\n      uniform ivec2 destStart;\n\n      void main() {\n        ivec2 destCoords = getOutputCoords() - destStart;\n        int index = destCoords.x * "+destNumCols+" + destCoords.y;\n        int r = index / "+srcNumCols+";\n        ivec2 sourceCoords = sourceStart + ivec2(r, index - r * "+srcNumCols+");\n        setOutput(getSource(sourceCoords.x, sourceCoords.y));\n      }\n    ";}Copy2DProgram.prototype.getCustomSetupFunc=function(sourceStart,destStart,destSize){return function(gpgpu,webGLProgram){gpgpu.setOutputMatrixWriteRegion(destStart[0],destSize[0],destStart[1],destSize[1]);var sourceStartCRLoc=gpgpu.getUniformLocation(webGLProgram,'sourceStart');gpgpu.gl.uniform2i(sourceStartCRLoc,sourceStart[0],sourceStart[1]);var destStartCRLoc=gpgpu.getUniformLocation(webGLProgram,'destStart');gpgpu.gl.uniform2i(destStartCRLoc,destStart[0],destStart[1]);};};return Copy2DProgram;}();exports.Copy2DProgram=Copy2DProgram;},{}],67:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator["throw"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value);}).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=y[op[0]&2?"return":op[0]?"throw":"next"])&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[0,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../../environment");var util=require("../../util");var gpgpu_util=require("./gpgpu_util");var tex_util=require("./tex_util");var webgl_util=require("./webgl_util");var GPGPUContext=function(){function GPGPUContext(gl){this.outputTexture=null;this.program=null;this.disposed=false;this.autoDebugValidate=false;if(gl!=null){this.gl=gl;}else{this.gl=gpgpu_util.createWebGLContext();}if(environment_1.ENV.get('WEBGL_VERSION')===1){this.textureFloatExtension=webgl_util.getExtensionOrThrow(this.gl,'OES_texture_float');this.colorBufferFloatExtension=this.gl.getExtension('WEBGL_color_buffer_float');}else{this.colorBufferFloatExtension=webgl_util.getExtensionOrThrow(this.gl,'EXT_color_buffer_float');}this.loseContextExtension=webgl_util.getExtensionOrThrow(this.gl,'WEBGL_lose_context');if(environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')){this.getBufferSubDataAsyncExtension=this.gl.getExtension('WEBGL_get_buffer_sub_data_async');}this.vertexBuffer=gpgpu_util.createVertexBuffer(this.gl);this.indexBuffer=gpgpu_util.createIndexBuffer(this.gl);this.framebuffer=webgl_util.createFramebuffer(this.gl);}GPGPUContext.prototype.dispose=function(){var _this=this;this.throwIfDisposed();if(this.program!=null){console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.'+' This is probably a resource leak, delete the program with '+'GPGPUContext.deleteProgram before disposing.');}if(this.outputTexture!=null){console.warn('Disposing a GPGPUContext that still has a bound output matrix '+'texture.  This is probably a resource leak, delete the output '+'matrix texture with GPGPUContext.deleteMatrixTexture before '+'disposing.');}var gl=this.gl;webgl_util.callAndCheck(gl,function(){return gl.finish();});webgl_util.callAndCheck(gl,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,null);});webgl_util.callAndCheck(gl,function(){return gl.deleteFramebuffer(_this.framebuffer);});webgl_util.callAndCheck(gl,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,null);});webgl_util.callAndCheck(gl,function(){return gl.deleteBuffer(_this.vertexBuffer);});webgl_util.callAndCheck(gl,function(){return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null);});webgl_util.callAndCheck(gl,function(){return gl.deleteBuffer(_this.indexBuffer);});this.loseContextExtension.loseContext();this.disposed=true;};GPGPUContext.prototype.enableAutomaticDebugValidation=function(enabled){this.autoDebugValidate=enabled;webgl_util.enableDebugWebGLErrorChecking(enabled);};GPGPUContext.prototype.createMatrixTexture=function(rows,columns){this.throwIfDisposed();return gpgpu_util.createMatrixTexture(this.gl,rows,columns);};GPGPUContext.prototype.uploadPixelDataToTexture=function(texture,pixels){this.throwIfDisposed();gpgpu_util.uploadPixelDataToTexture(this.gl,texture,pixels);};GPGPUContext.prototype.createPackedMatrixTexture=function(rows,columns){this.throwIfDisposed();return gpgpu_util.createPackedMatrixTexture(this.gl,rows,columns);};GPGPUContext.prototype.deleteMatrixTexture=function(texture){var _this=this;this.throwIfDisposed();if(this.outputTexture===texture){webgl_util.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer);this.outputTexture=null;}webgl_util.callAndCheck(this.gl,function(){return _this.gl.deleteTexture(texture);});};GPGPUContext.prototype.uploadMatrixToTexture=function(texture,rows,columns,matrix){this.throwIfDisposed();var numChannels=1;return gpgpu_util.uploadMatrixToTexture(this.gl,texture,rows,columns,matrix,numChannels);};GPGPUContext.prototype.uploadMatrixToPackedTexture=function(texture,rows,columns,matrix){this.throwIfDisposed();return gpgpu_util.uploadMatrixToPackedTexture(this.gl,texture,rows,columns,matrix);};GPGPUContext.prototype.downloadMatrixFromTexture=function(texture,rows,columns){var _this=this;return this.downloadMatrixDriver(texture,function(){return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl,rows,columns);});};GPGPUContext.prototype.downloadMatrixFromTextureAsync=function(texture,rows,columns){return __awaiter(this,void 0,void 0,function(){var _this=this;return __generator(this,function(_a){if(this.getBufferSubDataAsyncExtension==null){throw new Error("Cannot download matrix from output texture asynchronously, "+"WEBGL_get_buffer_sub_data_async is not enabled.");}return[2,this.downloadMatrixDriverAsync(texture,function(){return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl,_this.getBufferSubDataAsyncExtension,rows,columns);})];});});};GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture=function(texture,rows,columns,channels){var _this=this;return this.downloadMatrixDriver(texture,function(){return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl,rows,columns,channels);});};GPGPUContext.prototype.downloadMatrixFromPackedTexture=function(texture,rows,columns){var _this=this;return this.downloadMatrixDriver(texture,function(){return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl,rows,columns);});};GPGPUContext.prototype.createProgram=function(fragmentShaderSource){this.throwIfDisposed();var gl=this.gl;var fragmentShader=webgl_util.createFragmentShader(gl,fragmentShaderSource);var vertexShader=gpgpu_util.createVertexShader(gl);var program=webgl_util.createProgram(gl);webgl_util.callAndCheck(gl,function(){return gl.attachShader(program,vertexShader);});webgl_util.callAndCheck(gl,function(){return gl.attachShader(program,fragmentShader);});webgl_util.linkProgram(gl,program);if(this.autoDebugValidate){webgl_util.validateProgram(gl,program);}return program;};GPGPUContext.prototype.deleteProgram=function(program){var _this=this;this.throwIfDisposed();if(program===this.program){this.program=null;}if(program!=null){webgl_util.callAndCheck(this.gl,function(){return _this.gl.deleteProgram(program);});}};GPGPUContext.prototype.setProgram=function(program){var _this=this;this.throwIfDisposed();this.program=program;if(this.program!=null&&this.autoDebugValidate){webgl_util.validateProgram(this.gl,this.program);}webgl_util.callAndCheck(this.gl,function(){return _this.gl.useProgram(program);});};GPGPUContext.prototype.getUniformLocation=function(program,uniformName){this.throwIfDisposed();return webgl_util.getProgramUniformLocationOrThrow(this.gl,program,uniformName);};GPGPUContext.prototype.getAttributeLocation=function(program,attribute){var _this=this;this.throwIfDisposed();return webgl_util.callAndCheck(this.gl,function(){return _this.gl.getAttribLocation(program,attribute);});};GPGPUContext.prototype.getUniformLocationNoThrow=function(program,uniformName){this.throwIfDisposed();return this.gl.getUniformLocation(program,uniformName);};GPGPUContext.prototype.setInputMatrixTexture=function(inputMatrixTexture,uniformLocation,textureUnit){this.throwIfDisposed();this.throwIfNoProgram();webgl_util.bindTextureToProgramUniformSampler(this.gl,this.program,inputMatrixTexture,uniformLocation,textureUnit);};GPGPUContext.prototype.setOutputMatrixTexture=function(outputMatrixTexture,rows,columns){this.setOutputMatrixTextureDriver(outputMatrixTexture,columns,rows);};GPGPUContext.prototype.setOutputPackedMatrixTexture=function(outputPackedMatrixTexture,rows,columns){this.throwIfDisposed();var _a=tex_util.getPackedMatrixTextureShapeWidthHeight(rows,columns),width=_a[0],height=_a[1];this.setOutputMatrixTextureDriver(outputPackedMatrixTexture,width,height);};GPGPUContext.prototype.setOutputMatrixWriteRegion=function(startRow,numRows,startColumn,numColumns){this.setOutputMatrixWriteRegionDriver(startColumn,startRow,numColumns,numRows);};GPGPUContext.prototype.setOutputPackedMatrixWriteRegion=function(startRow,numRows,startColumn,numColumns){throw new Error('setOutputPackedMatrixWriteRegion not implemented.');};GPGPUContext.prototype.debugValidate=function(){if(this.program!=null){webgl_util.validateProgram(this.gl,this.program);}webgl_util.validateFramebuffer(this.gl);};GPGPUContext.prototype.executeProgram=function(attribLocations){this.throwIfDisposed();this.throwIfNoProgram();var gl=this.gl;gpgpu_util.bindVertexProgramAttributeStreams(gl,this.program,this.vertexBuffer,attribLocations);if(this.autoDebugValidate){this.debugValidate();}webgl_util.callAndCheck(gl,function(){return gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);});};GPGPUContext.prototype.blockUntilAllProgramsCompleted=function(){var _this=this;this.throwIfDisposed();webgl_util.callAndCheck(this.gl,function(){return _this.gl.finish();});};GPGPUContext.prototype.runQuery=function(queryFn){if(environment_1.ENV.get('WEBGL_VERSION')===2){return this.runQueryWebGL2(queryFn);}return this.runQueryWebGL1(queryFn);};GPGPUContext.prototype.runQueryWebGL2=function(benchmark){var _this=this;var ext=webgl_util.getExtensionOrThrow(this.gl,'EXT_disjoint_timer_query_webgl2');var query=this.gl.createQuery();this.gl.beginQuery(ext.TIME_ELAPSED_EXT,query);benchmark();this.gl.endQuery(ext.TIME_ELAPSED_EXT);return new Promise(function(resolve,reject){var queryGPU=function queryGPU(){var available=_this.gl.getQueryParameter(query,_this.gl.QUERY_RESULT_AVAILABLE);var disjoint=_this.gl.getParameter(ext.GPU_DISJOINT_EXT);return available&&!disjoint;};var getTimeElapsed=function getTimeElapsed(){var timeElapsedNanos=_this.gl.getQueryParameter(query,_this.gl.QUERY_RESULT);resolve(timeElapsedNanos/1000000);};var resolveWithWarning=function resolveWithWarning(){console.warn('Disjoint query timer never available.');resolve(-1);};util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);});};GPGPUContext.prototype.runQueryWebGL1=function(benchmark){var _this=this;var ext=webgl_util.getExtensionOrThrow(this.gl,'EXT_disjoint_timer_query');var query=ext.createQueryEXT();ext.beginQueryEXT(ext.TIME_ELAPSED_EXT,query);benchmark();ext.endQueryEXT(ext.TIME_ELAPSED_EXT);return new Promise(function(resolve,reject){var queryGPU=function queryGPU(){var available=ext.getQueryObjectEXT(query,ext.QUERY_RESULT_AVAILABLE_EXT);var disjoint=_this.gl.getParameter(ext.GPU_DISJOINT_EXT);return available&&!disjoint;};var getTimeElapsed=function getTimeElapsed(){var timeElapsedNanos=ext.getQueryObjectEXT(query,ext.QUERY_RESULT_EXT);resolve(timeElapsedNanos/1000000);};var resolveWithWarning=function resolveWithWarning(){console.warn('Disjoint query timer never available.');resolve(-1);};util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);});};GPGPUContext.prototype.downloadMatrixDriverSetup=function(texture){this.throwIfDisposed();webgl_util.bindColorTextureToFramebuffer(this.gl,texture,this.framebuffer);if(this.autoDebugValidate){webgl_util.validateFramebuffer(this.gl);}};GPGPUContext.prototype.downloadMatrixDriverTeardown=function(){if(this.outputTexture!=null){webgl_util.bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer);if(this.autoDebugValidate){webgl_util.validateFramebuffer(this.gl);}}else{webgl_util.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer);}};GPGPUContext.prototype.downloadMatrixDriver=function(texture,downloadAndDecode){this.downloadMatrixDriverSetup(texture);var result=downloadAndDecode();this.downloadMatrixDriverTeardown();return result;};GPGPUContext.prototype.downloadMatrixDriverAsync=function(texture,downloadAndDecode){return __awaiter(this,void 0,void 0,function(){var result;return __generator(this,function(_a){switch(_a.label){case 0:this.downloadMatrixDriverSetup(texture);return[4,downloadAndDecode()];case 1:result=_a.sent();this.downloadMatrixDriverTeardown();return[2,result];}});});};GPGPUContext.prototype.setOutputMatrixTextureDriver=function(outputMatrixTextureMaybePacked,width,height){this.throwIfDisposed();var gl=this.gl;webgl_util.bindColorTextureToFramebuffer(gl,outputMatrixTextureMaybePacked,this.framebuffer);if(this.autoDebugValidate){webgl_util.validateFramebuffer(gl);}this.outputTexture=outputMatrixTextureMaybePacked;webgl_util.callAndCheck(gl,function(){return gl.viewport(0,0,width,height);});webgl_util.callAndCheck(gl,function(){return gl.scissor(0,0,width,height);});};GPGPUContext.prototype.setOutputMatrixWriteRegionDriver=function(x,y,width,height){var _this=this;this.throwIfDisposed();webgl_util.callAndCheck(this.gl,function(){return _this.gl.scissor(x,y,width,height);});};GPGPUContext.prototype.throwIfDisposed=function(){if(this.disposed){throw new Error('Attempted to use disposed GPGPUContext.');}};GPGPUContext.prototype.throwIfNoProgram=function(){if(this.program==null){throw new Error('No GPU program is currently set.');}};return GPGPUContext;}();exports.GPGPUContext=GPGPUContext;},{"../../environment":8,"../../util":88,"./gpgpu_util":69,"./tex_util":82,"./webgl_util":86}],68:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../../environment");var util=require("../../util");var shader_compiler=require("./shader_compiler");var ATTRIBUTE_NAMES=['uv','clipSpacePos'];var NAN_UNIFORM_NAME='NaN';function shouldUploadNaNUniform(){return!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');}function compileProgram(gpgpu,program,inputs,output){var userCode=program.userCode;var inputInfos=inputs.map(function(input,i){var shapeInfo={logicalShape:input.shape,texShape:input.getTextureShapeRC(),textureType:input.getData().textureType};return{name:program.variableNames[i],shapeInfo:shapeInfo};});var inShapeInfos=inputInfos.map(function(x){return x.shapeInfo;});var outShapeInfo={logicalShape:output.shape,texShape:output.getTextureShapeRC(),textureType:output.getData().textureType};var source=shader_compiler.makeShader(inputInfos,outShapeInfo,userCode,program.supportsBroadcasting===true,program.numBatchDims);var webGLProgram=gpgpu.createProgram(source);var uniformLocations={};for(var i=0;i<program.variableNames.length;i++){var uniformName=program.variableNames[i];uniformLocations[uniformName]=gpgpu.getUniformLocation(webGLProgram,uniformName);}var attributeLocations={};ATTRIBUTE_NAMES.forEach(function(attribute){attributeLocations[attribute]=gpgpu.getAttributeLocation(webGLProgram,attribute);});if(shouldUploadNaNUniform()){uniformLocations[NAN_UNIFORM_NAME]=gpgpu.getUniformLocation(webGLProgram,NAN_UNIFORM_NAME);}return{program:program,source:source,webGLProgram:webGLProgram,uniformLocations:uniformLocations,attributeLocations:attributeLocations,gpgpu:gpgpu,inShapeInfos:inShapeInfos,outShapeInfo:outShapeInfo};}exports.compileProgram=compileProgram;function validateBinaryAndProgram(shapeInfos,inputs,numBatchDims){if(shapeInfos.length!==inputs.length){throw Error("Binary was compiled with "+shapeInfos.length+" inputs, but "+("was executed with "+inputs.length+" inputs"));}shapeInfos.forEach(function(s,i){var shapeA=s.logicalShape;var texShapeA=s.texShape;var shapeB=inputs[i].shape;var texShapeB=inputs[i].getTextureShapeRC();if(!numBatchDims&&!util.arraysEqual(shapeA,shapeB)){throw Error("Binary was compiled with different shapes than "+("the current args. Shapes "+shapeA+" and "+shapeB+" must match"));}if(!numBatchDims&&!util.arraysEqual(texShapeA,texShapeB)){throw Error("Binary was compiled with different texture shapes than the"+(" current args. Shape "+texShapeA+" and "+texShapeB+" must match"));}});}function runProgram(binary,inputs,output,customSetup){validateBinaryAndProgram(binary.inShapeInfos,inputs,binary.program.numBatchDims);validateBinaryAndProgram([binary.outShapeInfo],[output],binary.program.numBatchDims);var outTex=output.getTexture();var outTexShape=output.getTextureShapeRC();var gpgpu=binary.gpgpu;gpgpu.setOutputMatrixTexture(outTex,outTexShape[0],outTexShape[1]);gpgpu.setProgram(binary.webGLProgram);inputs.forEach(function(input,i){var tex=input.getTexture();var variableName=binary.program.variableNames[i];var variableUniformLocation=binary.uniformLocations[variableName];gpgpu.setInputMatrixTexture(tex,variableUniformLocation,i);});if(shouldUploadNaNUniform()){gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME],NaN);}if(customSetup!=null){customSetup(gpgpu,binary.webGLProgram);}gpgpu.executeProgram(binary.attributeLocations);}exports.runProgram=runProgram;function makeShaderKey(program,inputs,output){var keyInputs='';inputs.concat(output).forEach(function(x){keyInputs+=x.shape+"_"+x.getTextureShapeRC();});var keyUserCode=program.userCode;var keyBroadcast=(program.supportsBroadcasting===true).toString();var key=program.constructor.name;key+='_'+keyBroadcast+'_'+keyInputs+'_'+keyUserCode;return key;}exports.makeShaderKey=makeShaderKey;},{"../../environment":8,"../../util":88,"./shader_compiler":80}],69:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator["throw"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value);}).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=y[op[0]&2?"return":op[0]?"throw":"next"])&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[0,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../../environment");var tex_util=require("./tex_util");var webgl_util=require("./webgl_util");function getWebGLContextAttributes(){return{alpha:false,antialias:false,premultipliedAlpha:false,preserveDrawingBuffer:false,depth:false,stencil:false,failIfMajorPerformanceCaveat:true};}exports.getWebGLContextAttributes=getWebGLContextAttributes;function createWebGLContext(canvas){var attributes=getWebGLContextAttributes();var gl;if(canvas!=null){gl=webgl_util.createWebGLRenderingContextFromCanvas(canvas,attributes);}else{gl=webgl_util.createWebGLRenderingContext(attributes);}webgl_util.callAndCheck(gl,function(){return gl.disable(gl.DEPTH_TEST);});webgl_util.callAndCheck(gl,function(){return gl.disable(gl.STENCIL_TEST);});webgl_util.callAndCheck(gl,function(){return gl.disable(gl.BLEND);});webgl_util.callAndCheck(gl,function(){return gl.disable(gl.DITHER);});webgl_util.callAndCheck(gl,function(){return gl.disable(gl.POLYGON_OFFSET_FILL);});webgl_util.callAndCheck(gl,function(){return gl.disable(gl.SAMPLE_COVERAGE);});webgl_util.callAndCheck(gl,function(){return gl.enable(gl.SCISSOR_TEST);});webgl_util.callAndCheck(gl,function(){return gl.enable(gl.CULL_FACE);});webgl_util.callAndCheck(gl,function(){return gl.cullFace(gl.BACK);});return gl;}exports.createWebGLContext=createWebGLContext;function createVertexShader(gl){var vertexShaderSource="\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";return webgl_util.createVertexShader(gl,vertexShaderSource);}exports.createVertexShader=createVertexShader;function createVertexBuffer(gl){var vertexArray=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return webgl_util.createStaticVertexBuffer(gl,vertexArray);}exports.createVertexBuffer=createVertexBuffer;function createIndexBuffer(gl){var triangleVertexIndices=new Uint16Array([0,1,2,2,1,3]);return webgl_util.createStaticIndexBuffer(gl,triangleVertexIndices);}exports.createIndexBuffer=createIndexBuffer;function getTextureInternalFormat(gl,numChannels){if(!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')){return gl.RGBA;}if(environment_1.ENV.get('WEBGL_VERSION')===2){if(numChannels===4){return gl.RGBA32F;}return gl.R32F;}return gl.RGBA;}function getTextureFormat(gl,numChannels){if(!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')){return gl.RGBA;}if(environment_1.ENV.get('WEBGL_VERSION')===2){if(numChannels===4){return gl.RGBA;}return gl.RED;}return gl.RGBA;}function getTextureType(gl){if(!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')){return gl.UNSIGNED_BYTE;}return gl.FLOAT;}function createAndConfigureTexture(gl,width,height,numChannels){webgl_util.validateTextureSize(gl,width,height);var texture=webgl_util.createTexture(gl);var tex2d=gl.TEXTURE_2D;var internalFormat=getTextureInternalFormat(gl,numChannels);var format=getTextureFormat(gl,numChannels);webgl_util.callAndCheck(gl,function(){return gl.bindTexture(tex2d,texture);});webgl_util.callAndCheck(gl,function(){return gl.texParameteri(tex2d,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);});webgl_util.callAndCheck(gl,function(){return gl.texParameteri(tex2d,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);});webgl_util.callAndCheck(gl,function(){return gl.texParameteri(tex2d,gl.TEXTURE_MIN_FILTER,gl.NEAREST);});webgl_util.callAndCheck(gl,function(){return gl.texParameteri(tex2d,gl.TEXTURE_MAG_FILTER,gl.NEAREST);});webgl_util.callAndCheck(gl,function(){return gl.texImage2D(tex2d,0,internalFormat,width,height,0,format,getTextureType(gl),null);});webgl_util.callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,null);});return texture;}function createMatrixTexture(gl,rows,columns){var _a=tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows,columns),width=_a[0],height=_a[1];var numChannels=1;return createAndConfigureTexture(gl,width,height,numChannels);}exports.createMatrixTexture=createMatrixTexture;function createColorMatrixTexture(gl,rows,columns){var _a=tex_util.getColorMatrixTextureShapeWidthHeight(rows,columns),width=_a[0],height=_a[1];var numChannels=4;return createAndConfigureTexture(gl,width,height,numChannels);}exports.createColorMatrixTexture=createColorMatrixTexture;function createPackedMatrixTexture(gl,rows,columns){var _a=tex_util.getPackedMatrixTextureShapeWidthHeight(rows,columns),width=_a[0],height=_a[1];var numChannels=4;return createAndConfigureTexture(gl,width,height,numChannels);}exports.createPackedMatrixTexture=createPackedMatrixTexture;function bindVertexProgramAttributeStreams(gl,program,vertexBuffer,attribLocations){var posOffset=0;var uvOffset=3*4;var stride=3*4+2*4;webgl_util.callAndCheck(gl,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);});webgl_util.bindVertexBufferToProgramAttribute(gl,program,'clipSpacePos',vertexBuffer,3,stride,posOffset,attribLocations);webgl_util.bindVertexBufferToProgramAttribute(gl,program,'uv',vertexBuffer,2,stride,uvOffset,attribLocations);}exports.bindVertexProgramAttributeStreams=bindVertexProgramAttributeStreams;function uploadPixelDataToTexture(gl,texture,pixels){webgl_util.callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,texture);});webgl_util.callAndCheck(gl,function(){return gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,pixels);});webgl_util.callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,null);});}exports.uploadPixelDataToTexture=uploadPixelDataToTexture;function uploadDataToTexture(gl,texture,width,height,data,numChannels){var textureFormat=getTextureFormat(gl,numChannels);webgl_util.validateTextureSize(gl,width,height);webgl_util.callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,texture);});webgl_util.callAndCheck(gl,function(){return gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,width,height,textureFormat,getTextureType(gl),data);});webgl_util.callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,null);});}function uploadMatrixToTexture(gl,texture,rows,columns,matrix,numChannels){var _a=tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];var unpackedArray;if(environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')){var channelsPerTexture=numChannels===1?webgl_util.getChannelsPerTexture():numChannels;if(channelsPerTexture===1){unpackedArray=matrix;}else{unpackedArray=new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length,channelsPerTexture));tex_util.encodeMatrixToUnpackedArray(matrix,unpackedArray,channelsPerTexture);}}else{unpackedArray=tex_util.encodeFloatArray(matrix);}uploadDataToTexture(gl,texture,w,h,unpackedArray,numChannels);}exports.uploadMatrixToTexture=uploadMatrixToTexture;function uploadMatrixToPackedTexture(gl,texture,rows,columns,matrix){var _a=tex_util.getPackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];var packedRGBA=new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows,columns));tex_util.encodeMatrixToPackedRGBA(matrix,rows,columns,packedRGBA);var numChannels=4;uploadDataToTexture(gl,texture,w,h,packedRGBA,numChannels);}exports.uploadMatrixToPackedTexture=uploadMatrixToPackedTexture;function getDownloadTargetArrayBuffer(rows,columns,channelsPerTexture){var isFloatTexture=environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');var downloadTarget;if(isFloatTexture){downloadTarget=new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows*columns,channelsPerTexture));}else{downloadTarget=new Uint8Array(rows*columns*channelsPerTexture);}return downloadTarget;}function decodeDownloadTargetArrayBuffer(downloadTarget,rows,columns,channelsPerPixel){var isFloatTexture=environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');if(isFloatTexture){var matrix=new Float32Array(rows*columns);tex_util.decodeMatrixFromUnpackedArray(downloadTarget,matrix,channelsPerPixel);return matrix;}else{return tex_util.decodeToFloatArray(downloadTarget);}}function downloadMatrixFromOutputTextureAsync(gl,getBufferSubDataAsyncExtension,rows,columns){return __awaiter(this,void 0,void 0,function(){var gl2,channelsPerPixel,downloadTarget,bufferSizeBytes,buffer;return __generator(this,function(_a){switch(_a.label){case 0:gl2=gl;channelsPerPixel=4;downloadTarget=getDownloadTargetArrayBuffer(rows,columns,channelsPerPixel);bufferSizeBytes=downloadTarget instanceof Float32Array?downloadTarget.length*4:downloadTarget;buffer=gl.createBuffer();webgl_util.callAndCheck(gl,function(){return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER,buffer);});webgl_util.callAndCheck(gl,function(){return gl.bufferData(gl2.PIXEL_PACK_BUFFER,bufferSizeBytes,gl.STATIC_DRAW);});webgl_util.callAndCheck(gl,function(){return gl2.readPixels(0,0,columns,rows,gl.RGBA,getTextureType(gl),0);});return[4,getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER,0,downloadTarget)];case 1:_a.sent();return[2,decodeDownloadTargetArrayBuffer(downloadTarget,rows,columns,channelsPerPixel)];}});});}exports.downloadMatrixFromOutputTextureAsync=downloadMatrixFromOutputTextureAsync;function downloadMatrixFromOutputTexture(gl,rows,columns){var _a=tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];var channelsPerPixel=4;var downloadTarget=getDownloadTargetArrayBuffer(rows,columns,channelsPerPixel);webgl_util.callAndCheck(gl,function(){return gl.readPixels(0,0,w,h,gl.RGBA,getTextureType(gl),downloadTarget);});return decodeDownloadTargetArrayBuffer(downloadTarget,rows,columns,channelsPerPixel);}exports.downloadMatrixFromOutputTexture=downloadMatrixFromOutputTexture;function downloadMatrixFromRGBAColorTexture(gl,rows,columns,channels){var size=rows*columns*4;var downloadTarget=new Uint8Array(size);webgl_util.callAndCheck(gl,function(){return gl.readPixels(0,0,columns,rows,gl.RGBA,gl.UNSIGNED_BYTE,downloadTarget);});var packedRGBA=new Float32Array(size);for(var i=0;i<downloadTarget.length;i++){packedRGBA[i]=downloadTarget[i];}var matrix=new Float32Array(rows*columns*channels);tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA,matrix,channels);return matrix;}exports.downloadMatrixFromRGBAColorTexture=downloadMatrixFromRGBAColorTexture;function downloadMatrixFromPackedOutputTexture(gl,rows,columns){var _a=tex_util.getPackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];var packedRGBA=new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows,columns));webgl_util.callAndCheck(gl,function(){return gl.readPixels(0,0,w,h,gl.RGBA,getTextureType(gl),packedRGBA);});var matrix=new Float32Array(rows*columns);return tex_util.decodeMatrixFromPackedRGBA(packedRGBA,rows,columns,matrix);}exports.downloadMatrixFromPackedOutputTexture=downloadMatrixFromPackedOutputTexture;},{"../../environment":8,"./tex_util":82,"./webgl_util":86}],70:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../../util");var axis_util=require("../axis_util");var LogSumExpProgram=function(){function LogSumExpProgram(shape,axes){this.variableNames=['A'];var _a=axis_util.computeOutAndReduceShapes(shape,axes),outShape=_a[0],reduceShape=_a[1];this.outputShape=outShape;this.numBatchDims=outShape.length;var size=util.sizeFromShape(reduceShape);var sizeNearestVec4=Math.floor(size/4)*4;var sizeVec4Remainder=size%4;var r1=sizeNearestVec4;var r2=sizeNearestVec4+1;var r3=sizeNearestVec4+2;this.userCode="\n      const vec2 ones2 = vec2(1, 1);\n      const vec3 ones3 = vec3(1, 1, 1);\n      const vec4 ones4 = vec4(1, 1, 1, 1);\n\n      void main() {\n        vec4 maxVec = vec4(getAFlat(0));\n        for (int i = 0; i < "+sizeNearestVec4+"; i += 4) {\n          vec4 aVec = vec4(getAFlat(i), getAFlat(i+1),\n                           getAFlat(i+2), getAFlat(i+3));\n          maxVec = max(maxVec, aVec);\n        }\n        if ("+(sizeVec4Remainder===1)+") {\n          maxVec = max(maxVec, vec4(maxVec.xyz, getAFlat("+r1+")));\n        } else if ("+(sizeVec4Remainder===2)+") {\n          vec2 aVec = vec2(getAFlat("+r1+"), getAFlat("+r2+"));\n          maxVec = max(maxVec, vec4(maxVec.xy, aVec));\n        } else if ("+(sizeVec4Remainder===3)+") {\n          vec3 aVec = vec3(getAFlat("+r1+"), getAFlat("+r2+"), getAFlat("+r3+"));\n          maxVec = max(maxVec, vec4(maxVec.x, aVec));\n        }\n        float finalMax = max(maxVec.x, max(maxVec.y, max(maxVec.z, maxVec.w)));\n\n        float expSum = 0.0;\n        for (int i = 0; i < "+sizeNearestVec4+"; i += 4) {\n          vec4 aVec = vec4(getAFlat(i), getAFlat(i+1),\n                           getAFlat(i+2), getAFlat(i+3));\n          expSum += dot(ones4, exp(aVec - finalMax));\n        }\n        if ("+(sizeVec4Remainder===1)+") {\n          expSum += exp(getAFlat("+r1+") - finalMax);\n        } else if ("+(sizeVec4Remainder===2)+") {\n          vec2 aVec = vec2(getAFlat("+r1+"), getAFlat("+r2+"));\n          expSum += dot(ones2, exp(aVec - finalMax));\n        } else if ("+(sizeVec4Remainder===3)+") {\n          vec3 aVec = vec3(getAFlat("+r1+"), getAFlat("+r2+"), getAFlat("+r3+"));\n          expSum += dot(ones3, exp(aVec - finalMax));\n        }\n\n        setOutput(finalMax + log(expSum));\n      }\n    ";}return LogSumExpProgram;}();exports.LogSumExpProgram=LogSumExpProgram;},{"../../util":88,"../axis_util":47}],71:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var MaxPool2DBackpropProgram=function(){function MaxPool2DBackpropProgram(convInfo){this.variableNames=['dy','maxPos'];this.outputShape=convInfo.inShape;var dyRows=convInfo.outShape[0];var dyCols=convInfo.outShape[1];var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var padTop=filterHeight-1-convInfo.padInfo.top;var padLeft=filterWidth-1-convInfo.padInfo.left;var lastIndex=filterHeight*filterWidth-1;this.userCode="\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d = coords.z;\n\n        ivec2 dyRCCorner = coords.xy - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n          if (dyR < 0.0 || dyR >= "+dyRows+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n            if (dyC < 0.0 || dyC >= "+dyCols+".0 || fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(idyR, idyC, d);\n            int maxPosValue = "+lastIndex+" - int(getMaxPos(idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+filterWidth+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";}return MaxPool2DBackpropProgram;}();exports.MaxPool2DBackpropProgram=MaxPool2DBackpropProgram;},{}],72:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../../util");var axis_util=require("../axis_util");var MinMaxProgram=function(){function MinMaxProgram(shape,axes,op){this.variableNames=['A'];var _a=axis_util.computeOutAndReduceShapes(shape,axes),outShape=_a[0],reduceShape=_a[1];this.outputShape=outShape;this.numBatchDims=outShape.length;var size=util.sizeFromShape(reduceShape);var sizeNearestVec4=Math.floor(size/4)*4;var sizeVec4Remainder=size%4;var r1=sizeNearestVec4;var r2=sizeNearestVec4+1;var r3=sizeNearestVec4+2;this.userCode="\n      void main() {\n        vec4 bestVec = vec4(getAFlat(0));\n        for (int i = 0; i < "+sizeNearestVec4+"; i += 4) {\n          vec4 aVec = vec4(getAFlat(i), getAFlat(i+1),\n                           getAFlat(i+2), getAFlat(i+3));\n          if (hasNaN(aVec)) {\n            setOutput(getNaN(aVec));\n            return;\n          }\n          bestVec = "+op+"(bestVec, aVec);\n        }\n        vec4 aVec;\n        if ("+(sizeVec4Remainder===1)+") {\n          aVec = vec4(bestVec.xyz, getAFlat("+r1+"));\n        } else if ("+(sizeVec4Remainder===2)+") {\n          aVec = vec4(bestVec.xy, vec2(getAFlat("+r1+"), getAFlat("+r2+")));\n        } else if ("+(sizeVec4Remainder===3)+") {\n          aVec = vec4(bestVec.x,\n                      vec3(getAFlat("+r1+"), getAFlat("+r2+"), getAFlat("+r3+")));\n        }\n        if ("+(sizeVec4Remainder>0)+") {\n          if (hasNaN(aVec)) {\n            setOutput(getNaN(aVec));\n            return;\n          }\n          bestVec = "+op+"(bestVec, aVec);\n        }\n\n        float final = "+op+"(bestVec.x, "+op+"(bestVec.y,\n                      "+op+"(bestVec.z, bestVec.w)));\n        setOutput(final);\n      }\n    ";}return MinMaxProgram;}();exports.MinMaxProgram=MinMaxProgram;},{"../../util":88,"../axis_util":47}],73:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var math_1=require("../math");var MatMulProgram=function(){function MatMulProgram(aShape,bShape,aOrient,bOrient){if(aOrient===void 0){aOrient=math_1.MatrixOrientation.REGULAR;}if(bOrient===void 0){bOrient=math_1.MatrixOrientation.REGULAR;}this.variableNames=['matrixA','matrixB'];var outerShapeA=aOrient===math_1.MatrixOrientation.REGULAR?aShape[0]:aShape[1];var outerShapeB=bOrient===math_1.MatrixOrientation.REGULAR?bShape[1]:bShape[0];this.outputShape=[outerShapeA,outerShapeB];var sharedDim=aOrient===math_1.MatrixOrientation.REGULAR?aShape[1]:aShape[0];var aSnippetFromOffset=function aSnippetFromOffset(vec4Offset,indexVar){return aOrient===math_1.MatrixOrientation.REGULAR?"aRow, "+indexVar+" + "+vec4Offset:indexVar+" + "+vec4Offset+", aRow";};var bSnippetFromOffset=function bSnippetFromOffset(vec4Offset,indexVar){return bOrient===math_1.MatrixOrientation.REGULAR?indexVar+" + "+vec4Offset+", bCol":"bCol, "+indexVar+" + "+vec4Offset;};var sharedDimNearestVec4=Math.floor(sharedDim/4)*4;var sharedDimVec4Remainder=sharedDim%4;this.userCode=" float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < "+sharedDimNearestVec4+"; i += 4) {\n        vec4 a = vec4(\n          getMatrixA("+aSnippetFromOffset(0,'i')+"),\n          getMatrixA("+aSnippetFromOffset(1,'i')+"),\n          getMatrixA("+aSnippetFromOffset(2,'i')+"),\n          getMatrixA("+aSnippetFromOffset(3,'i')+")\n        );\n        vec4 b = vec4(\n          getMatrixB("+bSnippetFromOffset(0,'i')+"),\n          getMatrixB("+bSnippetFromOffset(1,'i')+"),\n          getMatrixB("+bSnippetFromOffset(2,'i')+"),\n          getMatrixB("+bSnippetFromOffset(3,'i')+")\n        );\n\n        result += dot(a, b);\n      }\n\n      if ("+(sharedDimVec4Remainder===1)+") {\n        result += getMatrixA("+aSnippetFromOffset(0,sharedDimNearestVec4)+") *\n          getMatrixB("+bSnippetFromOffset(0,sharedDimNearestVec4)+");\n      } else if ("+(sharedDimVec4Remainder===2)+") {\n        vec2 a = vec2(\n          getMatrixA("+aSnippetFromOffset(0,sharedDimNearestVec4)+"),\n          getMatrixA("+aSnippetFromOffset(1,sharedDimNearestVec4)+")\n        );\n        vec2 b = vec2(\n          getMatrixB("+bSnippetFromOffset(0,sharedDimNearestVec4)+"),\n          getMatrixB("+bSnippetFromOffset(1,sharedDimNearestVec4)+")\n        );\n        result += dot(a, b);\n      } else if ("+(sharedDimVec4Remainder===3)+") {\n        vec3 a = vec3(\n          getMatrixA("+aSnippetFromOffset(0,sharedDimNearestVec4)+"),\n          getMatrixA("+aSnippetFromOffset(1,sharedDimNearestVec4)+"),\n          getMatrixA("+aSnippetFromOffset(2,sharedDimNearestVec4)+")\n        );\n        vec3 b = vec3(\n          getMatrixB("+bSnippetFromOffset(0,sharedDimNearestVec4)+"),\n          getMatrixB("+bSnippetFromOffset(1,sharedDimNearestVec4)+"),\n          getMatrixB("+bSnippetFromOffset(2,sharedDimNearestVec4)+")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    ";}return MatMulProgram;}();exports.MatMulProgram=MatMulProgram;},{"../math":53}],74:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var MultinomialProgram=function(){function MultinomialProgram(batchSize,numOutcomes,numSamples){this.variableNames=['probs'];this.outputShape=[batchSize,numSamples];this.numBatchDims=1;this.userCode="\n      uniform float seed;\n\n      void main() {\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(numOutcomes-1)+"; i++) {\n          cdf += getProbs(i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(numOutcomes-1)+"));\n      }\n    ";}MultinomialProgram.prototype.getCustomSetupFunc=function(seed){var _this=this;return function(gpgpu,webGLProgram){if(_this.seedLoc==null){_this.seedLoc=gpgpu.getUniformLocation(webGLProgram,'seed');}gpgpu.gl.uniform1f(_this.seedLoc,seed);};};return MultinomialProgram;}();exports.MultinomialProgram=MultinomialProgram;},{}],75:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var OneHotProgram=function(){function OneHotProgram(numIndices,depth,onValue,offValue){this.variableNames=['indices'];this.outputShape=[numIndices,depth];this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+offValue+"), float("+onValue+"),\n                      float(index == coords.y)));\n      }\n    ";}OneHotProgram.prototype.getCustomSetupFunc=function(seed){var _this=this;return function(gpgpu,webGLProgram){if(_this.seedLoc==null){_this.seedLoc=gpgpu.getUniformLocation(webGLProgram,'seed');}gpgpu.gl.uniform1f(_this.seedLoc,seed);};};return OneHotProgram;}();exports.OneHotProgram=OneHotProgram;},{}],76:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var Pool2DProgram=function(){function Pool2DProgram(convInfo,poolType,computePositions){this.variableNames=['x'];if(poolType==='avg'&&computePositions){throw new Error('Cannot compute positions for average pool.');}var filterHeight=convInfo.filterHeight;var filterWidth=convInfo.filterWidth;var strideHeight=convInfo.strideHeight;var strideWidth=convInfo.strideWidth;var xNumRows=convInfo.inShape[0];var xNumCols=convInfo.inShape[1];var padTop=convInfo.padInfo.top;var padLeft=convInfo.padInfo.left;this.outputShape=convInfo.outShape;var isAvgPool=poolType==='avg';var initializationValue='0.0';if(!isAvgPool){if(poolType==='min'){initializationValue='1.0 / 0.0';}else{initializationValue='-1.0 / 0.0';}}if(computePositions){var compareOp_1=poolType==='min'?'<=':'>=';this.userCode="\n        const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n        const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n          int d = coords.z;\n\n          ivec2 xRCCorner = coords.xy * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+filterHeight+"; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+xNumRows+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+filterWidth+"; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+xNumCols+") {\n                continue;\n              }\n\n              float value = getX(xR, xC, d);\n\n              if (isNaN(value)) {\n                setOutput(value);\n                return;\n              }\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value "+compareOp_1+" currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+filterWidth+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";return;}var compareOp=poolType==='min'?'min':'max';var returnValue=poolType+"("+poolType+"("+poolType+"("+'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';if(poolType==='avg'){returnValue="avgValue / "+filterHeight*filterWidth+".0";}var filterWidthNearestVec4=Math.floor(filterWidth/4)*4;var filterWidthVec4Remainder=filterWidth%4;var updateSnippet="\n      if (hasNaN(values)) {\n        setOutput(getNaN(values));\n        return;\n      }\n      if ("+isAvgPool+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = "+compareOp+"(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n      const float initializationValue = "+initializationValue+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+xNumCols+") {\n          return initializationValue;\n        }\n        return getX(xR, xC, d);\n      }\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d = coords.z;\n\n        ivec2 xRCCorner = coords.xy * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+initializationValue+");\n        float avgValue = 0.0;\n\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+xNumRows+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+filterWidthNearestVec4+"; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              getValue(xR, xC + 2, d),\n              getValue(xR, xC + 3, d)\n            );\n\n            "+updateSnippet+"\n          }\n\n          int xC = xCCorner + "+filterWidthNearestVec4+";\n          if ("+(filterWidthVec4Remainder===1)+") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n            "+updateSnippet+"\n          } else if ("+(filterWidthVec4Remainder===2)+") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+updateSnippet+"\n          } else if ("+(filterWidthVec4Remainder===3)+") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              getValue(xR, xC + 2, d),\n              initializationValue\n            );\n\n            "+updateSnippet+"\n          }\n        }\n        setOutput("+returnValue+");\n      }\n    ";}return Pool2DProgram;}();exports.Pool2DProgram=Pool2DProgram;},{}],77:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var util=require("../../util");var axis_util=require("../axis_util");var ReduceSumProgram=function(){function ReduceSumProgram(shape,axes){this.variableNames=['A'];var _a=axis_util.computeOutAndReduceShapes(shape,axes),outShape=_a[0],reduceShape=_a[1];this.outputShape=outShape;this.numBatchDims=outShape.length;var size=util.sizeFromShape(reduceShape);var sizeNearestVec4=Math.floor(size/4)*4;var sizeVec4Remainder=size%4;var r1=sizeNearestVec4;var r2=sizeNearestVec4+1;var r3=sizeNearestVec4+2;this.userCode="\n      void main() {\n        const vec2 ones2 = vec2(1);\n        const vec3 ones3 = vec3(1);\n        const vec4 ones4 = vec4(1);\n\n        float sum = 0.0;\n        for (int i = 0; i < "+sizeNearestVec4+"; i += 4) {\n          vec4 aVec = vec4(getAFlat(i), getAFlat(i+1),\n                           getAFlat(i+2), getAFlat(i+3));\n          sum += dot(ones4, aVec);\n        }\n\n        if ("+(sizeVec4Remainder===1)+") {\n          sum += getAFlat("+r1+");\n        } else if ("+(sizeVec4Remainder===2)+") {\n          vec2 aVec = vec2(getAFlat("+r1+"), getAFlat("+r2+"));\n          sum += dot(ones2, aVec);\n        } else if ("+(sizeVec4Remainder===3)+") {\n          vec3 aVec = vec3(getAFlat("+r1+"), getAFlat("+r2+"), getAFlat("+r3+"));\n          sum += dot(ones3, aVec);\n        }\n\n        setOutput(sum);\n      }\n    ";}return ReduceSumProgram;}();exports.ReduceSumProgram=ReduceSumProgram;},{"../../util":88,"../axis_util":47}],78:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var webgl_util=require("./webgl_util");function getRenderRGBShader(gpgpu,destinationWidth){var fragmentShaderSource="\n    precision highp float;\n    uniform sampler2D source;\n    varying vec2 resultUV;\n\n    const float destinationWidth = "+destinationWidth+".0;\n    const float a = 1.0;\n\n    void main() {\n      float xr = floor(resultUV.s * destinationWidth) * 3.0;\n      vec3 x = xr + vec3(0, 1, 2);\n\n      float sourceWidth = destinationWidth * 3.0;\n      vec3 u = (x + 0.5) / sourceWidth;\n      float v = 1.0 - resultUV.t;\n\n      float r = texture2D(source, vec2(u[0], v)).r;\n      float g = texture2D(source, vec2(u[1], v)).r;\n      float b = texture2D(source, vec2(u[2], v)).r;\n\n      gl_FragColor = vec4(r, g, b, a);\n    }";return gpgpu.createProgram(fragmentShaderSource);}exports.getRenderRGBShader=getRenderRGBShader;function renderToCanvas(gpgpu,renderShader,sourceTex){webgl_util.bindCanvasToFramebuffer(gpgpu.gl);renderToFramebuffer(gpgpu,renderShader,sourceTex);}exports.renderToCanvas=renderToCanvas;function renderToFramebuffer(gpgpu,renderShader,sourceTex){gpgpu.setProgram(renderShader);var sourceSamplerLocation=webgl_util.getProgramUniformLocationOrThrow(gpgpu.gl,renderShader,'source');gpgpu.setInputMatrixTexture(sourceTex,sourceSamplerLocation,0);gpgpu.executeProgram();}exports.renderToFramebuffer=renderToFramebuffer;},{"./webgl_util":86}],79:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var ResizeBilinear3DProgram=function(){function ResizeBilinear3DProgram(inputShape,outputDimensionsRowCol,alignCorners){this.variableNames=['A'];this.outputShape=[];var depth=inputShape[2];this.outputShape=[outputDimensionsRowCol[0],outputDimensionsRowCol[1],depth];var effectiveInputShape=alignCorners?[inputShape[0]-1,inputShape[1]-1,depth]:inputShape;var effectiveOutputShape=alignCorners?[this.outputShape[0]-1,this.outputShape[1]-1,depth]:this.outputShape;this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+effectiveInputShape[0]/effectiveOutputShape[0]+",\n          "+effectiveInputShape[1]/effectiveOutputShape[1]+");\n      const vec2 inputShapeRC = vec2("+inputShape[0]+".0, "+inputShape[1]+".0);\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        ivec2 yRC = coords.xy;\n        int d = coords.z;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";}return ResizeBilinear3DProgram;}();exports.ResizeBilinear3DProgram=ResizeBilinear3DProgram;},{}],80:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment_1=require("../../environment");var util=require("../../util");var broadcast_util=require("../broadcast_util");var tex_util=require("./tex_util");var tex_util_1=require("./tex_util");function updateBatchedShapeInfo(info,numBatchDims){info.logicalShape=info.logicalShape.slice(numBatchDims);}function makeShader(inputsInfo,outputShape,userCode,broadcast,numBatchDims){var batchSnippet='';if(numBatchDims){if(inputsInfo.length!==1){throw new Error("Batching for 2 or more inputs is not yet supported. "+("Got "+inputsInfo.length+" inputs."));}updateBatchedShapeInfo(inputsInfo[0].shapeInfo,numBatchDims);updateBatchedShapeInfo(outputShape,numBatchDims);var inputSize=util.sizeFromShape(inputsInfo[0].shapeInfo.logicalShape);var outputSize=util.sizeFromShape(outputShape.logicalShape);batchSnippet=getBatchSnippet(inputSize,outputSize,outputShape.texShape);}var sampleSnippet=getSampleSnippet();var setOutputSnippet=getSetOutputSnippet();var inputPrefixSnippet=inputsInfo.map(function(x){return"uniform sampler2D "+x.name+";";}).join('\n');var inputSamplingSnippet=inputsInfo.map(function(x){return getInputSamplingSnippet(x,outputShape,broadcast,numBatchDims);}).join('\n');var outTexShape=outputShape.texShape;var outputSamplingSnippet=getOutputSamplingSnippet(outputShape.logicalShape,outTexShape);var source=[SHADER_PREFIX,batchSnippet,sampleSnippet,setOutputSnippet,inputPrefixSnippet,outputSamplingSnippet,inputSamplingSnippet,userCode].join('\n');return source;}exports.makeShader=makeShader;function getSampleSnippet(){return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')?FLOAT_TEXTURE_SAMPLE_SNIPPET:UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;}function getSetOutputSnippet(){return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')?FLOAT_TEXTURE_SETOUTPUT_SNIPPET:UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;}function getInputSamplingSnippet(inInfo,outShapeInfo,broadcast,numBatchDims){var shape=inInfo.shapeInfo.logicalShape;var res=getSamplerFlat(inInfo,numBatchDims);switch(shape.length){case 0:res+=getSamplerScalar(inInfo);break;case 1:res+=getSampler1D(inInfo);break;case 2:res+=getSampler2D(inInfo);break;case 3:res+=getSampler3D(inInfo);break;case 4:res+=getSampler4D(inInfo);break;default:throw new Error(shape.length+"-D input sampling"+" is not yet supported");}if(broadcast||util.arraysEqual(inInfo.shapeInfo.logicalShape,outShapeInfo.logicalShape)){res+=getSamplerAtOutputCoords(inInfo,outShapeInfo,broadcast);}return res;}function getBatchSnippet(inputSize,outputSize,texShape){return"\n    int getBatchOffset() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n      int b = index / "+outputSize+";\n      return b * "+inputSize+";\n    }\n  ";}function getOutputSamplingSnippet(outShape,outTexShape){switch(outShape.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(outShape,outTexShape);case 2:return getOutput2DCoords(outShape,outTexShape);case 3:return getOutput3DCoords(outShape,outTexShape);case 4:return getOutput4DCoords(outShape,outTexShape);default:throw new Error(outShape.length+"-D output sampling is not yet supported");}}var SAMPLE_1D_SNIPPET="\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";var SAMPLE_2D_SNIPPET="\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";var SAMPLE_3D_SNIPPET="\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";var SAMPLE_4D_SNIPPET="\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET="\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = "+tex_util.FLOAT_MIN+".0;\n  const float maxValue = "+tex_util.FLOAT_MAX+".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sample(sampler2D texture, vec2 uv) {\n    vec4 sampleValue = texture2D(texture, uv);\n    if (all(equal(sampleValue, vec4("+tex_util.BYTE_NAN_VALUE+")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n";var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET="\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4("+tex_util.BYTE_NAN_VALUE+");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n";var FLOAT_TEXTURE_SAMPLE_SNIPPET="\n  float sample(sampler2D texture, vec2 uv) {\n    return texture2D(texture, uv).r;\n  }\n";var FLOAT_TEXTURE_SETOUTPUT_SNIPPET="\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";var SHADER_PREFIX="\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    return val == val ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    return any(notEqual(values, values));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  const vec2 randomConst = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n     2.665144142690225 // 2^sqrt(2) (Gelfond\u2013Schneider constant)\n  );\n\n  float random(float seed) {\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\n  }\n\n  float sampleUVAndDepth(sampler2D texture, vec2 uv, int depth) {\n    float value;\n    if (depth == 0) {\n      value = texture2D(texture, uv).r;\n    } else if (depth == 1) {\n      value = texture2D(texture, uv).g;\n    } else if (depth == 2) {\n      value = texture2D(texture, uv).b;\n    } else if (depth == 3) {\n      value = texture2D(texture, uv).a;\n    }\n    return floor(value * 255.0 + 0.5);\n  }\n\n  "+SAMPLE_1D_SNIPPET+"\n  "+SAMPLE_2D_SNIPPET+"\n  "+SAMPLE_3D_SNIPPET+"\n  "+SAMPLE_4D_SNIPPET+"\n";function getOutputScalarCoords(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";}function getOutput1DCoords(shape,texShape){if(texShape[0]===1){return"\n      int getOutputCoords() {\n        return int(resultUV.x * "+texShape[1]+".0);\n      }\n    ";}if(texShape[1]===1){return"\n      int getOutputCoords() {\n        return int(resultUV.y * "+texShape[0]+".0);\n      }\n    ";}return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+texShape[0]+", "+texShape[1]+"));\n      return resTexRC.x * "+texShape[1]+" + resTexRC.y;\n    }\n  ";}function getOutput3DCoords(shape,texShape){var stride0=shape[1]*shape[2];var stride1=shape[2];return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n      int r = index / "+stride0+";\n      index -= r * "+stride0+";\n      int c = index / "+stride1+";\n      int d = index - c * "+stride1+";\n      return ivec3(r, c, d);\n    }\n  ";}function getOutput4DCoords(shape,texShape){var stride2=shape[3];var stride1=shape[2]*stride2;var stride0=shape[1]*stride1;return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n\n      int r = index / "+stride0+";\n      index -= r * "+stride0+";\n\n      int c = index / "+stride1+";\n      index -= c * "+stride1+";\n\n      int d = index / "+stride2+";\n      int d2 = index - d * "+stride2+";\n\n      return ivec4(r, c, d, d2);\n    }\n  ";}function getOutput2DCoords(shape,texShape){if(util.arraysEqual(shape,texShape)){return"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+texShape[0]+", "+texShape[1]+"));\n      }\n    ";}if(shape[1]===1){return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+texShape[0]+", "+texShape[1]+"));\n        int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";}if(shape[0]===1){return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+texShape[0]+", "+texShape[1]+"));\n        int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";}return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n      int r = index / "+shape[1]+";\n      int c = index - r * "+shape[1]+";\n      return ivec2(r, c);\n    }\n  ";}function getSamplerScalar(inputInfo){var texName=inputInfo.name;var funcName='get'+texName.charAt(0).toUpperCase()+texName.slice(1);return"\n    float "+funcName+"() {\n      return sample("+texName+", halfCR);\n    }\n  ";}function getSampler1D(inputInfo){var texName=inputInfo.name;var funcName='get'+texName.charAt(0).toUpperCase()+texName.slice(1);return"\n    float "+funcName+"(int index) {\n      return "+funcName+"Flat(index);\n    }\n  ";}function getSampler2D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape;var texShape=inputInfo.shapeInfo.texShape;var texName=inputInfo.name;var funcName='get'+texName.charAt(0).toUpperCase()+texName.slice(1);var tR=texShape[0];var tC=texShape[1];if(util.arraysEqual(shape,texShape)){return"\n    float "+funcName+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+tC+".0, "+tR+".0);\n      return sample("+texName+", uv);\n    }\n  ";}if(tC===1){if(shape[0]===1){return"\n      float "+funcName+"(int row, int col) {\n        vec2 uv = vec2(0.5, (float(col) + 0.5) / "+tR+".0);\n        return sample("+texName+", uv);\n      }\n    ";}if(shape[1]===1){return"\n      float "+funcName+"(int row, int col) {\n        vec2 uv = vec2(0.5, (float(row) + 0.5) / "+tR+".0);\n        return sample("+texName+", uv);\n      }\n    ";}return"\n    float "+funcName+"(int row, int col) {\n      int index = row * "+shape[1]+" + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / "+tR+".0);\n      return sample("+texName+", uv);\n    }\n  ";}if(tR===1){return"\n    float "+funcName+"(int row, int col) {\n      int index = row * "+shape[1]+" + col;\n      vec2 uv = vec2((float(index) + 0.5) / "+tC+".0, 0.5);\n      return sample("+texName+", uv);\n    }\n  ";}return"\n  float "+funcName+"(int row, int col) {\n    vec2 uv = UVfrom2D("+tR+", "+tC+", "+shape[1]+", row, col);\n    return sample("+texName+", uv);\n  }\n";}function getSampler3D(inputInfo){var texShape=inputInfo.shapeInfo.texShape;var shape=inputInfo.shapeInfo.logicalShape;var texName=inputInfo.name;var funcName='get'+texName.charAt(0).toUpperCase()+texName.slice(1);var tR=texShape[0];var tC=texShape[1];var stride0=shape[1]*shape[2];var stride1=shape[2];if(tC===stride0){if(inputInfo.shapeInfo.textureType===tex_util_1.TextureType.DEFAULT){return"\n        float "+funcName+"(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * "+stride1+" + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+tC+".0, "+tR+".0);\n          return sample("+texName+", uv);\n        }\n      ";}else if(inputInfo.shapeInfo.textureType===tex_util_1.TextureType.RGBA_COLOR){return"\n        float "+funcName+"(int row, int col, int depth) {\n          vec2 uv = (vec2(col, row) + halfCR) / vec2("+tC+".0, "+tR+".0);\n          return sampleUVAndDepth("+texName+", uv, depth);\n        }\n      ";}else{throw new Error("Unknown TextureType "+inputInfo.shapeInfo.textureType+".");}}if(inputInfo.shapeInfo.textureType===tex_util_1.TextureType.DEFAULT){return"\n      float "+funcName+"(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            "+tR+", "+tC+", "+stride0+", "+stride1+", row, col, depth);\n        return sample("+texName+", uv);\n      }\n  ";}else if(inputInfo.shapeInfo.textureType===tex_util_1.TextureType.RGBA_COLOR){return"\n      float "+funcName+"(int row, int col, int depth) {\n        vec2 uv = UVfrom2D("+tR+", "+tC+", "+shape[1]+", row, col);\n        return sampleUVAndDepth("+texName+", uv, depth);\n      }\n    ";}else{throw new Error("Unknown TextureType "+inputInfo.shapeInfo.textureType+".");}}function getSampler4D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape;var texShape=inputInfo.shapeInfo.texShape;var texName=inputInfo.name;var funcName='get'+texName.charAt(0).toUpperCase()+texName.slice(1);var tR=texShape[0];var tC=texShape[1];var stride2=shape[3];var stride1=shape[2]*stride2;var stride0=shape[1]*stride1;if(tC===stride0){return"\n      float "+funcName+"(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * "+stride1+" + depth * "+stride2+" + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+tC+".0, "+tR+".0);\n        return sample("+texName+", uv);\n      }\n    ";}return"\n    float "+funcName+"(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D("+tR+", "+tC+", "+stride0+", "+stride1+", "+stride2+",\n          row, col, depth, depth2);\n      return sample("+texName+", uv);\n    }\n  ";}function getSamplerFlat(inputInfo,numBatchDims){var texName=inputInfo.name;var texShape=inputInfo.shapeInfo.texShape;var funcName='get'+texName.charAt(0).toUpperCase()+texName.slice(1)+'Flat';var tNumR=texShape[0];var tNumC=texShape[1];var batchSnippet='';if(numBatchDims){batchSnippet='index += getBatchOffset();';}if(tNumC===1&&tNumR===1){return"\n      float "+funcName+"(int index) {\n        "+batchSnippet+"\n        return sample("+texName+", halfCR);\n      }\n    ";}if(tNumC===1){return"\n      float "+funcName+"(int index) {\n        "+batchSnippet+"\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / "+tNumR+".0);\n        return sample("+texName+", uv);\n      }\n    ";}if(tNumR===1){return"\n      float "+funcName+"(int index) {\n        "+batchSnippet+"\n        vec2 uv = vec2((float(index) + 0.5) / "+tNumC+".0, 0.5);\n        return sample("+texName+", uv);\n      }\n    ";}return"\n    float "+funcName+"(int index) {\n      "+batchSnippet+"\n      vec2 uv = UVfrom1D("+tNumR+", "+tNumC+", index);\n      return sample("+texName+", uv);\n    }\n  ";}function getBroadcastOutputCoordsSampler(inputInfo,outShapeInfo,texFuncSnippet,funcName){var inRank=inputInfo.shapeInfo.logicalShape.length;var outRank=outShapeInfo.logicalShape.length;var type='int';if(outRank===2){type='ivec2';}else if(outRank===3){type='ivec3';}else if(outRank===4){type='ivec4';}var broadcastDims=broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape,outShapeInfo.logicalShape);var rankDiff=outRank-inRank;var coordsSnippet;if(inRank===0){coordsSnippet='';}else if(outRank<2&&broadcastDims.length>=1){coordsSnippet='coords = 0;';}else{coordsSnippet=broadcastDims.map(function(d){return"coords["+(d+rankDiff)+"] = 0;";}).join('\n');}var unpackedCoordsSnippet='';if(outRank<2&&inRank>0){unpackedCoordsSnippet='coords';}else{unpackedCoordsSnippet=inputInfo.shapeInfo.logicalShape.map(function(s,i){return"coords["+(i+rankDiff)+"]";}).join(', ');}return"\n    float "+funcName+"() {\n      "+type+" coords = getOutputCoords();\n      "+coordsSnippet+"\n      return get"+texFuncSnippet+"("+unpackedCoordsSnippet+");\n    }\n  ";}function getSamplerAtOutputCoords(inputInfo,outShapeInfo,supportsBroadcasting){var inTexShape=inputInfo.shapeInfo.texShape;var texName=inputInfo.name;var isRGBAColorTexture=inputInfo.shapeInfo.textureType===tex_util_1.TextureType.RGBA_COLOR;var texFuncSnippet=texName.charAt(0).toUpperCase()+texName.slice(1);var funcName='get'+texFuncSnippet+'AtOutCoords';var broadcastDims=broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape,outShapeInfo.logicalShape);var inRank=inputInfo.shapeInfo.logicalShape.length;var outRank=outShapeInfo.logicalShape.length;var doBroadcast=supportsBroadcasting&&(outRank>inRank||broadcastDims.length>0);var broadcastOverOuter=broadcast_util.broadcastDimsAreOuter(broadcastDims);if(doBroadcast&&!broadcastOverOuter){return getBroadcastOutputCoordsSampler(inputInfo,outShapeInfo,texFuncSnippet,funcName);}var outTexShape=outShapeInfo.texShape;if(util.arraysEqual(inTexShape,outTexShape)&&!isRGBAColorTexture){return"\n      float "+funcName+"() {\n        return sample("+texName+", resultUV);\n      }\n    ";}var inTexExpandedShape=isRGBAColorTexture?[inTexShape[0],inTexShape[1]*inputInfo.shapeInfo.logicalShape[2]]:inTexShape;var sampleSnippet="return sample("+texName+", uv);";var rgbaColorSnippet='';if(isRGBAColorTexture){rgbaColorSnippet="\n      int col = texC / "+inputInfo.shapeInfo.logicalShape[2]+";\n      int texD = texC - col * "+inputInfo.shapeInfo.logicalShape[2]+";\n      texC = col;\n    ";sampleSnippet="return sampleUVAndDepth("+texName+", uv, texD);";}var inSize=util.sizeFromShape(inTexExpandedShape);var broadcastSnippet='';if(doBroadcast&&broadcastOverOuter){broadcastSnippet="\n        int mainPart = index / "+inSize+";\n        index -= mainPart * "+inSize+";\n      ";}return"\n    float "+funcName+"() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+outTexShape[0]+", "+outTexShape[1]+"));\n      int index = resTexRC.x * "+outTexShape[1]+" + resTexRC.y;\n      "+broadcastSnippet+"\n      int texR = index / "+inTexExpandedShape[1]+";\n      int texC = index - texR * "+inTexExpandedShape[1]+";\n\n      "+rgbaColorSnippet+"\n\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2("+inTexShape[1]+".0, "+inTexShape[0]+".0);\n\n      "+sampleSnippet+"\n    }\n  ";}},{"../../environment":8,"../../util":88,"../broadcast_util":48,"./tex_util":82}],81:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var SliceProgram=function(){function SliceProgram(destSize){this.variableNames=['source'];this.outputShape=destSize;this.rank=destSize.length;var dtype=getDataType(this.rank);var sourceCoords=getCoords(this.rank);this.userCode="\n      uniform "+dtype+" start;\n\n      void main() {\n        "+dtype+" sourceLoc = start + getOutputCoords();\n        setOutput(getSource("+sourceCoords+"));\n      }\n    ";}SliceProgram.prototype.getCustomSetupFunc=function(start){var _this=this;if(start.length!==this.rank){throw Error("The rank ("+this.rank+") of the program must match the "+("length of start ("+start.length+")"));}return function(gpgpu,webGLProgram){if(_this.startLoc==null){_this.startLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,'start');if(_this.startLoc==null){return;}}if(_this.rank===1){gpgpu.gl.uniform1i(_this.startLoc,start[0]);}else if(_this.rank===2){gpgpu.gl.uniform2i(_this.startLoc,start[0],start[1]);}else if(_this.rank===3){gpgpu.gl.uniform3i(_this.startLoc,start[0],start[1],start[2]);}else if(_this.rank===4){gpgpu.gl.uniform4i(_this.startLoc,start[0],start[1],start[2],start[3]);}else{throw Error("Slicing for rank "+_this.rank+" is not yet supported");}};};return SliceProgram;}();exports.SliceProgram=SliceProgram;function getCoords(rank){if(rank===1){return'sourceLoc';}else if(rank===2){return'sourceLoc.x, sourceLoc.y';}else if(rank===3){return'sourceLoc.x, sourceLoc.y, sourceLoc.z';}else if(rank===4){return'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';}else{throw Error("Slicing for rank "+rank+" is not yet supported");}}function getDataType(rank){if(rank===1){return'int';}else if(rank===2){return'ivec2';}else if(rank===3){return'ivec3';}else if(rank===4){return'ivec4';}else{throw Error("Slicing for rank "+rank+" is not yet supported");}}},{}],82:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var TextureType;(function(TextureType){TextureType[TextureType["DEFAULT"]=0]="DEFAULT";TextureType[TextureType["RGBA_COLOR"]=1]="RGBA_COLOR";})(TextureType=exports.TextureType||(exports.TextureType={}));function getUnpackedMatrixTextureShapeWidthHeight(rows,columns){return[columns,rows];}exports.getUnpackedMatrixTextureShapeWidthHeight=getUnpackedMatrixTextureShapeWidthHeight;function getUnpackedArraySizeFromMatrixSize(matrixSize,channelsPerTexture){return matrixSize*channelsPerTexture;}exports.getUnpackedArraySizeFromMatrixSize=getUnpackedArraySizeFromMatrixSize;function getColorMatrixTextureShapeWidthHeight(rows,columns){return[columns*4,rows];}exports.getColorMatrixTextureShapeWidthHeight=getColorMatrixTextureShapeWidthHeight;function getMatrixSizeFromUnpackedArraySize(unpackedSize,channelsPerTexture){if(unpackedSize%channelsPerTexture!==0){throw new Error("unpackedSize ("+unpackedSize+") must be a multiple of "+(""+channelsPerTexture));}return unpackedSize/channelsPerTexture;}exports.getMatrixSizeFromUnpackedArraySize=getMatrixSizeFromUnpackedArraySize;function encodeMatrixToUnpackedArray(matrix,unpackedArray,channelsPerTexture){var requiredSize=getUnpackedArraySizeFromMatrixSize(matrix.length,channelsPerTexture);if(unpackedArray.length<requiredSize){throw new Error("unpackedArray length ("+unpackedArray.length+") must be >= "+(""+requiredSize));}var dst=0;for(var src=0;src<matrix.length;++src){unpackedArray[dst]=matrix[src];dst+=channelsPerTexture;}}exports.encodeMatrixToUnpackedArray=encodeMatrixToUnpackedArray;exports.FLOAT_MAX=20000;exports.FLOAT_MIN=-exports.FLOAT_MAX;var FLOAT_RANGE=(exports.FLOAT_MAX-exports.FLOAT_MIN)/255;var FLOAT_DELTAS=[1,1/255,1/(255*255),1/(255*255*255)];var FLOAT_POWERS=[1,255,255*255];exports.BYTE_NAN_VALUE=0;function encodeFloatArray(floatArray){var uintArray=new Uint8Array(floatArray.length*4);var _loop_1=function _loop_1(i){var value=floatArray[i/4];if(isNaN(value)){uintArray[i]=exports.BYTE_NAN_VALUE;uintArray[i+1]=exports.BYTE_NAN_VALUE;uintArray[i+2]=exports.BYTE_NAN_VALUE;uintArray[i+3]=exports.BYTE_NAN_VALUE;return"continue";}var normalizedValue=(value-exports.FLOAT_MIN)/FLOAT_RANGE;var enc=FLOAT_POWERS.map(function(pow){return pow*normalizedValue;});var buckets=enc.map(function(value){return Math.floor(value%1*255);});uintArray[i]=Math.floor(normalizedValue);uintArray[i+1]=buckets[0];uintArray[i+2]=buckets[1];uintArray[i+3]=buckets[2];};for(var i=0;i<uintArray.length;i+=4){_loop_1(i);}return uintArray;}exports.encodeFloatArray=encodeFloatArray;function decodeToFloatArray(uintArray){var floatArray=new Float32Array(uintArray.length/4);var _loop_2=function _loop_2(i){if(uintArray[i]===exports.BYTE_NAN_VALUE&&uintArray[i+1]===exports.BYTE_NAN_VALUE&&uintArray[i+2]===exports.BYTE_NAN_VALUE&&uintArray[i+3]===exports.BYTE_NAN_VALUE){floatArray[i/4]=NaN;return"continue";}var dot=0;FLOAT_DELTAS.forEach(function(delta,j){dot+=delta*uintArray[i+j];});var value=dot*FLOAT_RANGE+exports.FLOAT_MIN;floatArray[i/4]=value;};for(var i=0;i<uintArray.length;i+=4){_loop_2(i);}return floatArray;}exports.decodeToFloatArray=decodeToFloatArray;function decodeMatrixFromUnpackedArray(unpackedArray,matrix,channelsPerTexture){var requiredSize=getMatrixSizeFromUnpackedArraySize(unpackedArray.length,channelsPerTexture);if(matrix.length<requiredSize){throw new Error("matrix length ("+matrix.length+") must be >= "+requiredSize);}var dst=0;for(var src=0;src<unpackedArray.length;src+=channelsPerTexture){matrix[dst++]=unpackedArray[src];}}exports.decodeMatrixFromUnpackedArray=decodeMatrixFromUnpackedArray;function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray,matrix,channels){var requiredSize=unpackedArray.length*channels/4;if(matrix.length<requiredSize){throw new Error("matrix length ("+matrix.length+") must be >= "+requiredSize);}var dst=0;for(var src=0;src<unpackedArray.length;src+=4){for(var c=0;c<channels;c++){matrix[dst++]=unpackedArray[src+c];}}}exports.decodeMatrixFromUnpackedColorRGBAArray=decodeMatrixFromUnpackedColorRGBAArray;function getPackedMatrixTextureShapeWidthHeight(rows,columns){return[Math.ceil(columns/2),Math.ceil(rows/2)];}exports.getPackedMatrixTextureShapeWidthHeight=getPackedMatrixTextureShapeWidthHeight;function getPackedRGBAArraySizeFromMatrixShape(rows,columns){var _a=getPackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1];return w*h*4;}exports.getPackedRGBAArraySizeFromMatrixShape=getPackedRGBAArraySizeFromMatrixShape;function encodeMatrixToPackedRGBA(matrix,rows,columns,packedRGBA){var requiredSize=getPackedRGBAArraySizeFromMatrixShape(rows,columns);if(packedRGBA.length<requiredSize){throw new Error("packedRGBA length ("+packedRGBA.length+") must be >= "+requiredSize);}var _a=getPackedMatrixTextureShapeWidthHeight(rows,columns),textureWidth=_a[0],textureHeight=_a[1];var oddWidth=columns%2===1;var oddHeight=rows%2===1;var widthInFullBlocks=Math.floor(columns/2);var heightInFullBlocks=Math.floor(rows/2);{var dstStride=oddWidth?4:0;var oneRow=columns;var dst=0;for(var blockY=0;blockY<heightInFullBlocks;++blockY){var matrixSrcRow=blockY*2*columns;for(var blockX=0;blockX<widthInFullBlocks;++blockX){var matrixSrcCol=blockX*2;var src=matrixSrcRow+matrixSrcCol;packedRGBA[dst]=matrix[src];packedRGBA[dst+1]=matrix[src+1];packedRGBA[dst+2]=matrix[src+oneRow];packedRGBA[dst+3]=matrix[src+oneRow+1];dst+=4;}dst+=dstStride;}}if(oddWidth){var src=columns-1;var dst=(textureWidth-1)*4;var srcStride=2*columns;var dstStride=textureWidth*4;for(var blockY=0;blockY<heightInFullBlocks;++blockY){packedRGBA[dst]=matrix[src];packedRGBA[dst+2]=matrix[src+columns];src+=srcStride;dst+=dstStride;}}if(oddHeight){var src=(rows-1)*columns;var dst=(textureHeight-1)*textureWidth*4;for(var blockX=0;blockX<widthInFullBlocks;++blockX){packedRGBA[dst++]=matrix[src++];packedRGBA[dst++]=matrix[src++];dst+=2;}}if(oddWidth&&oddHeight){packedRGBA[packedRGBA.length-4]=matrix[matrix.length-1];}return packedRGBA;}exports.encodeMatrixToPackedRGBA=encodeMatrixToPackedRGBA;function decodeMatrixFromPackedRGBA(packedRGBA,rows,columns,matrix){var requiredSize=rows*columns;if(requiredSize<matrix.length){throw new Error("matrix length ("+matrix.length+") must be >= "+requiredSize);}var oddWidth=columns%2===1;var oddHeight=rows%2===1;var widthInFullBlocks=Math.floor(columns/2);var heightInFullBlocks=Math.floor(rows/2);var _a=getPackedMatrixTextureShapeWidthHeight(rows,columns),textureWidth=_a[0],textureHeight=_a[1];{var srcStride=oddWidth?4:0;var dstStride=columns+(oddWidth?1:0);var src=0;var dstRow1=0;var dstRow2=columns;for(var blockY=0;blockY<heightInFullBlocks;++blockY){for(var blockX=0;blockX<widthInFullBlocks;++blockX){matrix[dstRow1++]=packedRGBA[src++];matrix[dstRow1++]=packedRGBA[src++];matrix[dstRow2++]=packedRGBA[src++];matrix[dstRow2++]=packedRGBA[src++];}src+=srcStride;dstRow1+=dstStride;dstRow2+=dstStride;}}if(oddWidth){var src=(textureWidth-1)*4;var dst=columns-1;var srcStride=textureWidth*4;var dstStride=2*columns;for(var blockY=0;blockY<heightInFullBlocks;++blockY){matrix[dst]=packedRGBA[src];matrix[dst+columns]=packedRGBA[src+2];src+=srcStride;dst+=dstStride;}}if(oddHeight){var src=(textureHeight-1)*textureWidth*4;var dst=(rows-1)*columns;for(var blockX=0;blockX<widthInFullBlocks;++blockX){matrix[dst++]=packedRGBA[src++];matrix[dst++]=packedRGBA[src++];src+=2;}}if(oddWidth&&oddHeight){matrix[matrix.length-1]=packedRGBA[packedRGBA.length-4];}return matrix;}exports.decodeMatrixFromPackedRGBA=decodeMatrixFromPackedRGBA;},{}],83:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var TextureManager=function(){function TextureManager(gpgpu){this.gpgpu=gpgpu;this.numUsedTextures=0;this.numFreeTextures=0;this.freeTextures={};this.logEnabled=false;this.usedTextureCount={};}TextureManager.prototype.acquireTexture=function(shapeRC){var shapeKey=getKeyFromTextureShape(shapeRC);if(!(shapeKey in this.freeTextures)){this.freeTextures[shapeKey]=[];}if(!(shapeKey in this.usedTextureCount)){this.usedTextureCount[shapeKey]=0;}this.usedTextureCount[shapeKey]++;if(this.freeTextures[shapeKey].length>0){this.numFreeTextures--;this.numUsedTextures++;this.log();return this.freeTextures[shapeKey].shift();}this.numUsedTextures++;this.log();return this.gpgpu.createMatrixTexture(shapeRC[0],shapeRC[1]);};TextureManager.prototype.releaseTexture=function(texture,shape){var shapeKey=getKeyFromTextureShape(shape);if(!(shapeKey in this.freeTextures)){this.freeTextures[shapeKey]=[];}this.freeTextures[shapeKey].push(texture);this.numFreeTextures++;this.numUsedTextures--;this.usedTextureCount[shapeKey]--;this.log();};TextureManager.prototype.log=function(){if(!this.logEnabled){return;}var total=this.numFreeTextures+this.numUsedTextures;console.log('Free/Used',this.numFreeTextures+" / "+this.numUsedTextures,"("+total+")");};TextureManager.prototype.getNumUsedTextures=function(){return this.numUsedTextures;};TextureManager.prototype.getNumFreeTextures=function(){return this.numFreeTextures;};TextureManager.prototype.dispose=function(){for(var shape in this.freeTextures){if(this.freeTextures.hasOwnProperty(shape)){for(var i=0;i<this.freeTextures[shape].length;i++){this.gpgpu.deleteMatrixTexture(this.freeTextures[shape][i]);}}}};return TextureManager;}();exports.TextureManager=TextureManager;function getKeyFromTextureShape(shapeRowsCol){return shapeRowsCol[0]+"_"+shapeRowsCol[1];}},{}],84:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var TransposeProgram=function(){function TransposeProgram(aShape,newDim){this.variableNames=['A'];var outputShape=new Array(aShape.length);for(var i=0;i<outputShape.length;i++){outputShape[i]=aShape[newDim[i]];}this.outputShape=outputShape;this.rank=outputShape.length;var dtype=getDataType(this.rank);var switched=getSwitchedCoords(newDim);this.userCode="\n    void main() {\n      "+dtype+" resRC = getOutputCoords();\n      setOutput(getA("+switched+"));\n    }\n    ";}return TransposeProgram;}();exports.TransposeProgram=TransposeProgram;function getSwitchedCoords(newDim){var rank=newDim.length;if(rank>4){throw Error("Transpose for rank "+rank+" is not yet supported");}var originalOrder=['resRC.x','resRC.y','resRC.z','resRC.w'];var switchedCoords=new Array(rank);for(var i=0;i<newDim.length;i++){switchedCoords[newDim[i]]=originalOrder[i];}return switchedCoords.join();}function getDataType(rank){if(rank===1){return'int';}else if(rank===2){return'ivec2';}else if(rank===3){return'ivec3';}else if(rank===4){return'ivec4';}else{throw Error("Transpose for rank "+rank+" is not yet supported");}}},{}],85:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var UnaryOpProgram=function(){function UnaryOpProgram(aShape,opSnippet){this.variableNames=['A'];this.outputShape=aShape;this.userCode="\n      float unaryOperation(float x) {\n        "+opSnippet+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";}return UnaryOpProgram;}();exports.UnaryOpProgram=UnaryOpProgram;exports.CHECK_NAN_SNIPPET="\n  if (isNaN(x)) {\n    return x;\n  }\n";exports.ABS="\n  return abs(x);\n";exports.RELU="\n  return (x < 0.0) ? 0.0 : x;\n";exports.ELU="\n  return (x >= 0.0) ? x : (exp(x) - 1.0);\n";function LEAKY_RELU(alpha){return"\n  return (x >= 0.0) ? x : "+alpha+" * x;\n  ";}exports.LEAKY_RELU=LEAKY_RELU;exports.STEP="\n  return (x == x) ? (x > 0.0 ? 1.0 : 0.0) : x;\n";exports.NEG="\n  return -x;\n";exports.CEIL="\n  return ceil(x);\n";exports.FLOOR="\n  return floor(x);\n";exports.EXP="\n  return exp(x);\n";exports.LOG="\n  return log(x);\n";exports.SQRT=exports.CHECK_NAN_SNIPPET+"\n  return sqrt(x);\n";exports.SIGMOID="\n  return 1.0 / (1.0 + exp(-1.0 * x));\n";exports.SIN=exports.CHECK_NAN_SNIPPET+"\n  return sin(x);\n";exports.COS=exports.CHECK_NAN_SNIPPET+"\n  return cos(x);\n";exports.TAN="\n  return tan(x);\n";exports.ASIN=exports.CHECK_NAN_SNIPPET+"\n  return asin(x);\n";exports.ACOS=exports.CHECK_NAN_SNIPPET+"\n  return acos(x);\n";exports.ATAN=exports.CHECK_NAN_SNIPPET+"\n  return atan(x);\n";exports.SINH="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";exports.COSH="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";exports.TANH="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";exports.SQUARE="\n  return x * x;\n";},{}],86:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var MAX_TEXTURE_SIZE=null;var util=require("../../util");var environment_1=require("../../environment");function createWebGLRenderingContext(attributes){var canvas=document.createElement('canvas');canvas.width=1;canvas.height=1;return createWebGLRenderingContextFromCanvas(canvas,attributes);}exports.createWebGLRenderingContext=createWebGLRenderingContext;function createWebGLRenderingContextFromCanvas(canvas,attributes){var gl;var webglVersion=environment_1.ENV.get('WEBGL_VERSION');if(webglVersion===2){gl=canvas.getContext('webgl2',attributes);}else if(webglVersion===1){gl=canvas.getContext('webgl',attributes)||canvas.getContext('experimental-webgl',attributes);}if(webglVersion===0||gl==null){throw new Error('This browser does not support WebGL.');}return gl;}exports.createWebGLRenderingContextFromCanvas=createWebGLRenderingContextFromCanvas;function callAndCheck(gl,func){var returnValue=func();checkWebGLError(gl);return returnValue;}exports.callAndCheck=callAndCheck;var webGLDebugErrorCheckingEnabled=false;function enableDebugWebGLErrorChecking(enabled){webGLDebugErrorCheckingEnabled=enabled;}exports.enableDebugWebGLErrorChecking=enableDebugWebGLErrorChecking;function checkWebGLError(gl){if(webGLDebugErrorCheckingEnabled){var error=gl.getError();if(error!==gl.NO_ERROR){throw new Error('WebGL Error: '+getWebGLErrorMessage(gl,error));}}}exports.checkWebGLError=checkWebGLError;function getWebGLErrorMessage(gl,status){switch(status){case gl.NO_ERROR:return'NO_ERROR';case gl.INVALID_ENUM:return'INVALID_ENUM';case gl.INVALID_VALUE:return'INVALID_VALUE';case gl.INVALID_OPERATION:return'INVALID_OPERATION';case gl.INVALID_FRAMEBUFFER_OPERATION:return'INVALID_FRAMEBUFFER_OPERATION';case gl.OUT_OF_MEMORY:return'OUT_OF_MEMORY';case gl.CONTEXT_LOST_WEBGL:return'CONTEXT_LOST_WEBGL';default:return"Unknown error code "+status;}}exports.getWebGLErrorMessage=getWebGLErrorMessage;function getExtensionOrThrow(gl,extensionName){return throwIfNull(gl,function(){return gl.getExtension(extensionName);},'Extension "'+extensionName+'" not supported on this browser.');}exports.getExtensionOrThrow=getExtensionOrThrow;function createVertexShader(gl,vertexShaderSource){var vertexShader=throwIfNull(gl,function(){return gl.createShader(gl.VERTEX_SHADER);},'Unable to create vertex WebGLShader.');callAndCheck(gl,function(){return gl.shaderSource(vertexShader,vertexShaderSource);});callAndCheck(gl,function(){return gl.compileShader(vertexShader);});if(gl.getShaderParameter(vertexShader,gl.COMPILE_STATUS)===false){console.log(gl.getShaderInfoLog(vertexShader));throw new Error('Failed to compile vertex shader.');}return vertexShader;}exports.createVertexShader=createVertexShader;function createFragmentShader(gl,fragmentShaderSource){var fragmentShader=throwIfNull(gl,function(){return gl.createShader(gl.FRAGMENT_SHADER);},'Unable to create fragment WebGLShader.');callAndCheck(gl,function(){return gl.shaderSource(fragmentShader,fragmentShaderSource);});callAndCheck(gl,function(){return gl.compileShader(fragmentShader);});if(gl.getShaderParameter(fragmentShader,gl.COMPILE_STATUS)===false){logShaderSourceAndInfoLog(fragmentShaderSource,gl.getShaderInfoLog(fragmentShader));throw new Error('Failed to compile fragment shader.');}return fragmentShader;}exports.createFragmentShader=createFragmentShader;var lineNumberRegex=/ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(shaderSource,shaderInfoLog){var lineNumberRegexResult=lineNumberRegex.exec(shaderInfoLog);if(lineNumberRegexResult==null){console.log("Couldn't parse line number in error: "+shaderInfoLog);console.log(shaderSource);return;}var lineNumber=+lineNumberRegexResult[1];var shaderLines=shaderSource.split('\n');var pad=shaderLines.length.toString().length+2;var linesWithLineNumbers=shaderLines.map(function(line,lineNumber){return util.rightPad((lineNumber+1).toString(),pad)+line;});var maxLineLength=0;for(var i=0;i<linesWithLineNumbers.length;i++){maxLineLength=Math.max(linesWithLineNumbers[i].length,maxLineLength);}var beforeErrorLines=linesWithLineNumbers.slice(0,lineNumber-1);var errorLine=linesWithLineNumbers.slice(lineNumber-1,lineNumber);var afterErrorLines=linesWithLineNumbers.slice(lineNumber);console.log(beforeErrorLines.join('\n'));console.log(shaderInfoLog.split('\n')[0]);console.log("%c "+util.rightPad(errorLine[0],maxLineLength),'border:1px solid red; background-color:#e3d2d2; color:#a61717');console.log(afterErrorLines.join('\n'));}function createProgram(gl){return throwIfNull(gl,function(){return gl.createProgram();},'Unable to create WebGLProgram.');}exports.createProgram=createProgram;function linkProgram(gl,program){callAndCheck(gl,function(){return gl.linkProgram(program);});if(gl.getProgramParameter(program,gl.LINK_STATUS)===false){console.log(gl.getProgramInfoLog(program));throw new Error('Failed to link vertex and fragment shaders.');}}exports.linkProgram=linkProgram;function validateProgram(gl,program){callAndCheck(gl,function(){return gl.validateProgram(program);});if(gl.getProgramParameter(program,gl.VALIDATE_STATUS)===false){console.log(gl.getProgramInfoLog(program));throw new Error('Shader program validation failed.');}}exports.validateProgram=validateProgram;function createStaticVertexBuffer(gl,data){var buffer=throwIfNull(gl,function(){return gl.createBuffer();},'Unable to create WebGLBuffer');callAndCheck(gl,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,buffer);});callAndCheck(gl,function(){return gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW);});return buffer;}exports.createStaticVertexBuffer=createStaticVertexBuffer;function createStaticIndexBuffer(gl,data){var buffer=throwIfNull(gl,function(){return gl.createBuffer();},'Unable to create WebGLBuffer');callAndCheck(gl,function(){return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,buffer);});callAndCheck(gl,function(){return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,data,gl.STATIC_DRAW);});return buffer;}exports.createStaticIndexBuffer=createStaticIndexBuffer;function queryMaxTextureSize(gl){if(MAX_TEXTURE_SIZE!=null){return MAX_TEXTURE_SIZE;}MAX_TEXTURE_SIZE=callAndCheck(gl,function(){return gl.getParameter(gl.MAX_TEXTURE_SIZE);});return MAX_TEXTURE_SIZE;}exports.queryMaxTextureSize=queryMaxTextureSize;function getChannelsPerTexture(){if(!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')){return 4;}if(environment_1.ENV.get('WEBGL_VERSION')===2){return 1;}return 4;}exports.getChannelsPerTexture=getChannelsPerTexture;function createTexture(gl){return throwIfNull(gl,function(){return gl.createTexture();},'Unable to create WebGLTexture.');}exports.createTexture=createTexture;function validateTextureSize(gl,width,height){var maxTextureSize=queryMaxTextureSize(gl);if(width<=0||height<=0){var requested="["+width+"x"+height+"]";throw new Error('Requested texture size '+requested+' is invalid.');}if(width>maxTextureSize||height>maxTextureSize){var requested="["+width+"x"+height+"]";var max="["+maxTextureSize+"x"+maxTextureSize+"]";throw new Error('Requested texture size '+requested+' greater than WebGL maximum on this browser / GPU '+max+'.');}}exports.validateTextureSize=validateTextureSize;function createFramebuffer(gl){return throwIfNull(gl,function(){return gl.createFramebuffer();},'Unable to create WebGLFramebuffer.');}exports.createFramebuffer=createFramebuffer;function bindVertexBufferToProgramAttribute(gl,program,attribute,buffer,arrayEntriesPerItem,itemStrideInBytes,itemOffsetInBytes,attribLocations){var loc=-1;if(attribLocations!=null&&attribute in attribLocations){loc=attribLocations[attribute];}else{loc=gl.getAttribLocation(program,attribute);}if(loc===-1){return;}callAndCheck(gl,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,buffer);});callAndCheck(gl,function(){return gl.vertexAttribPointer(loc,arrayEntriesPerItem,gl.FLOAT,false,itemStrideInBytes,itemOffsetInBytes);});callAndCheck(gl,function(){return gl.enableVertexAttribArray(loc);});}exports.bindVertexBufferToProgramAttribute=bindVertexBufferToProgramAttribute;function bindTextureUnit(gl,texture,textureUnit){validateTextureUnit(gl,textureUnit);callAndCheck(gl,function(){return gl.activeTexture(gl.TEXTURE0+textureUnit);});callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,texture);});}exports.bindTextureUnit=bindTextureUnit;function unbindTextureUnit(gl,textureUnit){validateTextureUnit(gl,textureUnit);callAndCheck(gl,function(){return gl.activeTexture(gl.TEXTURE0+textureUnit);});callAndCheck(gl,function(){return gl.bindTexture(gl.TEXTURE_2D,null);});}exports.unbindTextureUnit=unbindTextureUnit;function getProgramUniformLocationOrThrow(gl,program,uniformName){return throwIfNull(gl,function(){return gl.getUniformLocation(program,uniformName);},'uniform "'+uniformName+'" not present in program.');}exports.getProgramUniformLocationOrThrow=getProgramUniformLocationOrThrow;function bindTextureToProgramUniformSampler(gl,program,texture,uniformSamplerLocation,textureUnit){callAndCheck(gl,function(){return bindTextureUnit(gl,texture,textureUnit);});callAndCheck(gl,function(){return gl.uniform1i(uniformSamplerLocation,textureUnit);});}exports.bindTextureToProgramUniformSampler=bindTextureToProgramUniformSampler;function bindCanvasToFramebuffer(gl){callAndCheck(gl,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,null);});callAndCheck(gl,function(){return gl.viewport(0,0,gl.canvas.width,gl.canvas.height);});callAndCheck(gl,function(){return gl.scissor(0,0,gl.canvas.width,gl.canvas.height);});}exports.bindCanvasToFramebuffer=bindCanvasToFramebuffer;function bindColorTextureToFramebuffer(gl,texture,framebuffer){callAndCheck(gl,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer);});callAndCheck(gl,function(){return gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);});}exports.bindColorTextureToFramebuffer=bindColorTextureToFramebuffer;function unbindColorTextureFromFramebuffer(gl,framebuffer){callAndCheck(gl,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer);});callAndCheck(gl,function(){return gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,null,0);});}exports.unbindColorTextureFromFramebuffer=unbindColorTextureFromFramebuffer;function validateFramebuffer(gl){var status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);if(status!==gl.FRAMEBUFFER_COMPLETE){throw new Error('Error binding framebuffer: '+getFramebufferErrorMessage(gl,status));}}exports.validateFramebuffer=validateFramebuffer;function getFramebufferErrorMessage(gl,status){switch(status){case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';case gl.FRAMEBUFFER_UNSUPPORTED:return'FRAMEBUFFER_UNSUPPORTED';default:return"unknown error "+status;}}exports.getFramebufferErrorMessage=getFramebufferErrorMessage;function throwIfNull(gl,returnTOrNull,failureMessage){var tOrNull=callAndCheck(gl,function(){return returnTOrNull();});if(tOrNull==null){throw new Error(failureMessage);}return tOrNull;}function validateTextureUnit(gl,textureUnit){var maxTextureUnit=gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1;var glTextureUnit=textureUnit+gl.TEXTURE0;if(glTextureUnit<gl.TEXTURE0||glTextureUnit>maxTextureUnit){var textureUnitRange="[gl.TEXTURE0, gl.TEXTURE"+maxTextureUnit+"]";throw new Error("textureUnit must be in "+textureUnitRange+".");}}function getTextureShapeFromLogicalShape(gl,logShape,preferredTexShape){var maxTexSize=queryMaxTextureSize(gl);var size=util.sizeFromShape(logShape);if(preferredTexShape!=null){var sizePreferred=util.sizeFromShape(preferredTexShape);util.assert(size===sizePreferred,"Size of shape ("+size+") must match size of "+("preferredShape ("+sizePreferred+")"));if(preferredTexShape[0]<=maxTexSize&&preferredTexShape[1]<=maxTexSize){return preferredTexShape;}}if(logShape.length<=1&&size<=maxTexSize){return[size,1];}else if(logShape.length===2&&logShape[0]<=maxTexSize&&logShape[1]<=maxTexSize){return logShape;}else if(logShape.length===3&&logShape[0]<=maxTexSize&&logShape[1]*logShape[2]<=maxTexSize){return[logShape[0],logShape[1]*logShape[2]];}else if(logShape.length===4&&logShape[0]<=maxTexSize&&logShape[1]*logShape[2]*logShape[3]<=maxTexSize){return[logShape[0],logShape[1]*logShape[2]*logShape[3]];}else{return util.sizeToSquarishShape(size);}}exports.getTextureShapeFromLogicalShape=getTextureShapeFromLogicalShape;},{"../../environment":8,"../../util":88}],87:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var environment=require("./environment");var environment_1=require("./environment");var math_cpu_1=require("./math/math_cpu");var math_gpu_1=require("./math/math_gpu");var util=require("./util");exports.TEST_EPSILON=1e-2;function expectArraysClose(actual,expected,epsilon){if(epsilon===void 0){epsilon=exports.TEST_EPSILON;}var aType=actual.constructor.name;var bType=expected.constructor.name;if(aType!==bType){throw new Error("Arrays are of different type "+aType+" vs "+bType);}if(actual.length!==expected.length){throw new Error("Matrices have different lengths ("+actual.length+" vs "+(expected.length+")."));}for(var i=0;i<expected.length;++i){var a=actual[i];var e=expected[i];if(!areClose(a,e,epsilon)){var actualStr="actual["+i+"] === "+a;var expectedStr="expected["+i+"] === "+e;throw new Error('Arrays differ: '+actualStr+', '+expectedStr);}}}exports.expectArraysClose=expectArraysClose;function expectNumbersClose(a,e,epsilon){if(epsilon===void 0){epsilon=exports.TEST_EPSILON;}if(!areClose(a,e,epsilon)){throw new Error("Numbers differ: actual === "+a+", expected === "+e);}}exports.expectNumbersClose=expectNumbersClose;function areClose(a,e,epsilon){if(isNaN(a)&&isNaN(e)){return true;}if(isNaN(a)||isNaN(e)||Math.abs(a-e)>epsilon){return false;}return true;}function randomArrayInRange(n,minValue,maxValue){var v=new Float32Array(n);var range=maxValue-minValue;for(var i=0;i<n;++i){v[i]=Math.random()*range+minValue;}return v;}exports.randomArrayInRange=randomArrayInRange;function makeIdentity(n){var i=new Float32Array(n*n);for(var j=0;j<n;++j){i[j*n+j]=1;}return i;}exports.makeIdentity=makeIdentity;function cpuMultiplyMatrix(a,aRow,aCol,b,bRow,bCol){var result=new Float32Array(aRow*bCol);for(var r=0;r<aRow;++r){var aOffset=r*aCol;var cOffset=r*bCol;for(var c=0;c<bCol;++c){var d=0;for(var k=0;k<aCol;++k){d+=a[aOffset+k]*b[k*bCol+c];}result[cOffset+c]=d;}}return result;}exports.cpuMultiplyMatrix=cpuMultiplyMatrix;function cpuDotProduct(a,b){if(a.length!==b.length){throw new Error('cpuDotProduct: incompatible vectors.');}var d=0;for(var i=0;i<a.length;++i){d+=a[i]*b[i];}return d;}exports.cpuDotProduct=cpuDotProduct;function describeMathCPU(name,tests,featuresList){var testNameBase='math_cpu.'+name;describeWithFeaturesAndExecutor(testNameBase,tests,function(testName,tests,features){return executeMathTests(testName,tests,function(){return new math_cpu_1.NDArrayMathCPU();},features);},featuresList);}exports.describeMathCPU=describeMathCPU;function describeMathGPU(name,tests,featuresList){var testNameBase='math_gpu.'+name;describeWithFeaturesAndExecutor(testNameBase,tests,function(testName,tests,features){return executeMathTests(testName,tests,function(){return new math_gpu_1.NDArrayMathGPU();},features);},featuresList);}exports.describeMathGPU=describeMathGPU;function describeCustom(name,tests,featuresList,customBeforeEach,customAfterEach){describeWithFeaturesAndExecutor(name,[tests],function(testName,tests,features){return executeTests(testName,tests,features,customBeforeEach,customAfterEach);},featuresList);}exports.describeCustom=describeCustom;function describeWithFeaturesAndExecutor(testNameBase,tests,executor,featuresList){if(featuresList!=null){featuresList.forEach(function(features){var testName=testNameBase+' '+JSON.stringify(features);executor(testName,tests,features);});}else{executor(testNameBase,tests);}}var PROMISE_IT=function PROMISE_IT(name,testFunc){it(name,function(done){var result=testFunc();if(result instanceof Promise){result.then(done,function(e){fail(e);done();});}else{done();}});};function executeMathTests(testName,tests,mathFactory,features){var math;var customBeforeEach=function customBeforeEach(){math=mathFactory();math.startScope();};var customAfterEach=function customAfterEach(){math.endScope(null);math.dispose();};var customIt=function customIt(name,testFunc){PROMISE_IT(name,function(){return testFunc(math);});};executeTests(testName,tests,features,customBeforeEach,customAfterEach,customIt);}exports.executeMathTests=executeMathTests;function executeTests(testName,tests,features,customBeforeEach,customAfterEach,customIt){if(customIt===void 0){customIt=PROMISE_IT;}describe(testName,function(){beforeEach(function(){if(features!=null){environment.setEnvironment(new environment_1.Environment(features));}if(customBeforeEach!=null){customBeforeEach();}});afterEach(function(){if(customAfterEach!=null){customAfterEach();}if(features!=null){environment.setEnvironment(new environment_1.Environment());}});tests.forEach(function(test){return test(customIt);});});}exports.executeTests=executeTests;function assertIsNan(val,dtype){if(!util.isValNaN(val,dtype)){throw new Error("Value "+val+" does not represent NaN for dtype "+dtype);}}exports.assertIsNan=assertIsNan;},{"./environment":8,"./math/math_cpu":54,"./math/math_gpu":55,"./util":88}],88:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function shuffle(array){var counter=array.length;var temp=0;var index=0;while(counter>0){index=Math.random()*counter|0;counter--;temp=array[counter];array[counter]=array[index];array[index]=temp;}}exports.shuffle=shuffle;function clamp(min,x,max){return Math.max(min,Math.min(x,max));}exports.clamp=clamp;function randUniform(a,b){return Math.random()*(b-a)+a;}exports.randUniform=randUniform;function randGauss(mean,stdDev,truncated){if(mean===void 0){mean=0;}if(stdDev===void 0){stdDev=1;}if(truncated===void 0){truncated=false;}var v1,v2,s;do{v1=2*Math.random()-1;v2=2*Math.random()-1;s=v1*v1+v2*v2;}while(s>1);var result=Math.sqrt(-2*Math.log(s)/s)*v1;if(truncated&&Math.abs(result)>2){return randGauss(mean,stdDev,true);}return mean+stdDev*result;}exports.randGauss=randGauss;function distSquared(a,b){var result=0;for(var i=0;i<a.length;i++){var diff=Number(a[i])-Number(b[i]);result+=diff*diff;}return result;}exports.distSquared=distSquared;function assert(expr,msg){if(!expr){throw new Error(msg);}}exports.assert=assert;function assertShapesMatch(shapeA,shapeB,errorMessagePrefix){if(errorMessagePrefix===void 0){errorMessagePrefix='';}assert(arraysEqual(shapeA,shapeB),errorMessagePrefix+("Shapes "+shapeA+" and "+shapeB+" must match"));}exports.assertShapesMatch=assertShapesMatch;function flatten(arr,ret){if(ret===void 0){ret=[];}if(Array.isArray(arr)){for(var i=0;i<arr.length;++i){flatten(arr[i],ret);}}else{ret.push(arr);}return ret;}exports.flatten=flatten;function inferShape(arr){var shape=[];while(arr instanceof Array){shape.push(arr.length);arr=arr[0];}return shape;}exports.inferShape=inferShape;function sizeFromShape(shape){if(shape.length===0){return 1;}var size=shape[0];for(var i=1;i<shape.length;i++){size*=shape[i];}return size;}exports.sizeFromShape=sizeFromShape;function isScalarShape(shape){return shape.length===0;}exports.isScalarShape=isScalarShape;function arraysEqual(n1,n2){if(n1.length!==n2.length){return false;}for(var i=0;i<n1.length;i++){if(n1[i]!==n2[i]){return false;}}return true;}exports.arraysEqual=arraysEqual;function isInt(a){return a%1===0;}exports.isInt=isInt;function tanh(x){if(Math.tanh!=null){return Math.tanh(x);}if(x===Infinity){return 1;}else if(x===-Infinity){return-1;}else{var e2x=Math.exp(2*x);return(e2x-1)/(e2x+1);}}exports.tanh=tanh;function sizeToSquarishShape(size){for(var a=Math.floor(Math.sqrt(size));a>1;--a){if(size%a===0){return[a,size/a];}}return[1,size];}exports.sizeToSquarishShape=sizeToSquarishShape;function createShuffledIndices(n){var shuffledIndices=new Uint32Array(n);for(var i=0;i<n;++i){shuffledIndices[i]=i;}shuffle(shuffledIndices);return shuffledIndices;}exports.createShuffledIndices=createShuffledIndices;function rightPad(a,size){if(size<=a.length){return a;}return a+' '.repeat(size-a.length);}exports.rightPad=rightPad;function repeatedTry(checkFn,delayFn,maxCounter){if(delayFn===void 0){delayFn=function delayFn(counter){return 0;};}return new Promise(function(resolve,reject){var tryCount=0;var tryFn=function tryFn(){if(checkFn()){resolve();return;}tryCount++;var nextBackoff=delayFn(tryCount);if(maxCounter!=null&&tryCount>=maxCounter){reject();return;}setTimeout(tryFn,nextBackoff);};setTimeout(tryFn,0);});}exports.repeatedTry=repeatedTry;function getQueryParams(queryString){var params={};queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(s){var t=[];for(var _i=1;_i<arguments.length;_i++){t[_i-1]=arguments[_i];}decodeParam(params,t[0],t[1]);return t.join('=');});return params;}exports.getQueryParams=getQueryParams;function decodeParam(params,name,value){params[decodeURIComponent(name)]=decodeURIComponent(value||'');}function inferFromImplicitShape(shape,size){var shapeProd=1;var implicitIdx=-1;for(var i=0;i<shape.length;++i){if(shape[i]>0){shapeProd*=shape[i];}else if(shape[i]===-1){if(implicitIdx!==-1){throw Error("Shapes can only have 1 implicit size. "+("Found -1 at dim "+implicitIdx+" and dim "+i));}implicitIdx=i;}else if(shape[i]<=0){throw Error("Shapes can not be <= 0. Found "+shape[i]+" at dim "+i);}}if(implicitIdx===-1){if(size>0&&size!==shapeProd){throw Error("Size ("+size+") must match the product of shape "+shape);}return shape;}if(size%shapeProd!==0){throw Error("The implicit shape can't be a fractional number. "+("Got "+size+" / "+shapeProd));}var newShape=shape.slice();newShape[implicitIdx]=size/shapeProd;return newShape;}exports.inferFromImplicitShape=inferFromImplicitShape;exports.NAN_INT32=1<<31;exports.NAN_BOOL=255;exports.NAN_FLOAT32=NaN;function getNaN(dtype){if(dtype==='float32'){return exports.NAN_FLOAT32;}else if(dtype==='int32'){return exports.NAN_INT32;}else if(dtype==='bool'){return exports.NAN_BOOL;}else{throw new Error("Unknown dtype "+dtype);}}exports.getNaN=getNaN;function isValNaN(val,dtype){if(dtype==='float32'){return isNaN(val);}else if(dtype==='int32'){return val===exports.NAN_INT32;}else if(dtype==='bool'){return val===exports.NAN_BOOL;}else{throw new Error("Unknown dtype "+dtype);}}exports.isValNaN=isValNaN;},{}],89:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var version='0.3.7';exports.version=version;},{}],90:[function(require,module,exports){// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.
// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea=require('./lib/alea');// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128=require('./lib/xor128');// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow=require('./lib/xorwow');// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7=require('./lib/xorshift7');// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096=require('./lib/xor4096');// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei=require('./lib/tychei');// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr=require('./seedrandom');sr.alea=alea;sr.xor128=xor128;sr.xorwow=xorwow;sr.xorshift7=xorshift7;sr.xor4096=xor4096;sr.tychei=tychei;module.exports=sr;},{"./lib/alea":91,"./lib/tychei":92,"./lib/xor128":93,"./lib/xor4096":94,"./lib/xorshift7":95,"./lib/xorwow":96,"./seedrandom":97}],91:[function(require,module,exports){// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -
// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
(function(global,module,define){function Alea(seed){var me=this,mash=Mash();me.next=function(){var t=2091639*me.s0+me.c*2.3283064365386963e-10;// 2^-32
me.s0=me.s1;me.s1=me.s2;return me.s2=t-(me.c=t|0);};// Apply the seeding algorithm from Baagoe.
me.c=1;me.s0=mash(' ');me.s1=mash(' ');me.s2=mash(' ');me.s0-=mash(seed);if(me.s0<0){me.s0+=1;}me.s1-=mash(seed);if(me.s1<0){me.s1+=1;}me.s2-=mash(seed);if(me.s2<0){me.s2+=1;}mash=null;}function copy(f,t){t.c=f.c;t.s0=f.s0;t.s1=f.s1;t.s2=f.s2;return t;}function impl(seed,opts){var xg=new Alea(seed),state=opts&&opts.state,prng=xg.next;prng.int32=function(){return xg.next()*0x100000000|0;};prng.double=function(){return prng()+(prng()*0x200000|0)*1.1102230246251565e-16;// 2^-53
};prng.quick=prng;if(state){if((typeof state==="undefined"?"undefined":_typeof(state))=='object')copy(state,xg);prng.state=function(){return copy(xg,{});};}return prng;}function Mash(){var n=0xefc8249d;var mash=function mash(data){data=data.toString();for(var i=0;i<data.length;i++){n+=data.charCodeAt(i);var h=0.02519603282416938*n;n=h>>>0;h-=n;h*=n;n=h>>>0;h-=n;n+=h*0x100000000;// 2^32
}return(n>>>0)*2.3283064365386963e-10;// 2^-32
};return mash;}if(module&&module.exports){module.exports=impl;}else if(define&&define.amd){define(function(){return impl;});}else{this.alea=impl;}})(this,(typeof module==="undefined"?"undefined":_typeof(module))=='object'&&module,// present in node.js
typeof define=='function'&&define// present with an AMD loader
);},{}],92:[function(require,module,exports){// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
(function(global,module,define){function XorGen(seed){var me=this,strseed='';// Set up generator function.
me.next=function(){var b=me.b,c=me.c,d=me.d,a=me.a;b=b<<25^b>>>7^c;c=c-d|0;d=d<<24^d>>>8^a;a=a-b|0;me.b=b=b<<20^b>>>12^c;me.c=c=c-d|0;me.d=d<<16^c>>>16^a;return me.a=a-b|0;};/* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */me.a=0;me.b=0;me.c=2654435769|0;me.d=1367130551;if(seed===Math.floor(seed)){// Integer seed.
me.a=seed/0x100000000|0;me.b=seed|0;}else{// String seed.
strseed+=seed;}// Mix in string seed, then discard an initial batch of 64 values.
for(var k=0;k<strseed.length+20;k++){me.b^=strseed.charCodeAt(k)|0;me.next();}}function copy(f,t){t.a=f.a;t.b=f.b;t.c=f.c;t.d=f.d;return t;};function impl(seed,opts){var xg=new XorGen(seed),state=opts&&opts.state,prng=function prng(){return(xg.next()>>>0)/0x100000000;};prng.double=function(){do{var top=xg.next()>>>11,bot=(xg.next()>>>0)/0x100000000,result=(top+bot)/(1<<21);}while(result===0);return result;};prng.int32=xg.next;prng.quick=prng;if(state){if((typeof state==="undefined"?"undefined":_typeof(state))=='object')copy(state,xg);prng.state=function(){return copy(xg,{});};}return prng;}if(module&&module.exports){module.exports=impl;}else if(define&&define.amd){define(function(){return impl;});}else{this.tychei=impl;}})(this,(typeof module==="undefined"?"undefined":_typeof(module))=='object'&&module,// present in node.js
typeof define=='function'&&define// present with an AMD loader
);},{}],93:[function(require,module,exports){// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
(function(global,module,define){function XorGen(seed){var me=this,strseed='';me.x=0;me.y=0;me.z=0;me.w=0;// Set up generator function.
me.next=function(){var t=me.x^me.x<<11;me.x=me.y;me.y=me.z;me.z=me.w;return me.w^=me.w>>>19^t^t>>>8;};if(seed===(seed|0)){// Integer seed.
me.x=seed;}else{// String seed.
strseed+=seed;}// Mix in string seed, then discard an initial batch of 64 values.
for(var k=0;k<strseed.length+64;k++){me.x^=strseed.charCodeAt(k)|0;me.next();}}function copy(f,t){t.x=f.x;t.y=f.y;t.z=f.z;t.w=f.w;return t;}function impl(seed,opts){var xg=new XorGen(seed),state=opts&&opts.state,prng=function prng(){return(xg.next()>>>0)/0x100000000;};prng.double=function(){do{var top=xg.next()>>>11,bot=(xg.next()>>>0)/0x100000000,result=(top+bot)/(1<<21);}while(result===0);return result;};prng.int32=xg.next;prng.quick=prng;if(state){if((typeof state==="undefined"?"undefined":_typeof(state))=='object')copy(state,xg);prng.state=function(){return copy(xg,{});};}return prng;}if(module&&module.exports){module.exports=impl;}else if(define&&define.amd){define(function(){return impl;});}else{this.xor128=impl;}})(this,(typeof module==="undefined"?"undefined":_typeof(module))=='object'&&module,// present in node.js
typeof define=='function'&&define// present with an AMD loader
);},{}],94:[function(require,module,exports){// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().
(function(global,module,define){function XorGen(seed){var me=this;// Set up generator function.
me.next=function(){var w=me.w,X=me.X,i=me.i,t,v;// Update Weyl generator.
me.w=w=w+0x61c88647|0;// Update xor generator.
v=X[i+34&127];t=X[i=i+1&127];v^=v<<13;t^=t<<17;v^=v>>>15;t^=t>>>12;// Update Xor generator array state.
v=X[i]=v^t;me.i=i;// Result is the combination.
return v+(w^w>>>16)|0;};function init(me,seed){var t,v,i,j,w,X=[],limit=128;if(seed===(seed|0)){// Numeric seeds initialize v, which is used to generates X.
v=seed;seed=null;}else{// String seeds are mixed into v and X one character at a time.
seed=seed+'\0';v=0;limit=Math.max(limit,seed.length);}// Initialize circular array and weyl value.
for(i=0,j=-32;j<limit;++j){// Put the unicode characters into the array, and shuffle them.
if(seed)v^=seed.charCodeAt((j+32)%seed.length);// After 32 shuffles, take v as the starting w value.
if(j===0)w=v;v^=v<<10;v^=v>>>15;v^=v<<4;v^=v>>>13;if(j>=0){w=w+0x61c88647|0;// Weyl.
t=X[j&127]^=v+w;// Combine xor and weyl to init array.
i=0==t?i+1:0;// Count zeroes.
}}// We have detected all zeroes; make the key nonzero.
if(i>=128){X[(seed&&seed.length||0)&127]=-1;}// Run the generator 512 times to further mix the state before using it.
// Factoring this as a function slows the main generator, so it is just
// unrolled here.  The weyl generator is not advanced while warming up.
i=127;for(j=4*128;j>0;--j){v=X[i+34&127];t=X[i=i+1&127];v^=v<<13;t^=t<<17;v^=v>>>15;t^=t>>>12;X[i]=v^t;}// Storing state as object members is faster than using closure variables.
me.w=w;me.X=X;me.i=i;}init(me,seed);}function copy(f,t){t.i=f.i;t.w=f.w;t.X=f.X.slice();return t;};function impl(seed,opts){if(seed==null)seed=+new Date();var xg=new XorGen(seed),state=opts&&opts.state,prng=function prng(){return(xg.next()>>>0)/0x100000000;};prng.double=function(){do{var top=xg.next()>>>11,bot=(xg.next()>>>0)/0x100000000,result=(top+bot)/(1<<21);}while(result===0);return result;};prng.int32=xg.next;prng.quick=prng;if(state){if(state.X)copy(state,xg);prng.state=function(){return copy(xg,{});};}return prng;}if(module&&module.exports){module.exports=impl;}else if(define&&define.amd){define(function(){return impl;});}else{this.xor4096=impl;}})(this,// window object or global
(typeof module==="undefined"?"undefined":_typeof(module))=='object'&&module,// present in node.js
typeof define=='function'&&define// present with an AMD loader
);},{}],95:[function(require,module,exports){// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf
(function(global,module,define){function XorGen(seed){var me=this;// Set up generator function.
me.next=function(){// Update xor generator.
var X=me.x,i=me.i,t,v,w;t=X[i];t^=t>>>7;v=t^t<<24;t=X[i+1&7];v^=t^t>>>10;t=X[i+3&7];v^=t^t>>>3;t=X[i+4&7];v^=t^t<<7;t=X[i+7&7];t=t^t<<13;v^=t^t<<9;X[i]=v;me.i=i+1&7;return v;};function init(me,seed){var j,w,X=[];if(seed===(seed|0)){// Seed state array using a 32-bit integer.
w=X[0]=seed;}else{// Seed state using a string.
seed=''+seed;for(j=0;j<seed.length;++j){X[j&7]=X[j&7]<<15^seed.charCodeAt(j)+X[j+1&7]<<13;}}// Enforce an array length of 8, not all zeroes.
while(X.length<8){X.push(0);}for(j=0;j<8&&X[j]===0;++j){}if(j==8)w=X[7]=-1;else w=X[j];me.x=X;me.i=0;// Discard an initial 256 values.
for(j=256;j>0;--j){me.next();}}init(me,seed);}function copy(f,t){t.x=f.x.slice();t.i=f.i;return t;}function impl(seed,opts){if(seed==null)seed=+new Date();var xg=new XorGen(seed),state=opts&&opts.state,prng=function prng(){return(xg.next()>>>0)/0x100000000;};prng.double=function(){do{var top=xg.next()>>>11,bot=(xg.next()>>>0)/0x100000000,result=(top+bot)/(1<<21);}while(result===0);return result;};prng.int32=xg.next;prng.quick=prng;if(state){if(state.x)copy(state,xg);prng.state=function(){return copy(xg,{});};}return prng;}if(module&&module.exports){module.exports=impl;}else if(define&&define.amd){define(function(){return impl;});}else{this.xorshift7=impl;}})(this,(typeof module==="undefined"?"undefined":_typeof(module))=='object'&&module,// present in node.js
typeof define=='function'&&define// present with an AMD loader
);},{}],96:[function(require,module,exports){// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
(function(global,module,define){function XorGen(seed){var me=this,strseed='';// Set up generator function.
me.next=function(){var t=me.x^me.x>>>2;me.x=me.y;me.y=me.z;me.z=me.w;me.w=me.v;return(me.d=me.d+362437|0)+(me.v=me.v^me.v<<4^(t^t<<1))|0;};me.x=0;me.y=0;me.z=0;me.w=0;me.v=0;if(seed===(seed|0)){// Integer seed.
me.x=seed;}else{// String seed.
strseed+=seed;}// Mix in string seed, then discard an initial batch of 64 values.
for(var k=0;k<strseed.length+64;k++){me.x^=strseed.charCodeAt(k)|0;if(k==strseed.length){me.d=me.x<<10^me.x>>>4;}me.next();}}function copy(f,t){t.x=f.x;t.y=f.y;t.z=f.z;t.w=f.w;t.v=f.v;t.d=f.d;return t;}function impl(seed,opts){var xg=new XorGen(seed),state=opts&&opts.state,prng=function prng(){return(xg.next()>>>0)/0x100000000;};prng.double=function(){do{var top=xg.next()>>>11,bot=(xg.next()>>>0)/0x100000000,result=(top+bot)/(1<<21);}while(result===0);return result;};prng.int32=xg.next;prng.quick=prng;if(state){if((typeof state==="undefined"?"undefined":_typeof(state))=='object')copy(state,xg);prng.state=function(){return copy(xg,{});};}return prng;}if(module&&module.exports){module.exports=impl;}else if(define&&define.amd){define(function(){return impl;});}else{this.xorwow=impl;}})(this,(typeof module==="undefined"?"undefined":_typeof(module))=='object'&&module,// present in node.js
typeof define=='function'&&define// present with an AMD loader
);},{}],97:[function(require,module,exports){/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/(function(pool,math){//
// The following constants are related to IEEE 754 limits.
//
var global=this,width=256,// each RC4 output is 0 <= x < 256
chunks=6,// at least six RC4 outputs for each double
digits=52,// there are 52 significant digits in a double
rngname='random',// rngname: name for Math.random and Math.seedrandom
startdenom=math.pow(width,chunks),significance=math.pow(2,digits),overflow=significance*2,mask=width-1,nodecrypto;// node.js crypto module, initialized at the bottom.
//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed,options,callback){var key=[];options=options==true?{entropy:true}:options||{};// Flatten the seed string or build one from local entropy if needed.
var shortseed=mixkey(flatten(options.entropy?[seed,tostring(pool)]:seed==null?autoseed():seed,3),key);// Use the seed to initialize an ARC4 generator.
var arc4=new ARC4(key);// This function returns a random double in [0, 1) that contains
// randomness in every bit of the mantissa of the IEEE 754 value.
var prng=function prng(){var n=arc4.g(chunks),// Start with a numerator n < 2 ^ 48
d=startdenom,//   and denominator d = 2 ^ 48.
x=0;//   and no 'extra last byte'.
while(n<significance){// Fill up all significant digits by
n=(n+x)*width;//   shifting numerator and
d*=width;//   denominator and generating a
x=arc4.g(1);//   new least-significant-byte.
}while(n>=overflow){// To avoid rounding up, before adding
n/=2;//   last byte, shift everything
d/=2;//   right using integer math until
x>>>=1;//   we have exactly the desired bits.
}return(n+x)/d;// Form the number within [0, 1).
};prng.int32=function(){return arc4.g(4)|0;};prng.quick=function(){return arc4.g(4)/0x100000000;};prng.double=prng;// Mix the randomness into accumulated entropy.
mixkey(tostring(arc4.S),pool);// Calling convention: what to return as a function of prng, seed, is_math.
return(options.pass||callback||function(prng,seed,is_math_call,state){if(state){// Load the arc4 state from the given state if it has an S array.
if(state.S){copy(state,arc4);}// Only provide the .state method if requested via options.state.
prng.state=function(){return copy(arc4,{});};}// If called as a method of Math (Math.seedrandom()), mutate
// Math.random because that is how seedrandom.js has worked since v1.0.
if(is_math_call){math[rngname]=prng;return seed;}// Otherwise, it is a newer calling convention, so return the
// prng directly.
else return prng;})(prng,shortseed,'global'in options?options.global:this==math,options.state);}math['seed'+rngname]=seedrandom;//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key){var t,keylen=key.length,me=this,i=0,j=me.i=me.j=0,s=me.S=[];// The empty key [] is treated as [0].
if(!keylen){key=[keylen++];}// Set up S using the standard key scheduling algorithm.
while(i<width){s[i]=i++;}for(i=0;i<width;i++){s[i]=s[j=mask&j+key[i%keylen]+(t=s[i])];s[j]=t;}// The "g" method returns the next (count) outputs as one number.
(me.g=function(count){// Using instance members instead of closure state nearly doubles speed.
var t,r=0,i=me.i,j=me.j,s=me.S;while(count--){t=s[i=mask&i+1];r=r*width+s[mask&(s[i]=s[j=mask&j+t])+(s[j]=t)];}me.i=i;me.j=j;return r;// For robust unpredictability, the function call below automatically
// discards an initial batch of values.  This is called RC4-drop[256].
// See http://google.com/search?q=rsa+fluhrer+response&btnI
})(width);}//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f,t){t.i=f.i;t.j=f.j;t.S=f.S.slice();return t;};//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj,depth){var result=[],typ=typeof obj==="undefined"?"undefined":_typeof(obj),prop;if(depth&&typ=='object'){for(prop in obj){try{result.push(flatten(obj[prop],depth-1));}catch(e){}}}return result.length?result:typ=='string'?obj:obj+'\0';}//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed,key){var stringseed=seed+'',smear,j=0;while(j<stringseed.length){key[mask&j]=mask&(smear^=key[mask&j]*19)+stringseed.charCodeAt(j++);}return tostring(key);}//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed(){try{var out;if(nodecrypto&&(out=nodecrypto.randomBytes)){// The use of 'out' to remember randomBytes makes tight minified code.
out=out(width);}else{out=new Uint8Array(width);(global.crypto||global.msCrypto).getRandomValues(out);}return tostring(out);}catch(e){var browser=global.navigator,plugins=browser&&browser.plugins;return[+new Date(),global,plugins,global.screen,tostring(pool)];}}//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a){return String.fromCharCode.apply(0,a);}//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(),pool);//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if((typeof module==="undefined"?"undefined":_typeof(module))=='object'&&module.exports){module.exports=seedrandom;// When in node.js, try using crypto package for autoseeding.
try{nodecrypto=require('crypto');}catch(ex){}}else if(typeof define=='function'&&define.amd){define(function(){return seedrandom;});}// End anonymous scope, and pass initial values.
})([],// pool: entropy pool starts empty
Math// math: package containing random, pow, and seedrandom
);},{"crypto":2}],98:[function(require,module,exports){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator["throw"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value);}).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=y[op[0]&2?"return":op[0]?"throw":"next"])&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[0,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,"__esModule",{value:true});var deeplearn_1=require("deeplearn");var imagenet_classes_1=require("./imagenet_classes");var GOOGLE_CLOUD_STORAGE_DIR='https://storage.googleapis.com/learnjs-data/checkpoint_zoo/';var SqueezeNet=function(){function SqueezeNet(math){this.math=math;this.preprocessOffset=deeplearn_1.Array1D.new([103.939,116.779,123.68]);deeplearn_1.initializeGPU(this.math.getGPGPUContext(),this.math.getTextureManager());}SqueezeNet.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var checkpointLoader,_a;return __generator(this,function(_b){switch(_b.label){case 0:checkpointLoader=new deeplearn_1.CheckpointLoader(GOOGLE_CLOUD_STORAGE_DIR+'squeezenet1_1/');_a=this;return[4,checkpointLoader.getAllVariables()];case 1:_a.variables=_b.sent();return[2];}});});};SqueezeNet.prototype.predict=function(input){return __awaiter(this,void 0,void 0,function(){var _this=this;var namedActivations,avgpool10,layerNames;return __generator(this,function(_a){namedActivations={};avgpool10=this.math.scope(function(keep){var preprocessedInput=_this.math.subtract(input,_this.preprocessOffset);var conv1=_this.math.conv2d(preprocessedInput,_this.variables['conv1_W:0'],_this.variables['conv1_b:0'],2,0);var conv1relu=keep(_this.math.relu(conv1));namedActivations['conv_1']=conv1relu;var pool1=keep(_this.math.maxPool(conv1relu,3,2,0));namedActivations['maxpool_1']=pool1;var fire2=keep(_this.fireModule(pool1,2));namedActivations['fire2']=fire2;var fire3=keep(_this.fireModule(fire2,3));namedActivations['fire3']=fire3;var pool2=keep(_this.math.maxPool(fire3,3,2,'valid'));namedActivations['maxpool_2']=pool2;var fire4=keep(_this.fireModule(pool2,4));namedActivations['fire4']=fire4;var fire5=keep(_this.fireModule(fire4,5));namedActivations['fire5']=fire5;var pool3=keep(_this.math.maxPool(fire5,3,2,0));namedActivations['maxpool_3']=pool3;var fire6=keep(_this.fireModule(pool3,6));namedActivations['fire6']=fire6;var fire7=keep(_this.fireModule(fire6,7));namedActivations['fire7']=fire7;var fire8=keep(_this.fireModule(fire7,8));namedActivations['fire8']=fire8;var fire9=keep(_this.fireModule(fire8,9));namedActivations['fire9']=fire9;var conv10=keep(_this.math.conv2d(fire9,_this.variables['conv10_W:0'],_this.variables['conv10_b:0'],1,0));namedActivations['conv10']=conv10;return _this.math.avgPool(conv10,conv10.shape[0],1,0).as1D();});layerNames=Object.keys(namedActivations);layerNames.forEach(function(layerName){return _this.math.track(namedActivations[layerName]);});return[2,{namedActivations:namedActivations,logits:avgpool10}];});});};SqueezeNet.prototype.fireModule=function(input,fireId){var y1=this.math.conv2d(input,this.variables["fire"+fireId+"/squeeze1x1_W:0"],this.variables["fire"+fireId+"/squeeze1x1_b:0"],1,0);var y2=this.math.relu(y1);var left1=this.math.conv2d(y2,this.variables["fire"+fireId+"/expand1x1_W:0"],this.variables["fire"+fireId+"/expand1x1_b:0"],1,0);var left2=this.math.relu(left1);var right1=this.math.conv2d(y2,this.variables["fire"+fireId+"/expand3x3_W:0"],this.variables["fire"+fireId+"/expand3x3_b:0"],1,1);var right2=this.math.relu(right1);return this.math.concat3D(left2,right2,2);};SqueezeNet.prototype.getTopKClasses=function(logits,topK){return __awaiter(this,void 0,void 0,function(){var predictions,topk,topkIndices,topkValues,topClassesToProbability,i;return __generator(this,function(_a){switch(_a.label){case 0:predictions=this.math.softmax(logits);topk=new deeplearn_1.NDArrayMathCPU().topK(predictions,topK);return[4,topk.indices.data()];case 1:topkIndices=_a.sent();return[4,topk.values.data()];case 2:topkValues=_a.sent();topClassesToProbability={};for(i=0;i<topkIndices.length;i++){topClassesToProbability[imagenet_classes_1.IMAGENET_CLASSES[topkIndices[i]]]=topkValues[i];}return[2,topClassesToProbability];}});});};SqueezeNet.prototype.dispose=function(){this.preprocessOffset.dispose();for(var varName in this.variables){this.variables[varName].dispose();}};return SqueezeNet;}();exports.SqueezeNet=SqueezeNet;},{"./imagenet_classes":1,"deeplearn":44}]},{},[98])(98);});

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KNNImageClassifier = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     KNN Image Classifier model
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _deeplearnKnnImageClassifier = __webpack_require__(370);

var _deeplearn = __webpack_require__(38);

var _utils = __webpack_require__(68);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var KNNImageClassifier = function () {
  function KNNImageClassifier(callback) {
    var _this = this;

    _classCallCheck(this, KNNImageClassifier);

    this.knnKValue = 5;
    this.maxControls = 15;
    this.modelLoaded = false;
    this.classifier = new _deeplearnKnnImageClassifier.KNNImageClassifier(this.maxControls, this.knnKValue, _utils.math);
    var loadModel = this.classifier.load();
    loadModel.then(function () {
      _this.modelLoaded = true;
      callback();
    });
  }

  _createClass(KNNImageClassifier, [{
    key: 'addImage',
    value: function addImage(input, index) {
      var _this2 = this;

      if (this.modelLoaded) {
        _utils.math.scope(function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(keep, track) {
            var image;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    image = track(_deeplearn.Array3D.fromPixels(input));
                    _context.next = 3;
                    return _this2.classifier.addImage(image, index);

                  case 3:
                  case 'end':
                    return _context.stop();
                }
              }
            }, _callee, _this2);
          }));

          return function (_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }());
      } else {
        console.log('The Model has not finished loading. Wait until it loads and try again');
      }
    }
  }, {
    key: 'predict',
    value: function predict(input, callback) {
      var _this3 = this;

      if (this.modelLoaded) {
        _utils.math.scope(function () {
          var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(keep, track) {
            var image, results;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    image = _deeplearn.Array3D.fromPixels(input);
                    _context2.next = 3;
                    return _this3.classifier.predict(image);

                  case 3:
                    results = _context2.sent;

                    callback(results);

                  case 5:
                  case 'end':
                    return _context2.stop();
                }
              }
            }, _callee2, _this3);
          }));

          return function (_x3, _x4) {
            return _ref2.apply(this, arguments);
          };
        }());
      } else {
        console.log('The Model has not finished loading. Wait until it loads and try again');
      }
    }
  }]);

  return KNNImageClassifier;
}();

exports.KNNImageClassifier = KNNImageClassifier;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LSTMGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     A LSTM Generator: run inference mode for a LSTM.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Currently working with models trained using https://github.com/sherjilozair/char-rnn-tensorflow
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _deeplearn = __webpack_require__(38);

var _utils = __webpack_require__(68);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var regexCell = /cell_[0-9]|lstm_[0-9]/gi;
var regexWeights = /weights|weight|kernel|kernels|w/gi;
var regexBiases = /biases|bias|b/gi;
var regexFullyConnected = /softmax/gi;

var LSTMGenerator = function () {
  function LSTMGenerator(modelPath) {
    _classCallCheck(this, LSTMGenerator);

    this.checkpointsLoaded = false;
    this.model = {};
    this.loadCheckpoints(modelPath);
    this.loadVocab(modelPath);
  }

  // Load checkpoints


  _createClass(LSTMGenerator, [{
    key: 'loadCheckpoints',
    value: function loadCheckpoints(path) {
      var _this = this;

      var reader = new _deeplearn.CheckpointLoader(path);
      reader.getAllVariables().then(function (vars) {
        _this.cellsAmount = 0;
        for (var key in vars) {
          if (key.match(regexCell)) {
            if (key.match(regexWeights)) {
              _this.model['Kernel_' + key.match(/[0-9]/)[0]] = vars[key];
              _this.cellsAmount++;
            } else {
              _this.model['Bias_' + key.match(/[0-9]/)[0]] = vars[key];
            }
          } else if (key.match(regexFullyConnected)) {
            if (key.match(regexWeights)) {
              _this.model['fullyConnectedWeights'] = vars[key];
            } else {
              _this.model['fullyConnectedBiases'] = vars[key];
            }
          } else {
            _this.model[key] = vars[key];
          }
        }
        _this.checkpointsLoaded = true;
      });
    }
  }, {
    key: 'loadVocab',
    value: function loadVocab(path) {
      var _this2 = this;

      fetch(path + '/vocab.json').then(function (response) {
        return response.json();
      }).then(function (json) {
        _this2.vocab = json;
        _this2.vocabSize = Object.keys(json).length;
      });
    }

    // Generate text

  }, {
    key: 'generate',
    value: function generate(options, callback) {
      var _this3 = this;

      options.seed || (options.seed = 'a');
      options.length || (options.length = 20);
      options.temperature || (options.temperature = 0.5);
      var results = [];

      if (!this.checkpointsLoaded) {
        setTimeout(function () {
          _this3.generate(options, callback);
        }, 100);
      } else {
        _utils.math.scope(function (keep, track) {
          var forgetBias = track(_deeplearn.Scalar.new(1.0));

          var LSTMCells = [];
          var c = [];
          var h = [];

          for (var i = 0; i < _this3.cellsAmount; i++) {
            LSTMCells.push(_utils.math.basicLSTMCell.bind(_utils.math, forgetBias, _this3.model['Kernel_' + i], _this3.model['Bias_' + i]));
            c.push(track(_deeplearn.Array2D.zeros([1, _this3.model['Bias_' + i].shape[0] / 4])));
            h.push(track(_deeplearn.Array2D.zeros([1, _this3.model['Bias_' + i].shape[0] / 4])));
          }

          var userInput = Array.from(options.seed);

          var encoded_input = [];
          userInput.forEach(function (char, ind) {
            ind < 100 && encoded_input.push(_this3.vocab[char]);
          });

          var current = 0;
          var input = encoded_input[current];

          for (var _i = 0; _i < userInput.length + options.length; _i++) {
            var onehot = track(_deeplearn.Array2D.zeros([1, _this3.vocabSize]));
            onehot.set(1.0, 0, input);

            var output = void 0;
            if (_this3.model.embedding) {
              var embedded = _utils.math.matMul(onehot, _this3.model.embedding);
              output = _utils.math.multiRNNCell(LSTMCells, embedded, c, h);
            } else {
              output = _utils.math.multiRNNCell(LSTMCells, onehot, c, h);
            }

            c = output[0];
            h = output[1];

            var outputH = h[1];
            var weightedResult = _utils.math.matMul(outputH, _this3.model.fullyConnectedWeights);
            var logits = _utils.math.add(weightedResult, _this3.model.fullyConnectedBiases);

            var divided = _utils.math.arrayDividedByScalar(logits, _deeplearn.Scalar.new(options.temperature));
            var probabilities = _utils.math.exp(divided);
            var normalized = _utils.math.divide(probabilities, _utils.math.sum(probabilities)).getValues();
            var sampledResult = (0, _utils.sampleFromDistribution)(normalized);

            if (userInput.length > current) {
              current++;
              input = encoded_input[current];
            } else {
              input = sampledResult;
              results.push(sampledResult);
            }
          }
        });

        var generated = '';

        results.forEach(function (c, i) {
          var mapped = Object.keys(_this3.vocab).find(function (key) {
            return _this3.vocab[key] === c;
          });
          mapped && (generated += mapped);
        });

        callback({
          generated: generated
        });
      }
    }
  }]);

  return LSTMGenerator;
}();

exports.LSTMGenerator = LSTMGenerator;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NeuralNetwork = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Simple Artificial Neural Network
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Based on https://github.com/shiffman/Neural-Network-p5 by Daniel Shiffman 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Based on "Make Your Own Neural Network" by Tariq Rashid
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     https://github.com/makeyourownneuralnetwork/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

//import { activationFunctions, derivatives } from './activationFunctions';


var _index = __webpack_require__(68);

var _deeplearn = __webpack_require__(38);

var _math = __webpack_require__(57);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NeuralNetwork = function () {
  function NeuralNetwork(inputnodes, hiddennodes, outputnodes) {
    var learning_rate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;
    var activation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'sigmoid';

    _classCallCheck(this, NeuralNetwork);

    // Number of nodes in layer (input, hidden, output)
    // This network is limited to 3 layers
    this.inodes = inputnodes;
    this.hnodes = hiddennodes;
    this.onodes = outputnodes;

    this.wih = _deeplearn.Array2D.randNormal([this.hnodes, this.inodes]);
    this.who = _deeplearn.Array2D.randNormal([this.onodes, this.hnodes]);

    //this.activation = activationFunctions[activation];
    //this.derivative = derivatives[activation];

    this.learning_rate = _deeplearn.Scalar.new(learning_rate);
  }

  _createClass(NeuralNetwork, [{
    key: 'train',
    value: function train(inputs_array, targets_array) {
      // convert inputs list to 2d array
      var inputs = _index.math.transpose(_deeplearn.Array2D.new([1, inputs_array.length], inputs_array));
      var targets = _index.math.transpose(_deeplearn.Array2D.new([1, targets_array.length], targets_array));

      // calculate signals into hidden layer
      var hidden_inputs = _index.math.matMul(this.wih, inputs);
      // calculate the signals emerging from hidden layer
      var hidden_outputs = _index.math.sigmoid(hidden_inputs);

      // calculate signals into final output layer
      var final_inputs = _index.math.matMul(this.who, hidden_outputs);
      // calculate signals emerging from final output layer
      var final_outputs = _index.math.sigmoid(final_inputs);

      // output layer error is the (target - actual)
      var output_errors = _index.math.subtract(targets, final_outputs);
      // hidden layer error is the output_errors, split by weights, recombined at hidden node
      var hidden_errors = _index.math.matMul(_index.math.transpose(this.who), output_errors);
      // Start Backpropagation
      // Update the weights for the links between the hidden and output layers  
      this.who = _index.math.add(this.who, _index.math.multiply(this.learning_rate, _index.math.matMul(_index.math.multiply(_index.math.multiply(output_errors, final_outputs), _index.math.subtract(_deeplearn.Scalar.new(1), final_outputs)), _index.math.transpose(hidden_outputs))));

      // Update the weights for the links between the input and the hidden layer
      this.wih = _index.math.add(this.wih, _index.math.multiply(this.learning_rate, _index.math.matMul(_index.math.multiply(_index.math.multiply(hidden_errors, hidden_outputs), _index.math.subtract(_deeplearn.Scalar.new(1), hidden_outputs)), _index.math.transpose(inputs))));
    }
  }, {
    key: 'query',
    value: function query(inputs_array) {
      // convert inputs list to 2d array
      var inputs = _index.math.transpose(_deeplearn.Array2D.new([1, inputs_array.length], inputs_array));

      // Calculate signals into hidden layer
      var hidden_inputs = _index.math.matMul(this.wih, inputs);
      // Calculate the signals emerging from the hidden layer
      var hidden_outputs = _index.math.sigmoid(hidden_inputs);

      // Calculate signals into final output layer
      var final_inputs = _index.math.matMul(this.who, hidden_outputs);
      var final_outputs = _index.math.sigmoid(final_inputs);
      return {
        argMax: _index.math.argMax(final_outputs).getValues()[0],
        result: Array.from(final_outputs.getValues())
      };
    }
  }]);

  return NeuralNetwork;
}();

exports.NeuralNetwork = NeuralNetwork;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// Random

// Returns a random number between min (inclusive) and max (exclusive)
var randomFloat = function randomFloat() {
  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return Math.random() * (max - min) + min;
};

// Returns a random integer between min (inclusive) and max (inclusive)
var randomInt = function randomInt() {
  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return Math.floor(Math.random() * (max - min + 1)) + min;
};

// Random Number following a normal dist. 
// Taken from https://github.com/processing/p5.js/blob/master/src/math/random.js#L168
var randomGaussian = function randomGaussian() {
  var mean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var sd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  var y1 = void 0,
      y2 = void 0,
      x1 = void 0,
      x2 = void 0,
      w = void 0;
  var previous = void 0;
  if (previous) {
    y1 = y2;
    previous = false;
  } else {
    do {
      x1 = randomFloat(0, 2) - 1;
      x2 = randomFloat(0, 2) - 1;
      w = x1 * x1 + x2 * x2;
    } while (w >= 1);
    w = Math.sqrt(-2 * Math.log(w) / w);
    y1 = x1 * w;
    y2 = x2 * w;
    previous = true;
  }
  return y1 * sd + mean;
};

exports.randomFloat = randomFloat;
exports.randomInt = randomInt;
exports.randomGaussian = randomGaussian;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// Utils for sampling

// Sample from a distrubution
var sampleFromDistribution = function sampleFromDistribution(input) {
  var randomValue = Math.random();
  var sum = 0,
      result = void 0;
  for (var j = 0; j < input.length; j++) {
    sum += input[j];
    if (randomValue < sum) {
      result = j;
      break;
    }
  }
  return result;
};

exports.sampleFromDistribution = sampleFromDistribution;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(159)))

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(177);
module.exports = __webpack_require__(27).RegExp.escape;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
var isArray = __webpack_require__(73);
var SPECIES = __webpack_require__(7)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = __webpack_require__(3);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(31);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(44);
var gOPS = __webpack_require__(77);
var pIE = __webpack_require__(63);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 175 */
/***/ (function(module, exports) {

module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};


/***/ }),
/* 176 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(0);
var $re = __webpack_require__(175)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { copyWithin: __webpack_require__(113) });

__webpack_require__(36)('copyWithin');


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $every = __webpack_require__(26)(4);

$export($export.P + $export.F * !__webpack_require__(25)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { fill: __webpack_require__(83) });

__webpack_require__(36)('fill');


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $filter = __webpack_require__(26)(2);

$export($export.P + $export.F * !__webpack_require__(25)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(26)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(36)(KEY);


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(26)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(36)(KEY);


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $forEach = __webpack_require__(26)(0);
var STRICT = __webpack_require__(25)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(24);
var $export = __webpack_require__(0);
var toObject = __webpack_require__(11);
var call = __webpack_require__(124);
var isArrayIter = __webpack_require__(91);
var toLength = __webpack_require__(10);
var createProperty = __webpack_require__(85);
var getIterFn = __webpack_require__(107);

$export($export.S + $export.F * !__webpack_require__(75)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $indexOf = __webpack_require__(69)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(25)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', { isArray: __webpack_require__(73) });


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)
var $export = __webpack_require__(0);
var toIObject = __webpack_require__(20);
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(62) != Object || !__webpack_require__(25)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(20);
var toInteger = __webpack_require__(30);
var toLength = __webpack_require__(10);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(25)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $map = __webpack_require__(26)(1);

$export($export.P + $export.F * !__webpack_require__(25)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var createProperty = __webpack_require__(85);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(3)(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $reduce = __webpack_require__(115);

$export($export.P + $export.F * !__webpack_require__(25)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $reduce = __webpack_require__(115);

$export($export.P + $export.F * !__webpack_require__(25)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var html = __webpack_require__(89);
var cof = __webpack_require__(23);
var toAbsoluteIndex = __webpack_require__(48);
var toLength = __webpack_require__(10);
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(3)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $some = __webpack_require__(26)(3);

$export($export.P + $export.F * !__webpack_require__(25)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var aFunction = __webpack_require__(13);
var toObject = __webpack_require__(11);
var fails = __webpack_require__(3);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(25)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(47)('Array');


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0);
var toISOString = __webpack_require__(172);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(11);
var toPrimitive = __webpack_require__(31);

$export($export.P + $export.F * __webpack_require__(3)(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(7)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(15)(proto, TO_PRIMITIVE, __webpack_require__(173));


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(16)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(0);

$export($export.P, 'Function', { bind: __webpack_require__(116) });


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(5);
var getPrototypeOf = __webpack_require__(19);
var HAS_INSTANCE = __webpack_require__(7)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(9).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(9).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(8) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0);
var log1p = __webpack_require__(127);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0);
var sign = __webpack_require__(95);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0);
var $expm1 = __webpack_require__(94);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { fround: __webpack_require__(126) });


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = __webpack_require__(0);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { log1p: __webpack_require__(127) });


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { sign: __webpack_require__(95) });


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(94);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(94);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var has = __webpack_require__(14);
var cof = __webpack_require__(23);
var inheritIfRequired = __webpack_require__(90);
var toPrimitive = __webpack_require__(31);
var fails = __webpack_require__(3);
var gOPN = __webpack_require__(43).f;
var gOPD = __webpack_require__(18).f;
var dP = __webpack_require__(9).f;
var $trim = __webpack_require__(54).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(42)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(8) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(16)(global, NUMBER, $Number);
}


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(0);
var _isFinite = __webpack_require__(2).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', { isInteger: __webpack_require__(123) });


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(0);
var isInteger = __webpack_require__(123);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(135);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(136);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toInteger = __webpack_require__(30);
var aNumberValue = __webpack_require__(112);
var repeat = __webpack_require__(102);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(3)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $fails = __webpack_require__(3);
var aNumberValue = __webpack_require__(112);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(129) });


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(42) });


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(8), 'Object', { defineProperties: __webpack_require__(130) });


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(8), 'Object', { defineProperty: __webpack_require__(9).f });


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(5);
var meta = __webpack_require__(37).onFreeze;

__webpack_require__(29)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(20);
var $getOwnPropertyDescriptor = __webpack_require__(18).f;

__webpack_require__(29)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(29)('getOwnPropertyNames', function () {
  return __webpack_require__(131).f;
});


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(11);
var $getPrototypeOf = __webpack_require__(19);

__webpack_require__(29)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(5);

__webpack_require__(29)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(5);

__webpack_require__(29)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(5);

__webpack_require__(29)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { is: __webpack_require__(176) });


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(11);
var $keys = __webpack_require__(44);

__webpack_require__(29)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(5);
var meta = __webpack_require__(37).onFreeze;

__webpack_require__(29)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(5);
var meta = __webpack_require__(37).onFreeze;

__webpack_require__(29)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(98).set });


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(61);
var test = {};
test[__webpack_require__(7)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(16)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(135);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(136);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(41);
var global = __webpack_require__(2);
var ctx = __webpack_require__(24);
var classof = __webpack_require__(61);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(5);
var aFunction = __webpack_require__(13);
var anInstance = __webpack_require__(39);
var forOf = __webpack_require__(40);
var speciesConstructor = __webpack_require__(81);
var task = __webpack_require__(104).set;
var microtask = __webpack_require__(96)();
var newPromiseCapabilityModule = __webpack_require__(97);
var perform = __webpack_require__(137);
var promiseResolve = __webpack_require__(138);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(7)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(46)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(53)($Promise, PROMISE);
__webpack_require__(47)(PROMISE);
Wrapper = __webpack_require__(27)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(75)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(13);
var anObject = __webpack_require__(1);
var rApply = (__webpack_require__(2).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(3)(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(0);
var create = __webpack_require__(42);
var aFunction = __webpack_require__(13);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(5);
var fails = __webpack_require__(3);
var bind = __webpack_require__(116);
var rConstruct = (__webpack_require__(2).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(9);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(31);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(3)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(0);
var gOPD = __webpack_require__(18).f;
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
__webpack_require__(92)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(18);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(0);
var getProto = __webpack_require__(19);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(18);
var getPrototypeOf = __webpack_require__(19);
var has = __webpack_require__(14);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(5);
var anObject = __webpack_require__(1);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(134) });


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(0);
var setProto = __webpack_require__(98);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(9);
var gOPD = __webpack_require__(18);
var getPrototypeOf = __webpack_require__(19);
var has = __webpack_require__(14);
var $export = __webpack_require__(0);
var createDesc = __webpack_require__(45);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(5);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var inheritIfRequired = __webpack_require__(90);
var dP = __webpack_require__(9).f;
var gOPN = __webpack_require__(43).f;
var isRegExp = __webpack_require__(74);
var $flags = __webpack_require__(72);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(8) && (!CORRECT_NEW || __webpack_require__(3)(function () {
  re2[__webpack_require__(7)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(16)(global, 'RegExp', $RegExp);
}

__webpack_require__(47)('RegExp');


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(71)('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(71)('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(71)('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(71)('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = __webpack_require__(74);
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(143);
var anObject = __webpack_require__(1);
var $flags = __webpack_require__(72);
var DESCRIPTORS = __webpack_require__(8);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(16)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(3)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(17)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()
__webpack_require__(17)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()
__webpack_require__(17)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__(17)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $at = __webpack_require__(100)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(10);
var context = __webpack_require__(101);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(88)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__(17)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(17)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(17)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toAbsoluteIndex = __webpack_require__(48);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(0);
var context = __webpack_require__(101);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(88)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()
__webpack_require__(17)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(100)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(93)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__(17)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(20);
var toLength = __webpack_require__(10);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(102)
});


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()
__webpack_require__(17)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(10);
var context = __webpack_require__(101);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(88)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()
__webpack_require__(17)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(17)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()
__webpack_require__(17)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__(54)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(2);
var has = __webpack_require__(14);
var DESCRIPTORS = __webpack_require__(8);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(16);
var META = __webpack_require__(37).KEY;
var $fails = __webpack_require__(3);
var shared = __webpack_require__(80);
var setToStringTag = __webpack_require__(53);
var uid = __webpack_require__(49);
var wks = __webpack_require__(7);
var wksExt = __webpack_require__(141);
var wksDefine = __webpack_require__(106);
var enumKeys = __webpack_require__(174);
var isArray = __webpack_require__(73);
var anObject = __webpack_require__(1);
var toIObject = __webpack_require__(20);
var toPrimitive = __webpack_require__(31);
var createDesc = __webpack_require__(45);
var _create = __webpack_require__(42);
var gOPNExt = __webpack_require__(131);
var $GOPD = __webpack_require__(18);
var $DP = __webpack_require__(9);
var $keys = __webpack_require__(44);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(43).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(63).f = $propertyIsEnumerable;
  __webpack_require__(77).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(41)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(15)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $typed = __webpack_require__(82);
var buffer = __webpack_require__(105);
var anObject = __webpack_require__(1);
var toAbsoluteIndex = __webpack_require__(48);
var toLength = __webpack_require__(10);
var isObject = __webpack_require__(5);
var ArrayBuffer = __webpack_require__(2).ArrayBuffer;
var speciesConstructor = __webpack_require__(81);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(3)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(47)(ARRAY_BUFFER);


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(82).ABV, {
  DataView: __webpack_require__(105).DataView
});


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(34)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(34)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(34)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(34)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(34)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(34)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(34)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(34)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(34)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(119);
var validate = __webpack_require__(55);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(70)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(120);
var toObject = __webpack_require__(11);
var toLength = __webpack_require__(10);
var aFunction = __webpack_require__(13);
var arraySpeciesCreate = __webpack_require__(84);

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(36)('flatMap');


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(120);
var toObject = __webpack_require__(11);
var toLength = __webpack_require__(10);
var toInteger = __webpack_require__(30);
var arraySpeciesCreate = __webpack_require__(84);

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(36)('flatten');


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(0);
var $includes = __webpack_require__(69)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(36)('includes');


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(0);
var microtask = __webpack_require__(96)();
var process = __webpack_require__(2).process;
var isNode = __webpack_require__(23)(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(0);
var cof = __webpack_require__(23);

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.G, { global: __webpack_require__(2) });


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(78)('Map');


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(79)('Map');


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(118)('Map') });


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var scale = __webpack_require__(128);
var fround = __webpack_require__(126);

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { scale: __webpack_require__(128) });


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(0);

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(11);
var aFunction = __webpack_require__(13);
var $defineProperty = __webpack_require__(9);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(8) && $export($export.P + __webpack_require__(76), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(11);
var aFunction = __webpack_require__(13);
var $defineProperty = __webpack_require__(9);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(8) && $export($export.P + __webpack_require__(76), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $entries = __webpack_require__(133)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(0);
var ownKeys = __webpack_require__(134);
var toIObject = __webpack_require__(20);
var gOPD = __webpack_require__(18);
var createProperty = __webpack_require__(85);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(11);
var toPrimitive = __webpack_require__(31);
var getPrototypeOf = __webpack_require__(19);
var getOwnPropertyDescriptor = __webpack_require__(18).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(8) && $export($export.P + __webpack_require__(76), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(11);
var toPrimitive = __webpack_require__(31);
var getPrototypeOf = __webpack_require__(19);
var getOwnPropertyDescriptor = __webpack_require__(18).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(8) && $export($export.P + __webpack_require__(76), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $values = __webpack_require__(133)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/zenparsing/es-observable
var $export = __webpack_require__(0);
var global = __webpack_require__(2);
var core = __webpack_require__(27);
var microtask = __webpack_require__(96)();
var OBSERVABLE = __webpack_require__(7)('observable');
var aFunction = __webpack_require__(13);
var anObject = __webpack_require__(1);
var anInstance = __webpack_require__(39);
var redefineAll = __webpack_require__(46);
var hide = __webpack_require__(15);
var forOf = __webpack_require__(40);
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

__webpack_require__(47)('Observable');


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(0);
var core = __webpack_require__(27);
var global = __webpack_require__(2);
var speciesConstructor = __webpack_require__(81);
var promiseResolve = __webpack_require__(138);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(0);
var newPromiseCapability = __webpack_require__(97);
var perform = __webpack_require__(137);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(33);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(33);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(144);
var from = __webpack_require__(114);
var metadata = __webpack_require__(33);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(19);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(33);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(19);
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(33);
var anObject = __webpack_require__(1);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(33);
var anObject = __webpack_require__(1);
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(33);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(19);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(33);
var anObject = __webpack_require__(1);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(33);
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(13);
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(78)('Set');


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(79)('Set');


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(118)('Set') });


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/mathiasbynens/String.prototype.at
var $export = __webpack_require__(0);
var $at = __webpack_require__(100)(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/String.prototype.matchAll/
var $export = __webpack_require__(0);
var defined = __webpack_require__(28);
var toLength = __webpack_require__(10);
var isRegExp = __webpack_require__(74);
var getFlags = __webpack_require__(72);
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(92)($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(139);

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(139);

$export($export.P, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(54)('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');


/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(54)('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(106)('asyncIterator');


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(106)('observable');


/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.S, 'System', { global: __webpack_require__(2) });


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(78)('WeakMap');


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(79)('WeakMap');


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(78)('WeakSet');


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(79)('WeakSet');


/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(108);
var getKeys = __webpack_require__(44);
var redefine = __webpack_require__(16);
var global = __webpack_require__(2);
var hide = __webpack_require__(15);
var Iterators = __webpack_require__(52);
var wks = __webpack_require__(7);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $task = __webpack_require__(104);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var navigator = global.navigator;
var slice = [].slice;
var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(297);
__webpack_require__(236);
__webpack_require__(238);
__webpack_require__(237);
__webpack_require__(240);
__webpack_require__(242);
__webpack_require__(247);
__webpack_require__(241);
__webpack_require__(239);
__webpack_require__(249);
__webpack_require__(248);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(243);
__webpack_require__(235);
__webpack_require__(246);
__webpack_require__(250);
__webpack_require__(251);
__webpack_require__(203);
__webpack_require__(205);
__webpack_require__(204);
__webpack_require__(253);
__webpack_require__(252);
__webpack_require__(223);
__webpack_require__(233);
__webpack_require__(234);
__webpack_require__(224);
__webpack_require__(225);
__webpack_require__(226);
__webpack_require__(227);
__webpack_require__(228);
__webpack_require__(229);
__webpack_require__(230);
__webpack_require__(231);
__webpack_require__(232);
__webpack_require__(206);
__webpack_require__(207);
__webpack_require__(208);
__webpack_require__(209);
__webpack_require__(210);
__webpack_require__(211);
__webpack_require__(212);
__webpack_require__(213);
__webpack_require__(214);
__webpack_require__(215);
__webpack_require__(216);
__webpack_require__(217);
__webpack_require__(218);
__webpack_require__(219);
__webpack_require__(220);
__webpack_require__(221);
__webpack_require__(222);
__webpack_require__(284);
__webpack_require__(289);
__webpack_require__(296);
__webpack_require__(287);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(285);
__webpack_require__(290);
__webpack_require__(292);
__webpack_require__(275);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(283);
__webpack_require__(286);
__webpack_require__(288);
__webpack_require__(291);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(198);
__webpack_require__(200);
__webpack_require__(199);
__webpack_require__(202);
__webpack_require__(201);
__webpack_require__(187);
__webpack_require__(185);
__webpack_require__(191);
__webpack_require__(188);
__webpack_require__(194);
__webpack_require__(196);
__webpack_require__(184);
__webpack_require__(190);
__webpack_require__(181);
__webpack_require__(195);
__webpack_require__(179);
__webpack_require__(193);
__webpack_require__(192);
__webpack_require__(186);
__webpack_require__(189);
__webpack_require__(178);
__webpack_require__(180);
__webpack_require__(183);
__webpack_require__(182);
__webpack_require__(197);
__webpack_require__(108);
__webpack_require__(269);
__webpack_require__(274);
__webpack_require__(143);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(254);
__webpack_require__(142);
__webpack_require__(144);
__webpack_require__(145);
__webpack_require__(309);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(304);
__webpack_require__(307);
__webpack_require__(308);
__webpack_require__(302);
__webpack_require__(305);
__webpack_require__(303);
__webpack_require__(306);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(255);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(262);
__webpack_require__(260);
__webpack_require__(261);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(268);
__webpack_require__(267);
__webpack_require__(312);
__webpack_require__(310);
__webpack_require__(311);
__webpack_require__(353);
__webpack_require__(356);
__webpack_require__(355);
__webpack_require__(357);
__webpack_require__(358);
__webpack_require__(354);
__webpack_require__(359);
__webpack_require__(360);
__webpack_require__(334);
__webpack_require__(337);
__webpack_require__(333);
__webpack_require__(331);
__webpack_require__(332);
__webpack_require__(335);
__webpack_require__(336);
__webpack_require__(318);
__webpack_require__(352);
__webpack_require__(317);
__webpack_require__(351);
__webpack_require__(363);
__webpack_require__(365);
__webpack_require__(316);
__webpack_require__(350);
__webpack_require__(362);
__webpack_require__(364);
__webpack_require__(315);
__webpack_require__(361);
__webpack_require__(314);
__webpack_require__(319);
__webpack_require__(320);
__webpack_require__(321);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(325);
__webpack_require__(324);
__webpack_require__(326);
__webpack_require__(327);
__webpack_require__(328);
__webpack_require__(330);
__webpack_require__(329);
__webpack_require__(339);
__webpack_require__(340);
__webpack_require__(341);
__webpack_require__(342);
__webpack_require__(344);
__webpack_require__(343);
__webpack_require__(346);
__webpack_require__(345);
__webpack_require__(347);
__webpack_require__(348);
__webpack_require__(349);
__webpack_require__(313);
__webpack_require__(338);
__webpack_require__(368);
__webpack_require__(367);
__webpack_require__(366);
module.exports = __webpack_require__(27);


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var knn_image_classifier_1 = __webpack_require__(371);
exports.KNNImageClassifier = knn_image_classifier_1.KNNImageClassifier;
//# sourceMappingURL=index.js.map

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var deeplearn_1 = __webpack_require__(38);
var deeplearn_squeezenet_1 = __webpack_require__(373);
var KNNImageClassifier = (function () {
    function KNNImageClassifier(numClasses, k, math) {
        this.numClasses = numClasses;
        this.k = k;
        this.math = math;
        this.classLogitsMatrices = [];
        this.classExampleCount = [];
        this.varsLoaded = false;
        this.squashLogitsDenominator = deeplearn_1.Scalar.new(300);
        this.mathCPU = new deeplearn_1.NDArrayMathCPU();
        for (var i = 0; i < this.numClasses; i++) {
            this.classLogitsMatrices.push(null);
            this.classExampleCount.push(0);
        }
        this.squeezeNet = new deeplearn_squeezenet_1.SqueezeNet(this.math);
    }
    KNNImageClassifier.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.squeezeNet.load()];
                    case 1:
                        _a.sent();
                        this.varsLoaded = true;
                        return [2];
                }
            });
        });
    };
    KNNImageClassifier.prototype.clearClass = function (classIndex) {
        if (classIndex >= this.numClasses) {
            console.log('Cannot clear invalid class ${classIndex}');
            return;
        }
        this.classLogitsMatrices[classIndex] = null;
        this.classExampleCount[classIndex] = 0;
        this.clearTrainLogitsMatrix();
    };
    KNNImageClassifier.prototype.addImage = function (image, classIndex) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.varsLoaded) {
                            console.warn('Cannot add images until vars have been loaded.');
                            return [2];
                        }
                        if (classIndex >= this.numClasses) {
                            console.warn('Cannot add to invalid class ${classIndex}');
                        }
                        this.clearTrainLogitsMatrix();
                        return [4, this.math.scope(function (keep, track) { return __awaiter(_this, void 0, void 0, function () {
                                var predResults, imageLogits, logitsSize, newTrainLogitsMatrix;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4, this.squeezeNet.predict(image)];
                                        case 1:
                                            predResults = _a.sent();
                                            imageLogits = this.normalizeVector(predResults.logits);
                                            logitsSize = imageLogits.shape[0];
                                            if (this.classLogitsMatrices[classIndex] == null) {
                                                this.classLogitsMatrices[classIndex] = imageLogits.as2D(1, logitsSize);
                                            }
                                            else {
                                                newTrainLogitsMatrix = this.math.concat2D(this.classLogitsMatrices[classIndex].as2D(this.classExampleCount[classIndex], logitsSize), imageLogits.as2D(1, logitsSize), 0);
                                                this.classLogitsMatrices[classIndex].dispose();
                                                this.classLogitsMatrices[classIndex] = newTrainLogitsMatrix;
                                            }
                                            keep(this.classLogitsMatrices[classIndex]);
                                            this.classExampleCount[classIndex]++;
                                            return [2];
                                    }
                                });
                            }); })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    KNNImageClassifier.prototype.predict = function (image) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var imageClass, confidences, topKIndices, indices, indicesForClasses, topKCountsForClasses, i, num, i, classForEntry, topConfidence, kVal, i, probability;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        imageClass = -1;
                        confidences = new Array(this.numClasses);
                        if (!this.varsLoaded) {
                            console.warn('Cannot predict until vars have been loaded.');
                            return [2, { classIndex: imageClass, confidences: confidences }];
                        }
                        return [4, this.math.scope(function (keep) { return __awaiter(_this, void 0, void 0, function () {
                                var predResults, imageLogits, logitsSize, newTrainLogitsMatrix, i, numExamples, knn, kVal, topK;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4, this.squeezeNet.predict(image)];
                                        case 1:
                                            predResults = _a.sent();
                                            imageLogits = this.normalizeVector(predResults.logits);
                                            logitsSize = imageLogits.shape[0];
                                            if (this.trainLogitsMatrix == null) {
                                                newTrainLogitsMatrix = null;
                                                for (i = 0; i < this.numClasses; i++) {
                                                    newTrainLogitsMatrix = this.concatWithNulls(newTrainLogitsMatrix, this.classLogitsMatrices[i]);
                                                }
                                                this.trainLogitsMatrix = newTrainLogitsMatrix;
                                            }
                                            if (this.trainLogitsMatrix == null) {
                                                console.warn('Cannot predict without providing training images.');
                                                return [2, null];
                                            }
                                            keep(this.trainLogitsMatrix);
                                            numExamples = this.getNumExamples();
                                            knn = this.math
                                                .matMul(this.trainLogitsMatrix.as2D(numExamples, logitsSize), imageLogits.as2D(logitsSize, 1))
                                                .as1D();
                                            return [4, knn.data()];
                                        case 2:
                                            _a.sent();
                                            kVal = Math.min(this.k, numExamples);
                                            topK = this.mathCPU.topK(knn, kVal);
                                            return [2, topK.indices];
                                    }
                                });
                            }); })];
                    case 1:
                        topKIndices = _a.sent();
                        if (topKIndices == null) {
                            return [2, { classIndex: imageClass, confidences: confidences }];
                        }
                        indices = topKIndices.dataSync();
                        indicesForClasses = [];
                        topKCountsForClasses = [];
                        for (i = 0; i < this.numClasses; i++) {
                            topKCountsForClasses.push(0);
                            num = this.classExampleCount[i];
                            if (i > 0) {
                                num += indicesForClasses[i - 1];
                            }
                            indicesForClasses.push(num);
                        }
                        for (i = 0; i < indices.length; i++) {
                            for (classForEntry = 0; classForEntry < indicesForClasses.length; classForEntry++) {
                                if (indices[i] < indicesForClasses[classForEntry]) {
                                    topKCountsForClasses[classForEntry]++;
                                    break;
                                }
                            }
                        }
                        topConfidence = 0;
                        kVal = Math.min(this.k, this.getNumExamples());
                        for (i = 0; i < this.numClasses; i++) {
                            probability = topKCountsForClasses[i] / kVal;
                            if (probability > topConfidence) {
                                topConfidence = probability;
                                imageClass = i;
                            }
                            confidences[i] = probability;
                        }
                        return [2, { classIndex: imageClass, confidences: confidences }];
                }
            });
        });
    };
    KNNImageClassifier.prototype.getClassExampleCount = function () {
        return this.classExampleCount;
    };
    KNNImageClassifier.prototype.clearTrainLogitsMatrix = function () {
        if (this.trainLogitsMatrix != null) {
            this.trainLogitsMatrix.dispose();
            this.trainLogitsMatrix = null;
        }
    };
    KNNImageClassifier.prototype.concatWithNulls = function (ndarray1, ndarray2) {
        if (ndarray1 == null && ndarray2 == null) {
            return null;
        }
        if (ndarray1 == null) {
            return this.math.clone(ndarray2);
        }
        else if (ndarray2 === null) {
            return this.math.clone(ndarray1);
        }
        return this.math.concat2D(ndarray1, ndarray2, 0);
    };
    KNNImageClassifier.prototype.normalizeVector = function (vec) {
        var squashedVec = this.math.divide(vec, this.squashLogitsDenominator);
        var squared = this.math.multiplyStrict(squashedVec, squashedVec);
        var sum = this.math.sum(squared);
        var sqrtSum = this.math.sqrt(sum);
        return this.math.divide(squashedVec, sqrtSum);
    };
    KNNImageClassifier.prototype.getNumExamples = function () {
        var total = 0;
        for (var i = 0; i < this.classExampleCount.length; i++) {
            total += this.classExampleCount[i];
        }
        return total;
    };
    KNNImageClassifier.prototype.dispose = function () {
        this.squeezeNet.dispose();
        this.clearTrainLogitsMatrix();
        this.classLogitsMatrices.forEach(function (classLogitsMatrix) { return classLogitsMatrix.dispose(); });
        this.squashLogitsDenominator.dispose();
    };
    return KNNImageClassifier;
}());
exports.KNNImageClassifier = KNNImageClassifier;
//# sourceMappingURL=knn_image_classifier.js.map

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IMAGENET_CLASSES = {
    0: 'tench, Tinca tinca',
    1: 'goldfish, Carassius auratus',
    2: 'great white shark, white shark, man-eater, man-eating shark, ' +
        'Carcharodon carcharias',
    3: 'tiger shark, Galeocerdo cuvieri',
    4: 'hammerhead, hammerhead shark',
    5: 'electric ray, crampfish, numbfish, torpedo',
    6: 'stingray',
    7: 'cock',
    8: 'hen',
    9: 'ostrich, Struthio camelus',
    10: 'brambling, Fringilla montifringilla',
    11: 'goldfinch, Carduelis carduelis',
    12: 'house finch, linnet, Carpodacus mexicanus',
    13: 'junco, snowbird',
    14: 'indigo bunting, indigo finch, indigo bird, Passerina cyanea',
    15: 'robin, American robin, Turdus migratorius',
    16: 'bulbul',
    17: 'jay',
    18: 'magpie',
    19: 'chickadee',
    20: 'water ouzel, dipper',
    21: 'kite',
    22: 'bald eagle, American eagle, Haliaeetus leucocephalus',
    23: 'vulture',
    24: 'great grey owl, great gray owl, Strix nebulosa',
    25: 'European fire salamander, Salamandra salamandra',
    26: 'common newt, Triturus vulgaris',
    27: 'eft',
    28: 'spotted salamander, Ambystoma maculatum',
    29: 'axolotl, mud puppy, Ambystoma mexicanum',
    30: 'bullfrog, Rana catesbeiana',
    31: 'tree frog, tree-frog',
    32: 'tailed frog, bell toad, ribbed toad, tailed toad, Ascaphus trui',
    33: 'loggerhead, loggerhead turtle, Caretta caretta',
    34: 'leatherback turtle, leatherback, leathery turtle, Dermochelys coriacea',
    35: 'mud turtle',
    36: 'terrapin',
    37: 'box turtle, box tortoise',
    38: 'banded gecko',
    39: 'common iguana, iguana, Iguana iguana',
    40: 'American chameleon, anole, Anolis carolinensis',
    41: 'whiptail, whiptail lizard',
    42: 'agama',
    43: 'frilled lizard, Chlamydosaurus kingi',
    44: 'alligator lizard',
    45: 'Gila monster, Heloderma suspectum',
    46: 'green lizard, Lacerta viridis',
    47: 'African chameleon, Chamaeleo chamaeleon',
    48: 'Komodo dragon, Komodo lizard, dragon lizard, giant lizard, ' +
        'Varanus komodoensis',
    49: 'African crocodile, Nile crocodile, Crocodylus niloticus',
    50: 'American alligator, Alligator mississipiensis',
    51: 'triceratops',
    52: 'thunder snake, worm snake, Carphophis amoenus',
    53: 'ringneck snake, ring-necked snake, ring snake',
    54: 'hognose snake, puff adder, sand viper',
    55: 'green snake, grass snake',
    56: 'king snake, kingsnake',
    57: 'garter snake, grass snake',
    58: 'water snake',
    59: 'vine snake',
    60: 'night snake, Hypsiglena torquata',
    61: 'boa constrictor, Constrictor constrictor',
    62: 'rock python, rock snake, Python sebae',
    63: 'Indian cobra, Naja naja',
    64: 'green mamba',
    65: 'sea snake',
    66: 'horned viper, cerastes, sand viper, horned asp, Cerastes cornutus',
    67: 'diamondback, diamondback rattlesnake, Crotalus adamanteus',
    68: 'sidewinder, horned rattlesnake, Crotalus cerastes',
    69: 'trilobite',
    70: 'harvestman, daddy longlegs, Phalangium opilio',
    71: 'scorpion',
    72: 'black and gold garden spider, Argiope aurantia',
    73: 'barn spider, Araneus cavaticus',
    74: 'garden spider, Aranea diademata',
    75: 'black widow, Latrodectus mactans',
    76: 'tarantula',
    77: 'wolf spider, hunting spider',
    78: 'tick',
    79: 'centipede',
    80: 'black grouse',
    81: 'ptarmigan',
    82: 'ruffed grouse, partridge, Bonasa umbellus',
    83: 'prairie chicken, prairie grouse, prairie fowl',
    84: 'peacock',
    85: 'quail',
    86: 'partridge',
    87: 'African grey, African gray, Psittacus erithacus',
    88: 'macaw',
    89: 'sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita',
    90: 'lorikeet',
    91: 'coucal',
    92: 'bee eater',
    93: 'hornbill',
    94: 'hummingbird',
    95: 'jacamar',
    96: 'toucan',
    97: 'drake',
    98: 'red-breasted merganser, Mergus serrator',
    99: 'goose',
    100: 'black swan, Cygnus atratus',
    101: 'tusker',
    102: 'echidna, spiny anteater, anteater',
    103: 'platypus, duckbill, duckbilled platypus, duck-billed platypus, ' +
        'Ornithorhynchus anatinus',
    104: 'wallaby, brush kangaroo',
    105: 'koala, koala bear, kangaroo bear, native bear, Phascolarctos cinereus',
    106: 'wombat',
    107: 'jelly fish',
    108: 'sea anemone, anemone',
    109: 'brain coral',
    110: 'flatworm, platyhelminth',
    111: 'nematode, nematode worm, roundworm',
    112: 'conch',
    113: 'snail',
    114: 'slug',
    115: 'sea slug, nudibranch',
    116: 'chiton, coat-of-mail shell, sea cradle, polyplacophore',
    117: 'chambered nautilus, pearly nautilus, nautilus',
    118: 'Dungeness crab, Cancer magister',
    119: 'rock crab, Cancer irroratus',
    120: 'fiddler crab',
    121: 'king crab, Alaska crab, Alaskan king crab, Alaska king crab, ' +
        'Paralithodes camtschatica',
    122: 'American lobster, Northern lobster, Maine lobster, Homarus americanus',
    123: 'spiny lobster, langouste, rock lobster, crawfish, crayfish, sea ' +
        'crawfish',
    124: 'crayfish, crawfish, crawdad, crawdaddy',
    125: 'hermit crab',
    126: 'isopod',
    127: 'white stork, Ciconia ciconia',
    128: 'black stork, Ciconia nigra',
    129: 'spoonbill',
    130: 'flamingo',
    131: 'little blue heron, Egretta caerulea',
    132: 'American egret, great white heron, Egretta albus',
    133: 'bittern',
    134: 'crane',
    135: 'limpkin, Aramus pictus',
    136: 'European gallinule, Porphyrio porphyrio',
    137: 'American coot, marsh hen, mud hen, water hen, Fulica americana',
    138: 'bustard',
    139: 'ruddy turnstone, Arenaria interpres',
    140: 'red-backed sandpiper, dunlin, Erolia alpina',
    141: 'redshank, Tringa totanus',
    142: 'dowitcher',
    143: 'oystercatcher, oyster catcher',
    144: 'pelican',
    145: 'king penguin, Aptenodytes patagonica',
    146: 'albatross, mollymawk',
    147: 'grey whale, gray whale, devilfish, Eschrichtius gibbosus, ' +
        'Eschrichtius robustus',
    148: 'killer whale, killer, orca, grampus, sea wolf, Orcinus orca',
    149: 'dugong, Dugong dugon',
    150: 'sea lion',
    151: 'Chihuahua',
    152: 'Japanese spaniel',
    153: 'Maltese dog, Maltese terrier, Maltese',
    154: 'Pekinese, Pekingese, Peke',
    155: 'Shih-Tzu',
    156: 'Blenheim spaniel',
    157: 'papillon',
    158: 'toy terrier',
    159: 'Rhodesian ridgeback',
    160: 'Afghan hound, Afghan',
    161: 'basset, basset hound',
    162: 'beagle',
    163: 'bloodhound, sleuthhound',
    164: 'bluetick',
    165: 'black-and-tan coonhound',
    166: 'Walker hound, Walker foxhound',
    167: 'English foxhound',
    168: 'redbone',
    169: 'borzoi, Russian wolfhound',
    170: 'Irish wolfhound',
    171: 'Italian greyhound',
    172: 'whippet',
    173: 'Ibizan hound, Ibizan Podenco',
    174: 'Norwegian elkhound, elkhound',
    175: 'otterhound, otter hound',
    176: 'Saluki, gazelle hound',
    177: 'Scottish deerhound, deerhound',
    178: 'Weimaraner',
    179: 'Staffordshire bullterrier, Staffordshire bull terrier',
    180: 'American Staffordshire terrier, Staffordshire terrier, American pit ' +
        'bull terrier, pit bull terrier',
    181: 'Bedlington terrier',
    182: 'Border terrier',
    183: 'Kerry blue terrier',
    184: 'Irish terrier',
    185: 'Norfolk terrier',
    186: 'Norwich terrier',
    187: 'Yorkshire terrier',
    188: 'wire-haired fox terrier',
    189: 'Lakeland terrier',
    190: 'Sealyham terrier, Sealyham',
    191: 'Airedale, Airedale terrier',
    192: 'cairn, cairn terrier',
    193: 'Australian terrier',
    194: 'Dandie Dinmont, Dandie Dinmont terrier',
    195: 'Boston bull, Boston terrier',
    196: 'miniature schnauzer',
    197: 'giant schnauzer',
    198: 'standard schnauzer',
    199: 'Scotch terrier, Scottish terrier, Scottie',
    200: 'Tibetan terrier, chrysanthemum dog',
    201: 'silky terrier, Sydney silky',
    202: 'soft-coated wheaten terrier',
    203: 'West Highland white terrier',
    204: 'Lhasa, Lhasa apso',
    205: 'flat-coated retriever',
    206: 'curly-coated retriever',
    207: 'golden retriever',
    208: 'Labrador retriever',
    209: 'Chesapeake Bay retriever',
    210: 'German short-haired pointer',
    211: 'vizsla, Hungarian pointer',
    212: 'English setter',
    213: 'Irish setter, red setter',
    214: 'Gordon setter',
    215: 'Brittany spaniel',
    216: 'clumber, clumber spaniel',
    217: 'English springer, English springer spaniel',
    218: 'Welsh springer spaniel',
    219: 'cocker spaniel, English cocker spaniel, cocker',
    220: 'Sussex spaniel',
    221: 'Irish water spaniel',
    222: 'kuvasz',
    223: 'schipperke',
    224: 'groenendael',
    225: 'malinois',
    226: 'briard',
    227: 'kelpie',
    228: 'komondor',
    229: 'Old English sheepdog, bobtail',
    230: 'Shetland sheepdog, Shetland sheep dog, Shetland',
    231: 'collie',
    232: 'Border collie',
    233: 'Bouvier des Flandres, Bouviers des Flandres',
    234: 'Rottweiler',
    235: 'German shepherd, German shepherd dog, German police dog, alsatian',
    236: 'Doberman, Doberman pinscher',
    237: 'miniature pinscher',
    238: 'Greater Swiss Mountain dog',
    239: 'Bernese mountain dog',
    240: 'Appenzeller',
    241: 'EntleBucher',
    242: 'boxer',
    243: 'bull mastiff',
    244: 'Tibetan mastiff',
    245: 'French bulldog',
    246: 'Great Dane',
    247: 'Saint Bernard, St Bernard',
    248: 'Eskimo dog, husky',
    249: 'malamute, malemute, Alaskan malamute',
    250: 'Siberian husky',
    251: 'dalmatian, coach dog, carriage dog',
    252: 'affenpinscher, monkey pinscher, monkey dog',
    253: 'basenji',
    254: 'pug, pug-dog',
    255: 'Leonberg',
    256: 'Newfoundland, Newfoundland dog',
    257: 'Great Pyrenees',
    258: 'Samoyed, Samoyede',
    259: 'Pomeranian',
    260: 'chow, chow chow',
    261: 'keeshond',
    262: 'Brabancon griffon',
    263: 'Pembroke, Pembroke Welsh corgi',
    264: 'Cardigan, Cardigan Welsh corgi',
    265: 'toy poodle',
    266: 'miniature poodle',
    267: 'standard poodle',
    268: 'Mexican hairless',
    269: 'timber wolf, grey wolf, gray wolf, Canis lupus',
    270: 'white wolf, Arctic wolf, Canis lupus tundrarum',
    271: 'red wolf, maned wolf, Canis rufus, Canis niger',
    272: 'coyote, prairie wolf, brush wolf, Canis latrans',
    273: 'dingo, warrigal, warragal, Canis dingo',
    274: 'dhole, Cuon alpinus',
    275: 'African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus',
    276: 'hyena, hyaena',
    277: 'red fox, Vulpes vulpes',
    278: 'kit fox, Vulpes macrotis',
    279: 'Arctic fox, white fox, Alopex lagopus',
    280: 'grey fox, gray fox, Urocyon cinereoargenteus',
    281: 'tabby, tabby cat',
    282: 'tiger cat',
    283: 'Persian cat',
    284: 'Siamese cat, Siamese',
    285: 'Egyptian cat',
    286: 'cougar, puma, catamount, mountain lion, painter, panther, ' +
        'Felis concolor',
    287: 'lynx, catamount',
    288: 'leopard, Panthera pardus',
    289: 'snow leopard, ounce, Panthera uncia',
    290: 'jaguar, panther, Panthera onca, Felis onca',
    291: 'lion, king of beasts, Panthera leo',
    292: 'tiger, Panthera tigris',
    293: 'cheetah, chetah, Acinonyx jubatus',
    294: 'brown bear, bruin, Ursus arctos',
    295: 'American black bear, black bear, Ursus americanus, Euarctos ' +
        'americanus',
    296: 'ice bear, polar bear, Ursus Maritimus, Thalarctos maritimus',
    297: 'sloth bear, Melursus ursinus, Ursus ursinus',
    298: 'mongoose',
    299: 'meerkat, mierkat',
    300: 'tiger beetle',
    301: 'ladybug, ladybeetle, lady beetle, ladybird, ladybird beetle',
    302: 'ground beetle, carabid beetle',
    303: 'long-horned beetle, longicorn, longicorn beetle',
    304: 'leaf beetle, chrysomelid',
    305: 'dung beetle',
    306: 'rhinoceros beetle',
    307: 'weevil',
    308: 'fly',
    309: 'bee',
    310: 'ant, emmet, pismire',
    311: 'grasshopper, hopper',
    312: 'cricket',
    313: 'walking stick, walkingstick, stick insect',
    314: 'cockroach, roach',
    315: 'mantis, mantid',
    316: 'cicada, cicala',
    317: 'leafhopper',
    318: 'lacewing, lacewing fly',
    319: 'dragonfly, darning needle, devil\'s darning needle, sewing needle, ' +
        'snake feeder, snake doctor, mosquito hawk, skeeter hawk',
    320: 'damselfly',
    321: 'admiral',
    322: 'ringlet, ringlet butterfly',
    323: 'monarch, monarch butterfly, milkweed butterfly, Danaus plexippus',
    324: 'cabbage butterfly',
    325: 'sulphur butterfly, sulfur butterfly',
    326: 'lycaenid, lycaenid butterfly',
    327: 'starfish, sea star',
    328: 'sea urchin',
    329: 'sea cucumber, holothurian',
    330: 'wood rabbit, cottontail, cottontail rabbit',
    331: 'hare',
    332: 'Angora, Angora rabbit',
    333: 'hamster',
    334: 'porcupine, hedgehog',
    335: 'fox squirrel, eastern fox squirrel, Sciurus niger',
    336: 'marmot',
    337: 'beaver',
    338: 'guinea pig, Cavia cobaya',
    339: 'sorrel',
    340: 'zebra',
    341: 'hog, pig, grunter, squealer, Sus scrofa',
    342: 'wild boar, boar, Sus scrofa',
    343: 'warthog',
    344: 'hippopotamus, hippo, river horse, Hippopotamus amphibius',
    345: 'ox',
    346: 'water buffalo, water ox, Asiatic buffalo, Bubalus bubalis',
    347: 'bison',
    348: 'ram, tup',
    349: 'bighorn, bighorn sheep, cimarron, Rocky Mountain bighorn, Rocky ' +
        'Mountain sheep, Ovis canadensis',
    350: 'ibex, Capra ibex',
    351: 'hartebeest',
    352: 'impala, Aepyceros melampus',
    353: 'gazelle',
    354: 'Arabian camel, dromedary, Camelus dromedarius',
    355: 'llama',
    356: 'weasel',
    357: 'mink',
    358: 'polecat, fitch, foulmart, foumart, Mustela putorius',
    359: 'black-footed ferret, ferret, Mustela nigripes',
    360: 'otter',
    361: 'skunk, polecat, wood pussy',
    362: 'badger',
    363: 'armadillo',
    364: 'three-toed sloth, ai, Bradypus tridactylus',
    365: 'orangutan, orang, orangutang, Pongo pygmaeus',
    366: 'gorilla, Gorilla gorilla',
    367: 'chimpanzee, chimp, Pan troglodytes',
    368: 'gibbon, Hylobates lar',
    369: 'siamang, Hylobates syndactylus, Symphalangus syndactylus',
    370: 'guenon, guenon monkey',
    371: 'patas, hussar monkey, Erythrocebus patas',
    372: 'baboon',
    373: 'macaque',
    374: 'langur',
    375: 'colobus, colobus monkey',
    376: 'proboscis monkey, Nasalis larvatus',
    377: 'marmoset',
    378: 'capuchin, ringtail, Cebus capucinus',
    379: 'howler monkey, howler',
    380: 'titi, titi monkey',
    381: 'spider monkey, Ateles geoffroyi',
    382: 'squirrel monkey, Saimiri sciureus',
    383: 'Madagascar cat, ring-tailed lemur, Lemur catta',
    384: 'indri, indris, Indri indri, Indri brevicaudatus',
    385: 'Indian elephant, Elephas maximus',
    386: 'African elephant, Loxodonta africana',
    387: 'lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens',
    388: 'giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca',
    389: 'barracouta, snoek',
    390: 'eel',
    391: 'coho, cohoe, coho salmon, blue jack, silver salmon, Oncorhynchus ' +
        'kisutch',
    392: 'rock beauty, Holocanthus tricolor',
    393: 'anemone fish',
    394: 'sturgeon',
    395: 'gar, garfish, garpike, billfish, Lepisosteus osseus',
    396: 'lionfish',
    397: 'puffer, pufferfish, blowfish, globefish',
    398: 'abacus',
    399: 'abaya',
    400: 'academic gown, academic robe, judge\'s robe',
    401: 'accordion, piano accordion, squeeze box',
    402: 'acoustic guitar',
    403: 'aircraft carrier, carrier, flattop, attack aircraft carrier',
    404: 'airliner',
    405: 'airship, dirigible',
    406: 'altar',
    407: 'ambulance',
    408: 'amphibian, amphibious vehicle',
    409: 'analog clock',
    410: 'apiary, bee house',
    411: 'apron',
    412: 'ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, ' +
        'dustbin, trash barrel, trash bin',
    413: 'assault rifle, assault gun',
    414: 'backpack, back pack, knapsack, packsack, rucksack, haversack',
    415: 'bakery, bakeshop, bakehouse',
    416: 'balance beam, beam',
    417: 'balloon',
    418: 'ballpoint, ballpoint pen, ballpen, Biro',
    419: 'Band Aid',
    420: 'banjo',
    421: 'bannister, banister, balustrade, balusters, handrail',
    422: 'barbell',
    423: 'barber chair',
    424: 'barbershop',
    425: 'barn',
    426: 'barometer',
    427: 'barrel, cask',
    428: 'barrow, garden cart, lawn cart, wheelbarrow',
    429: 'baseball',
    430: 'basketball',
    431: 'bassinet',
    432: 'bassoon',
    433: 'bathing cap, swimming cap',
    434: 'bath towel',
    435: 'bathtub, bathing tub, bath, tub',
    436: 'beach wagon, station wagon, wagon, estate car, beach waggon, station ' +
        'waggon, waggon',
    437: 'beacon, lighthouse, beacon light, pharos',
    438: 'beaker',
    439: 'bearskin, busby, shako',
    440: 'beer bottle',
    441: 'beer glass',
    442: 'bell cote, bell cot',
    443: 'bib',
    444: 'bicycle-built-for-two, tandem bicycle, tandem',
    445: 'bikini, two-piece',
    446: 'binder, ring-binder',
    447: 'binoculars, field glasses, opera glasses',
    448: 'birdhouse',
    449: 'boathouse',
    450: 'bobsled, bobsleigh, bob',
    451: 'bolo tie, bolo, bola tie, bola',
    452: 'bonnet, poke bonnet',
    453: 'bookcase',
    454: 'bookshop, bookstore, bookstall',
    455: 'bottlecap',
    456: 'bow',
    457: 'bow tie, bow-tie, bowtie',
    458: 'brass, memorial tablet, plaque',
    459: 'brassiere, bra, bandeau',
    460: 'breakwater, groin, groyne, mole, bulwark, seawall, jetty',
    461: 'breastplate, aegis, egis',
    462: 'broom',
    463: 'bucket, pail',
    464: 'buckle',
    465: 'bulletproof vest',
    466: 'bullet train, bullet',
    467: 'butcher shop, meat market',
    468: 'cab, hack, taxi, taxicab',
    469: 'caldron, cauldron',
    470: 'candle, taper, wax light',
    471: 'cannon',
    472: 'canoe',
    473: 'can opener, tin opener',
    474: 'cardigan',
    475: 'car mirror',
    476: 'carousel, carrousel, merry-go-round, roundabout, whirligig',
    477: 'carpenter\'s kit, tool kit',
    478: 'carton',
    479: 'car wheel',
    480: 'cash machine, cash dispenser, automated teller machine, automatic ' +
        'teller machine, automated teller, automatic teller, ATM',
    481: 'cassette',
    482: 'cassette player',
    483: 'castle',
    484: 'catamaran',
    485: 'CD player',
    486: 'cello, violoncello',
    487: 'cellular telephone, cellular phone, cellphone, cell, mobile phone',
    488: 'chain',
    489: 'chainlink fence',
    490: 'chain mail, ring mail, mail, chain armor, chain armour, ring armor, ' +
        'ring armour',
    491: 'chain saw, chainsaw',
    492: 'chest',
    493: 'chiffonier, commode',
    494: 'chime, bell, gong',
    495: 'china cabinet, china closet',
    496: 'Christmas stocking',
    497: 'church, church building',
    498: 'cinema, movie theater, movie theatre, movie house, picture palace',
    499: 'cleaver, meat cleaver, chopper',
    500: 'cliff dwelling',
    501: 'cloak',
    502: 'clog, geta, patten, sabot',
    503: 'cocktail shaker',
    504: 'coffee mug',
    505: 'coffeepot',
    506: 'coil, spiral, volute, whorl, helix',
    507: 'combination lock',
    508: 'computer keyboard, keypad',
    509: 'confectionery, confectionary, candy store',
    510: 'container ship, containership, container vessel',
    511: 'convertible',
    512: 'corkscrew, bottle screw',
    513: 'cornet, horn, trumpet, trump',
    514: 'cowboy boot',
    515: 'cowboy hat, ten-gallon hat',
    516: 'cradle',
    517: 'crane',
    518: 'crash helmet',
    519: 'crate',
    520: 'crib, cot',
    521: 'Crock Pot',
    522: 'croquet ball',
    523: 'crutch',
    524: 'cuirass',
    525: 'dam, dike, dyke',
    526: 'desk',
    527: 'desktop computer',
    528: 'dial telephone, dial phone',
    529: 'diaper, nappy, napkin',
    530: 'digital clock',
    531: 'digital watch',
    532: 'dining table, board',
    533: 'dishrag, dishcloth',
    534: 'dishwasher, dish washer, dishwashing machine',
    535: 'disk brake, disc brake',
    536: 'dock, dockage, docking facility',
    537: 'dogsled, dog sled, dog sleigh',
    538: 'dome',
    539: 'doormat, welcome mat',
    540: 'drilling platform, offshore rig',
    541: 'drum, membranophone, tympan',
    542: 'drumstick',
    543: 'dumbbell',
    544: 'Dutch oven',
    545: 'electric fan, blower',
    546: 'electric guitar',
    547: 'electric locomotive',
    548: 'entertainment center',
    549: 'envelope',
    550: 'espresso maker',
    551: 'face powder',
    552: 'feather boa, boa',
    553: 'file, file cabinet, filing cabinet',
    554: 'fireboat',
    555: 'fire engine, fire truck',
    556: 'fire screen, fireguard',
    557: 'flagpole, flagstaff',
    558: 'flute, transverse flute',
    559: 'folding chair',
    560: 'football helmet',
    561: 'forklift',
    562: 'fountain',
    563: 'fountain pen',
    564: 'four-poster',
    565: 'freight car',
    566: 'French horn, horn',
    567: 'frying pan, frypan, skillet',
    568: 'fur coat',
    569: 'garbage truck, dustcart',
    570: 'gasmask, respirator, gas helmet',
    571: 'gas pump, gasoline pump, petrol pump, island dispenser',
    572: 'goblet',
    573: 'go-kart',
    574: 'golf ball',
    575: 'golfcart, golf cart',
    576: 'gondola',
    577: 'gong, tam-tam',
    578: 'gown',
    579: 'grand piano, grand',
    580: 'greenhouse, nursery, glasshouse',
    581: 'grille, radiator grille',
    582: 'grocery store, grocery, food market, market',
    583: 'guillotine',
    584: 'hair slide',
    585: 'hair spray',
    586: 'half track',
    587: 'hammer',
    588: 'hamper',
    589: 'hand blower, blow dryer, blow drier, hair dryer, hair drier',
    590: 'hand-held computer, hand-held microcomputer',
    591: 'handkerchief, hankie, hanky, hankey',
    592: 'hard disc, hard disk, fixed disk',
    593: 'harmonica, mouth organ, harp, mouth harp',
    594: 'harp',
    595: 'harvester, reaper',
    596: 'hatchet',
    597: 'holster',
    598: 'home theater, home theatre',
    599: 'honeycomb',
    600: 'hook, claw',
    601: 'hoopskirt, crinoline',
    602: 'horizontal bar, high bar',
    603: 'horse cart, horse-cart',
    604: 'hourglass',
    605: 'iPod',
    606: 'iron, smoothing iron',
    607: 'jack-o\'-lantern',
    608: 'jean, blue jean, denim',
    609: 'jeep, landrover',
    610: 'jersey, T-shirt, tee shirt',
    611: 'jigsaw puzzle',
    612: 'jinrikisha, ricksha, rickshaw',
    613: 'joystick',
    614: 'kimono',
    615: 'knee pad',
    616: 'knot',
    617: 'lab coat, laboratory coat',
    618: 'ladle',
    619: 'lampshade, lamp shade',
    620: 'laptop, laptop computer',
    621: 'lawn mower, mower',
    622: 'lens cap, lens cover',
    623: 'letter opener, paper knife, paperknife',
    624: 'library',
    625: 'lifeboat',
    626: 'lighter, light, igniter, ignitor',
    627: 'limousine, limo',
    628: 'liner, ocean liner',
    629: 'lipstick, lip rouge',
    630: 'Loafer',
    631: 'lotion',
    632: 'loudspeaker, speaker, speaker unit, loudspeaker system, speaker ' +
        'system',
    633: 'loupe, jeweler\'s loupe',
    634: 'lumbermill, sawmill',
    635: 'magnetic compass',
    636: 'mailbag, postbag',
    637: 'mailbox, letter box',
    638: 'maillot',
    639: 'maillot, tank suit',
    640: 'manhole cover',
    641: 'maraca',
    642: 'marimba, xylophone',
    643: 'mask',
    644: 'matchstick',
    645: 'maypole',
    646: 'maze, labyrinth',
    647: 'measuring cup',
    648: 'medicine chest, medicine cabinet',
    649: 'megalith, megalithic structure',
    650: 'microphone, mike',
    651: 'microwave, microwave oven',
    652: 'military uniform',
    653: 'milk can',
    654: 'minibus',
    655: 'miniskirt, mini',
    656: 'minivan',
    657: 'missile',
    658: 'mitten',
    659: 'mixing bowl',
    660: 'mobile home, manufactured home',
    661: 'Model T',
    662: 'modem',
    663: 'monastery',
    664: 'monitor',
    665: 'moped',
    666: 'mortar',
    667: 'mortarboard',
    668: 'mosque',
    669: 'mosquito net',
    670: 'motor scooter, scooter',
    671: 'mountain bike, all-terrain bike, off-roader',
    672: 'mountain tent',
    673: 'mouse, computer mouse',
    674: 'mousetrap',
    675: 'moving van',
    676: 'muzzle',
    677: 'nail',
    678: 'neck brace',
    679: 'necklace',
    680: 'nipple',
    681: 'notebook, notebook computer',
    682: 'obelisk',
    683: 'oboe, hautboy, hautbois',
    684: 'ocarina, sweet potato',
    685: 'odometer, hodometer, mileometer, milometer',
    686: 'oil filter',
    687: 'organ, pipe organ',
    688: 'oscilloscope, scope, cathode-ray oscilloscope, CRO',
    689: 'overskirt',
    690: 'oxcart',
    691: 'oxygen mask',
    692: 'packet',
    693: 'paddle, boat paddle',
    694: 'paddlewheel, paddle wheel',
    695: 'padlock',
    696: 'paintbrush',
    697: 'pajama, pyjama, pj\'s, jammies',
    698: 'palace',
    699: 'panpipe, pandean pipe, syrinx',
    700: 'paper towel',
    701: 'parachute, chute',
    702: 'parallel bars, bars',
    703: 'park bench',
    704: 'parking meter',
    705: 'passenger car, coach, carriage',
    706: 'patio, terrace',
    707: 'pay-phone, pay-station',
    708: 'pedestal, plinth, footstall',
    709: 'pencil box, pencil case',
    710: 'pencil sharpener',
    711: 'perfume, essence',
    712: 'Petri dish',
    713: 'photocopier',
    714: 'pick, plectrum, plectron',
    715: 'pickelhaube',
    716: 'picket fence, paling',
    717: 'pickup, pickup truck',
    718: 'pier',
    719: 'piggy bank, penny bank',
    720: 'pill bottle',
    721: 'pillow',
    722: 'ping-pong ball',
    723: 'pinwheel',
    724: 'pirate, pirate ship',
    725: 'pitcher, ewer',
    726: 'plane, carpenter\'s plane, woodworking plane',
    727: 'planetarium',
    728: 'plastic bag',
    729: 'plate rack',
    730: 'plow, plough',
    731: 'plunger, plumber\'s helper',
    732: 'Polaroid camera, Polaroid Land camera',
    733: 'pole',
    734: 'police van, police wagon, paddy wagon, patrol wagon, wagon, black ' +
        'Maria',
    735: 'poncho',
    736: 'pool table, billiard table, snooker table',
    737: 'pop bottle, soda bottle',
    738: 'pot, flowerpot',
    739: 'potter\'s wheel',
    740: 'power drill',
    741: 'prayer rug, prayer mat',
    742: 'printer',
    743: 'prison, prison house',
    744: 'projectile, missile',
    745: 'projector',
    746: 'puck, hockey puck',
    747: 'punching bag, punch bag, punching ball, punchball',
    748: 'purse',
    749: 'quill, quill pen',
    750: 'quilt, comforter, comfort, puff',
    751: 'racer, race car, racing car',
    752: 'racket, racquet',
    753: 'radiator',
    754: 'radio, wireless',
    755: 'radio telescope, radio reflector',
    756: 'rain barrel',
    757: 'recreational vehicle, RV, R.V.',
    758: 'reel',
    759: 'reflex camera',
    760: 'refrigerator, icebox',
    761: 'remote control, remote',
    762: 'restaurant, eating house, eating place, eatery',
    763: 'revolver, six-gun, six-shooter',
    764: 'rifle',
    765: 'rocking chair, rocker',
    766: 'rotisserie',
    767: 'rubber eraser, rubber, pencil eraser',
    768: 'rugby ball',
    769: 'rule, ruler',
    770: 'running shoe',
    771: 'safe',
    772: 'safety pin',
    773: 'saltshaker, salt shaker',
    774: 'sandal',
    775: 'sarong',
    776: 'sax, saxophone',
    777: 'scabbard',
    778: 'scale, weighing machine',
    779: 'school bus',
    780: 'schooner',
    781: 'scoreboard',
    782: 'screen, CRT screen',
    783: 'screw',
    784: 'screwdriver',
    785: 'seat belt, seatbelt',
    786: 'sewing machine',
    787: 'shield, buckler',
    788: 'shoe shop, shoe-shop, shoe store',
    789: 'shoji',
    790: 'shopping basket',
    791: 'shopping cart',
    792: 'shovel',
    793: 'shower cap',
    794: 'shower curtain',
    795: 'ski',
    796: 'ski mask',
    797: 'sleeping bag',
    798: 'slide rule, slipstick',
    799: 'sliding door',
    800: 'slot, one-armed bandit',
    801: 'snorkel',
    802: 'snowmobile',
    803: 'snowplow, snowplough',
    804: 'soap dispenser',
    805: 'soccer ball',
    806: 'sock',
    807: 'solar dish, solar collector, solar furnace',
    808: 'sombrero',
    809: 'soup bowl',
    810: 'space bar',
    811: 'space heater',
    812: 'space shuttle',
    813: 'spatula',
    814: 'speedboat',
    815: 'spider web, spider\'s web',
    816: 'spindle',
    817: 'sports car, sport car',
    818: 'spotlight, spot',
    819: 'stage',
    820: 'steam locomotive',
    821: 'steel arch bridge',
    822: 'steel drum',
    823: 'stethoscope',
    824: 'stole',
    825: 'stone wall',
    826: 'stopwatch, stop watch',
    827: 'stove',
    828: 'strainer',
    829: 'streetcar, tram, tramcar, trolley, trolley car',
    830: 'stretcher',
    831: 'studio couch, day bed',
    832: 'stupa, tope',
    833: 'submarine, pigboat, sub, U-boat',
    834: 'suit, suit of clothes',
    835: 'sundial',
    836: 'sunglass',
    837: 'sunglasses, dark glasses, shades',
    838: 'sunscreen, sunblock, sun blocker',
    839: 'suspension bridge',
    840: 'swab, swob, mop',
    841: 'sweatshirt',
    842: 'swimming trunks, bathing trunks',
    843: 'swing',
    844: 'switch, electric switch, electrical switch',
    845: 'syringe',
    846: 'table lamp',
    847: 'tank, army tank, armored combat vehicle, armoured combat vehicle',
    848: 'tape player',
    849: 'teapot',
    850: 'teddy, teddy bear',
    851: 'television, television system',
    852: 'tennis ball',
    853: 'thatch, thatched roof',
    854: 'theater curtain, theatre curtain',
    855: 'thimble',
    856: 'thresher, thrasher, threshing machine',
    857: 'throne',
    858: 'tile roof',
    859: 'toaster',
    860: 'tobacco shop, tobacconist shop, tobacconist',
    861: 'toilet seat',
    862: 'torch',
    863: 'totem pole',
    864: 'tow truck, tow car, wrecker',
    865: 'toyshop',
    866: 'tractor',
    867: 'trailer truck, tractor trailer, trucking rig, rig, articulated ' +
        'lorry, semi',
    868: 'tray',
    869: 'trench coat',
    870: 'tricycle, trike, velocipede',
    871: 'trimaran',
    872: 'tripod',
    873: 'triumphal arch',
    874: 'trolleybus, trolley coach, trackless trolley',
    875: 'trombone',
    876: 'tub, vat',
    877: 'turnstile',
    878: 'typewriter keyboard',
    879: 'umbrella',
    880: 'unicycle, monocycle',
    881: 'upright, upright piano',
    882: 'vacuum, vacuum cleaner',
    883: 'vase',
    884: 'vault',
    885: 'velvet',
    886: 'vending machine',
    887: 'vestment',
    888: 'viaduct',
    889: 'violin, fiddle',
    890: 'volleyball',
    891: 'waffle iron',
    892: 'wall clock',
    893: 'wallet, billfold, notecase, pocketbook',
    894: 'wardrobe, closet, press',
    895: 'warplane, military plane',
    896: 'washbasin, handbasin, washbowl, lavabo, wash-hand basin',
    897: 'washer, automatic washer, washing machine',
    898: 'water bottle',
    899: 'water jug',
    900: 'water tower',
    901: 'whiskey jug',
    902: 'whistle',
    903: 'wig',
    904: 'window screen',
    905: 'window shade',
    906: 'Windsor tie',
    907: 'wine bottle',
    908: 'wing',
    909: 'wok',
    910: 'wooden spoon',
    911: 'wool, woolen, woollen',
    912: 'worm fence, snake fence, snake-rail fence, Virginia fence',
    913: 'wreck',
    914: 'yawl',
    915: 'yurt',
    916: 'web site, website, internet site, site',
    917: 'comic book',
    918: 'crossword puzzle, crossword',
    919: 'street sign',
    920: 'traffic light, traffic signal, stoplight',
    921: 'book jacket, dust cover, dust jacket, dust wrapper',
    922: 'menu',
    923: 'plate',
    924: 'guacamole',
    925: 'consomme',
    926: 'hot pot, hotpot',
    927: 'trifle',
    928: 'ice cream, icecream',
    929: 'ice lolly, lolly, lollipop, popsicle',
    930: 'French loaf',
    931: 'bagel, beigel',
    932: 'pretzel',
    933: 'cheeseburger',
    934: 'hotdog, hot dog, red hot',
    935: 'mashed potato',
    936: 'head cabbage',
    937: 'broccoli',
    938: 'cauliflower',
    939: 'zucchini, courgette',
    940: 'spaghetti squash',
    941: 'acorn squash',
    942: 'butternut squash',
    943: 'cucumber, cuke',
    944: 'artichoke, globe artichoke',
    945: 'bell pepper',
    946: 'cardoon',
    947: 'mushroom',
    948: 'Granny Smith',
    949: 'strawberry',
    950: 'orange',
    951: 'lemon',
    952: 'fig',
    953: 'pineapple, ananas',
    954: 'banana',
    955: 'jackfruit, jak, jack',
    956: 'custard apple',
    957: 'pomegranate',
    958: 'hay',
    959: 'carbonara',
    960: 'chocolate sauce, chocolate syrup',
    961: 'dough',
    962: 'meat loaf, meatloaf',
    963: 'pizza, pizza pie',
    964: 'potpie',
    965: 'burrito',
    966: 'red wine',
    967: 'espresso',
    968: 'cup',
    969: 'eggnog',
    970: 'alp',
    971: 'bubble',
    972: 'cliff, drop, drop-off',
    973: 'coral reef',
    974: 'geyser',
    975: 'lakeside, lakeshore',
    976: 'promontory, headland, head, foreland',
    977: 'sandbar, sand bar',
    978: 'seashore, coast, seacoast, sea-coast',
    979: 'valley, vale',
    980: 'volcano',
    981: 'ballplayer, baseball player',
    982: 'groom, bridegroom',
    983: 'scuba diver',
    984: 'rapeseed',
    985: 'daisy',
    986: 'yellow lady\'s slipper, yellow lady-slipper, Cypripedium calceolus, ' +
        'Cypripedium parviflorum',
    987: 'corn',
    988: 'acorn',
    989: 'hip, rose hip, rosehip',
    990: 'buckeye, horse chestnut, conker',
    991: 'coral fungus',
    992: 'agaric',
    993: 'gyromitra',
    994: 'stinkhorn, carrion fungus',
    995: 'earthstar',
    996: 'hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola ' +
        'frondosa',
    997: 'bolete',
    998: 'ear, spike, capitulum',
    999: 'toilet tissue, toilet paper, bathroom tissue'
};
//# sourceMappingURL=imagenet_classes.js.map

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var squeezenet_1 = __webpack_require__(374);
exports.SqueezeNet = squeezenet_1.SqueezeNet;
//# sourceMappingURL=index.js.map

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var deeplearn_1 = __webpack_require__(38);
var imagenet_classes_1 = __webpack_require__(372);
var GOOGLE_CLOUD_STORAGE_DIR = 'https://storage.googleapis.com/learnjs-data/checkpoint_zoo/';
var SqueezeNet = (function () {
    function SqueezeNet(math) {
        this.math = math;
        this.preprocessOffset = deeplearn_1.Array1D.new([103.939, 116.779, 123.68]);
        deeplearn_1.initializeGPU(this.math.getGPGPUContext(), this.math.getTextureManager());
    }
    SqueezeNet.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var checkpointLoader, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        checkpointLoader = new deeplearn_1.CheckpointLoader(GOOGLE_CLOUD_STORAGE_DIR + 'squeezenet1_1/');
                        _a = this;
                        return [4, checkpointLoader.getAllVariables()];
                    case 1:
                        _a.variables = _b.sent();
                        return [2];
                }
            });
        });
    };
    SqueezeNet.prototype.predict = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var namedActivations, avgpool10, layerNames;
            return __generator(this, function (_a) {
                namedActivations = {};
                avgpool10 = this.math.scope(function (keep) {
                    var preprocessedInput = _this.math.subtract(input, _this.preprocessOffset);
                    var conv1 = _this.math.conv2d(preprocessedInput, _this.variables['conv1_W:0'], _this.variables['conv1_b:0'], 2, 0);
                    var conv1relu = keep(_this.math.relu(conv1));
                    namedActivations['conv_1'] = conv1relu;
                    var pool1 = keep(_this.math.maxPool(conv1relu, 3, 2, 0));
                    namedActivations['maxpool_1'] = pool1;
                    var fire2 = keep(_this.fireModule(pool1, 2));
                    namedActivations['fire2'] = fire2;
                    var fire3 = keep(_this.fireModule(fire2, 3));
                    namedActivations['fire3'] = fire3;
                    var pool2 = keep(_this.math.maxPool(fire3, 3, 2, 'valid'));
                    namedActivations['maxpool_2'] = pool2;
                    var fire4 = keep(_this.fireModule(pool2, 4));
                    namedActivations['fire4'] = fire4;
                    var fire5 = keep(_this.fireModule(fire4, 5));
                    namedActivations['fire5'] = fire5;
                    var pool3 = keep(_this.math.maxPool(fire5, 3, 2, 0));
                    namedActivations['maxpool_3'] = pool3;
                    var fire6 = keep(_this.fireModule(pool3, 6));
                    namedActivations['fire6'] = fire6;
                    var fire7 = keep(_this.fireModule(fire6, 7));
                    namedActivations['fire7'] = fire7;
                    var fire8 = keep(_this.fireModule(fire7, 8));
                    namedActivations['fire8'] = fire8;
                    var fire9 = keep(_this.fireModule(fire8, 9));
                    namedActivations['fire9'] = fire9;
                    var conv10 = keep(_this.math.conv2d(fire9, _this.variables['conv10_W:0'], _this.variables['conv10_b:0'], 1, 0));
                    namedActivations['conv10'] = conv10;
                    return _this.math.avgPool(conv10, conv10.shape[0], 1, 0).as1D();
                });
                layerNames = Object.keys(namedActivations);
                layerNames.forEach(function (layerName) { return _this.math.track(namedActivations[layerName]); });
                return [2, { namedActivations: namedActivations, logits: avgpool10 }];
            });
        });
    };
    SqueezeNet.prototype.fireModule = function (input, fireId) {
        var y1 = this.math.conv2d(input, this.variables["fire" + fireId + "/squeeze1x1_W:0"], this.variables["fire" + fireId + "/squeeze1x1_b:0"], 1, 0);
        var y2 = this.math.relu(y1);
        var left1 = this.math.conv2d(y2, this.variables["fire" + fireId + "/expand1x1_W:0"], this.variables["fire" + fireId + "/expand1x1_b:0"], 1, 0);
        var left2 = this.math.relu(left1);
        var right1 = this.math.conv2d(y2, this.variables["fire" + fireId + "/expand3x3_W:0"], this.variables["fire" + fireId + "/expand3x3_b:0"], 1, 1);
        var right2 = this.math.relu(right1);
        return this.math.concat3D(left2, right2, 2);
    };
    SqueezeNet.prototype.getTopKClasses = function (logits, topK) {
        return __awaiter(this, void 0, void 0, function () {
            var predictions, topk, topkIndices, topkValues, topClassesToProbability, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        predictions = this.math.softmax(logits);
                        topk = new deeplearn_1.NDArrayMathCPU().topK(predictions, topK);
                        return [4, topk.indices.data()];
                    case 1:
                        topkIndices = _a.sent();
                        return [4, topk.values.data()];
                    case 2:
                        topkValues = _a.sent();
                        topClassesToProbability = {};
                        for (i = 0; i < topkIndices.length; i++) {
                            topClassesToProbability[imagenet_classes_1.IMAGENET_CLASSES[topkIndices[i]]] = topkValues[i];
                        }
                        return [2, topClassesToProbability];
                }
            });
        });
    };
    SqueezeNet.prototype.dispose = function () {
        this.preprocessOffset.dispose();
        for (var varName in this.variables) {
            this.variables[varName].dispose();
        }
    };
    return SqueezeNet;
}());
exports.SqueezeNet = SqueezeNet;
//# sourceMappingURL=squeezenet.js.map

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var MANIFEST_FILE = 'manifest.json';
var CheckpointLoader = (function () {
    function CheckpointLoader(urlPath) {
        this.urlPath = urlPath;
        if (this.urlPath.charAt(this.urlPath.length - 1) !== '/') {
            this.urlPath += '/';
        }
    }
    CheckpointLoader.prototype.loadManifest = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', _this.urlPath + MANIFEST_FILE);
            xhr.onload = function () {
                _this.checkpointManifest = JSON.parse(xhr.responseText);
                resolve();
            };
            xhr.onerror = function (error) {
                throw new Error(MANIFEST_FILE + " not found at " + _this.urlPath + ". " + error);
            };
            xhr.send();
        });
    };
    CheckpointLoader.prototype.getCheckpointManifest = function () {
        var _this = this;
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    resolve(_this.checkpointManifest);
                });
            });
        }
        return new Promise(function (resolve, reject) {
            resolve(_this.checkpointManifest);
        });
    };
    CheckpointLoader.prototype.getAllVariables = function () {
        var _this = this;
        if (this.variables != null) {
            return new Promise(function (resolve, reject) {
                resolve(_this.variables);
            });
        }
        return new Promise(function (resolve, reject) {
            _this.getCheckpointManifest().then(function (checkpointDefinition) {
                var variableNames = Object.keys(_this.checkpointManifest);
                var variablePromises = [];
                for (var i = 0; i < variableNames.length; i++) {
                    variablePromises.push(_this.getVariable(variableNames[i]));
                }
                Promise.all(variablePromises).then(function (variables) {
                    _this.variables = {};
                    for (var i = 0; i < variables.length; i++) {
                        _this.variables[variableNames[i]] = variables[i];
                    }
                    resolve(_this.variables);
                });
            });
        });
    };
    CheckpointLoader.prototype.getVariable = function (varName) {
        var _this = this;
        if (!(varName in this.checkpointManifest)) {
            throw new Error('Cannot load non-existant variable ' + varName);
        }
        var variableRequestPromiseMethod = function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = 'arraybuffer';
            var fname = _this.checkpointManifest[varName].filename;
            xhr.open('GET', _this.urlPath + fname);
            xhr.onload = function () {
                var values = new Float32Array(xhr.response);
                var ndarray = ndarray_1.NDArray.make(_this.checkpointManifest[varName].shape, { values: values });
                resolve(ndarray);
            };
            xhr.onerror = function (error) {
                throw new Error("Could not fetch variable " + varName + ": " + error);
            };
            xhr.send();
        };
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    new Promise(variableRequestPromiseMethod).then(resolve);
                });
            });
        }
        return new Promise(variableRequestPromiseMethod);
    };
    return CheckpointLoader;
}());
exports.CheckpointLoader = CheckpointLoader;
//# sourceMappingURL=checkpoint_loader.js.map

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var InMemoryShuffledInputProviderBuilder = (function () {
    function InMemoryShuffledInputProviderBuilder(inputs) {
        this.inputs = inputs;
        this.idx = 0;
        this.inputCounter = 0;
        this.epoch = 0;
        this.shuffledIndices = util.createShuffledIndices(inputs[0].length);
        this.numInputs = inputs.length;
        var numExamples = this.inputs[0].length;
        for (var i = 0; i < this.numInputs; i++) {
            util.assert(this.inputs[i].length === numExamples, 'Number of examples must match across different inputs.');
        }
        for (var i = 0; i < this.numInputs; i++) {
            var inputShape = this.inputs[i][0].shape;
            for (var j = 0; j < this.inputs[i].length; j++) {
                util.assertShapesMatch(inputShape, this.inputs[i][j].shape);
            }
        }
    }
    InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex = function () {
        var returnIdx = this.idx;
        this.inputCounter++;
        if (this.inputCounter >= this.numInputs) {
            this.idx++;
            this.inputCounter = 0;
            if (this.idx >= this.inputs[0].length) {
                this.idx = 0;
                this.epoch++;
            }
        }
        return returnIdx;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getNextInput = function (inputId) {
        var currentExampleIndex = this.getCurrentExampleIndex();
        return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];
    };
    InMemoryShuffledInputProviderBuilder.prototype.getEpoch = function () {
        return this.epoch;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getInputProviders = function () {
        var inputProviders = [];
        for (var i = 0; i < this.numInputs; i++) {
            inputProviders.push(this.getInputProvider(i));
        }
        return inputProviders;
    };
    return InMemoryShuffledInputProviderBuilder;
}());
exports.InMemoryShuffledInputProviderBuilder = InMemoryShuffledInputProviderBuilder;
var InCPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InCPUMemoryShuffledInputProviderBuilder, _super);
    function InCPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return ndarray_1.NDArray.like(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InCPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InCPUMemoryShuffledInputProviderBuilder = InCPUMemoryShuffledInputProviderBuilder;
var InGPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InGPUMemoryShuffledInputProviderBuilder, _super);
    function InGPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return math.clone(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InGPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InGPUMemoryShuffledInputProviderBuilder = InGPUMemoryShuffledInputProviderBuilder;
//# sourceMappingURL=input_provider.js.map

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(a) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(a.substr(0, 4));
}
exports.isMobile = isMobile;
//# sourceMappingURL=device_util.js.map

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = __webpack_require__(64);
var graph_util = __webpack_require__(21);
var add_1 = __webpack_require__(379);
var argmax_1 = __webpack_require__(380);
var argmaxequals_1 = __webpack_require__(381);
var concat3d_1 = __webpack_require__(382);
var convolution_1 = __webpack_require__(383);
var divide_1 = __webpack_require__(384);
var element_wise_activation_1 = __webpack_require__(385);
var element_wise_cost_1 = __webpack_require__(386);
var exp_1 = __webpack_require__(387);
var linear_combination_1 = __webpack_require__(388);
var log_1 = __webpack_require__(389);
var matmul_1 = __webpack_require__(390);
var max_pool_1 = __webpack_require__(391);
var multiply_1 = __webpack_require__(392);
var reduce_sum_1 = __webpack_require__(393);
var reshape_1 = __webpack_require__(394);
var softmax_1 = __webpack_require__(395);
var subtract_1 = __webpack_require__(396);
function emitFromGraphNodes(nodes) {
    var ops = [];
    nodes.forEach(function (node) { return Array.prototype.push.apply(ops, emitOpFromNode(node)); });
    return ops;
}
exports.emitFromGraphNodes = emitFromGraphNodes;
function emitOpFromNode(node) {
    if (node instanceof graph_1.ReshapeNode) {
        return [new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X], node.output)];
    }
    else if (node instanceof graph_1.MatMulNode) {
        var x1 = node.inputs[graph_1.MatMulNode.X1];
        var x2 = node.inputs[graph_1.MatMulNode.X2];
        return [new matmul_1.MatMul(x1, x2, node.output)];
    }
    else if (node instanceof graph_1.Convolution2DNode) {
        var w = node.inputs[graph_1.Convolution2DNode.W];
        var x = node.inputs[graph_1.Convolution2DNode.X];
        var b = node.inputs[graph_1.Convolution2DNode.B];
        return [new convolution_1.Convolution2D(w, x, b, node.output, node.fieldSize, node.outputDepth, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.MaxPoolNode) {
        var x = node.inputs[graph_1.MaxPoolNode.X];
        return [new max_pool_1.MaxPool(x, node.output, node.fieldSize, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.ExpNode) {
        return [new exp_1.Exp(node.inputs[graph_1.ExpNode.X], node.output)];
    }
    else if (node instanceof graph_1.LogNode) {
        return [new log_1.Log(node.inputs[graph_1.LogNode.X], node.output)];
    }
    else if (node instanceof graph_1.ReLUNode) {
        return [new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X], node.output)];
    }
    else if (node instanceof graph_1.LeakyReLUNode) {
        return [new element_wise_activation_1.LeakyReLU(node.inputs[graph_1.LeakyReLUNode.X], node.output, node.alpha)];
    }
    else if (node instanceof graph_1.TanHNode) {
        return [new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X], node.output)];
    }
    else if (node instanceof graph_1.SigmoidNode) {
        return [new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X], node.output)];
    }
    else if (node instanceof graph_1.SoftmaxCrossEntropyCostNode) {
        var x = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];
        var target = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];
        return [new softmax_1.SoftmaxCrossEntropyCost(x, target, node.output)];
    }
    else if (node instanceof graph_1.SoftmaxNode) {
        return [new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X], node.output)];
    }
    else if (node instanceof graph_1.MeanSquaredCostNode) {
        var label = node.inputs[graph_1.MeanSquaredCostNode.LABEL];
        var prediction = node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];
        return [new element_wise_cost_1.MeanSquaredCost(label, prediction, node.output)];
    }
    else if (node instanceof graph_1.ArgMaxEqualsNode) {
        return [new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1], node.inputs[graph_1.ArgMaxEqualsNode.X2], node.output)];
    }
    else if (node instanceof graph_1.ArgMaxNode) {
        return [new argmax_1.ArgMax(node.x, node.output)];
    }
    else if (node instanceof graph_1.FusedLinearCombinationNode) {
        return [new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1], node.inputs[graph_1.FusedLinearCombinationNode.T2], node.inputs[graph_1.FusedLinearCombinationNode.C1], node.inputs[graph_1.FusedLinearCombinationNode.C2], node.output)];
    }
    else if (node instanceof graph_1.Concat3DNode) {
        return [new concat3d_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1], node.inputs[graph_1.Concat3DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.SquareNode) {
        return [new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X], node.output)];
    }
    else if (node instanceof graph_1.AddNode) {
        return [new add_1.Add(node.inputs[graph_1.AddNode.T1], node.inputs[graph_1.AddNode.T2], node.output)];
    }
    else if (node instanceof graph_1.SubtractNode) {
        return [new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1], node.inputs[graph_1.SubtractNode.T2], node.output)];
    }
    else if (node instanceof graph_1.MultiplyNode) {
        return [new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1], node.inputs[graph_1.MultiplyNode.T2], node.output)];
    }
    else if (node instanceof graph_1.DivideNode) {
        return [new divide_1.Divide(node.inputs[graph_1.DivideNode.T1], node.inputs[graph_1.DivideNode.T2], node.output)];
    }
    else if (node instanceof graph_1.ReduceSumNode) {
        return [new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X], node.output)];
    }
    else if (graph_util.isInputNode(node)) {
        return [];
    }
    else {
        throw Error("Unsupported node type: " + node.constructor.name);
    }
}
//# sourceMappingURL=operation_emitter.js.map

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var graph_util = __webpack_require__(21);
var op_1 = __webpack_require__(12);
var Add = (function (_super) {
    __extends(Add, _super);
    function Add(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Add.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(x1.shape)) {
                result = math.scalarPlusArray(x1, x2);
            }
            else if (util.isScalarShape(x2.shape)) {
                result = math.scalarPlusArray(x2, x1);
            }
            else {
                result = math.add(x1, x2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Add.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.x1Tensor, math.divide(sum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.clone(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.x2Tensor, math.divide(sum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, math.clone(dy));
                }
            }
        });
    };
    Add.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Add;
}(op_1.Operation));
exports.Add = Add;
//# sourceMappingURL=add.js.map

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = __webpack_require__(12);
var ArgMax = (function (_super) {
    __extends(ArgMax, _super);
    function ArgMax(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMax(x)));
        });
    };
    ArgMax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMax backprop unimplemented');
    };
    return ArgMax;
}(op_1.Operation));
exports.ArgMax = ArgMax;
//# sourceMappingURL=argmax.js.map

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = __webpack_require__(12);
var ArgMaxEquals = (function (_super) {
    __extends(ArgMaxEquals, _super);
    function ArgMaxEquals(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMaxEquals.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMaxEquals(x1, x2)));
        });
    };
    ArgMaxEquals.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMaxEquals backprop unimplemented');
    };
    return ArgMaxEquals;
}(op_1.Operation));
exports.ArgMaxEquals = ArgMaxEquals;
//# sourceMappingURL=argmaxequals.js.map

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = __webpack_require__(65);
var op_1 = __webpack_require__(12);
var Concat3D = (function (_super) {
    __extends(Concat3D, _super);
    function Concat3D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat3D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var concatResult = math.concat3D(x1, x2, _this.axis);
            inferenceArrays.set(_this.yTensor, keep(concatResult));
        });
    };
    Concat3D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('Concat3D backprop not implemented.');
    };
    return Concat3D;
}(op_1.Operation));
exports.Concat3D = Concat3D;
//# sourceMappingURL=concat3d.js.map

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = __webpack_require__(51);
var util = __webpack_require__(4);
var op_1 = __webpack_require__(12);
var Convolution2D = (function (_super) {
    __extends(Convolution2D, _super);
    function Convolution2D(wTensor, xTensor, bTensor, yTensor, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.wTensor = wTensor;
        _this.xTensor = xTensor;
        _this.bTensor = bTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.assertWeightsShape(wTensor.shape);
        _this.zeroPad = zeroPad != null ?
            zeroPad :
            conv_util.computeDefaultPad(_this.xTensor.shape, _this.fieldSize, _this.stride);
        util.assert(util.isInt(_this.zeroPad), "The zero padding (" + _this.zeroPad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    Convolution2D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var biases = inferenceArrays.get(this.bTensor);
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.conv2d(x, weights, biases, _this.stride, _this.zeroPad)));
        });
    };
    Convolution2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            var _a = math.conv2dBackProp(x, dy, weights, _this.stride, _this.zeroPad), dw = _a.dw, db = _a.db, dx = _a.dx;
            gradientArrays.add(_this.wTensor, dw);
            gradientArrays.add(_this.bTensor, db);
            gradientArrays.add(_this.xTensor, dx);
        });
    };
    Convolution2D.prototype.assertWeightsShape = function (weightsShape) {
        util.assert(weightsShape[0] === this.fieldSize &&
            weightsShape[1] === this.fieldSize &&
            weightsShape[2] === this.xTensor.shape[2] &&
            weightsShape[3] === this.outputDepth, "weights must be of shape [" + this.fieldSize + "," + this.fieldSize + "," +
            (this.xTensor.shape[2] + "," + this.outputDepth + "] but they are of") +
            ("shape [" + weightsShape + "]"));
    };
    return Convolution2D;
}(op_1.Operation));
exports.Convolution2D = Convolution2D;
//# sourceMappingURL=convolution.js.map

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = __webpack_require__(4);
var graph_util = __webpack_require__(21);
var op_1 = __webpack_require__(12);
var Divide = (function (_super) {
    __extends(Divide, _super);
    function Divide(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Divide.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarDividedByArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayDividedByScalar(t1, t2);
            }
            else {
                result = math.divide(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Divide.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        var x1IsScalar = util.isScalarShape(x1.shape);
        var x2IsScalar = util.isScalarShape(x2.shape);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (x1IsScalar) {
                    var div = math.divide(dy, x2);
                    gradientArrays.add(_this.x1Tensor, math.sum(div));
                    div.dispose();
                }
                else if (x2IsScalar) {
                    gradientArrays.add(_this.x1Tensor, math.arrayDividedByScalar(dy, x2));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.divide(dy, x2));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var x2Squared = math.elementWiseMul(x2, x2);
                var x1OverX2Squared = void 0;
                if (x2IsScalar) {
                    x1OverX2Squared = math.arrayDividedByScalar(x1, x2Squared);
                }
                else if (x1IsScalar) {
                    x1OverX2Squared = math.scalarDividedByArray(x1, x2Squared);
                }
                else {
                    x1OverX2Squared = math.divide(x1, x2Squared);
                }
                var dx2 = math.neg(x1OverX2Squared);
                var dyTimesDerivative = math.elementWiseMul(dy, dx2);
                if (x2IsScalar) {
                    gradientArrays.add(_this.x2Tensor, math.sum(dyTimesDerivative));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, dyTimesDerivative);
                }
            }
        });
    };
    return Divide;
}(op_1.Operation));
exports.Divide = Divide;
//# sourceMappingURL=divide.js.map

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var activation_functions_1 = __webpack_require__(404);
var op_1 = __webpack_require__(12);
var ElementWiseActivation = (function (_super) {
    __extends(ElementWiseActivation, _super);
    function ElementWiseActivation(xTensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.func = func;
        return _this;
    }
    ElementWiseActivation.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(_this.func.output(math, x)));
        });
    };
    ElementWiseActivation.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            var dydx = _this.func.der(math, x, y);
            gradientArrays.add(_this.xTensor, math.elementWiseMul(dy, dydx));
            dydx.dispose();
        });
    };
    ElementWiseActivation.prototype.dispose = function () {
        this.func.dispose();
    };
    return ElementWiseActivation;
}(op_1.Operation));
exports.ElementWiseActivation = ElementWiseActivation;
var ReLU = (function (_super) {
    __extends(ReLU, _super);
    function ReLU(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.ReLUFunc()) || this;
    }
    return ReLU;
}(ElementWiseActivation));
exports.ReLU = ReLU;
var LeakyReLU = (function (_super) {
    __extends(LeakyReLU, _super);
    function LeakyReLU(xTensor, yTensor, alpha) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.LeakyReluFunc(alpha)) || this;
    }
    return LeakyReLU;
}(ElementWiseActivation));
exports.LeakyReLU = LeakyReLU;
var TanH = (function (_super) {
    __extends(TanH, _super);
    function TanH(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.TanHFunc()) || this;
    }
    return TanH;
}(ElementWiseActivation));
exports.TanH = TanH;
var Sigmoid = (function (_super) {
    __extends(Sigmoid, _super);
    function Sigmoid(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SigmoidFunc()) || this;
    }
    return Sigmoid;
}(ElementWiseActivation));
exports.Sigmoid = Sigmoid;
var Square = (function (_super) {
    __extends(Square, _super);
    function Square(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SquareFunc()) || this;
    }
    return Square;
}(ElementWiseActivation));
exports.Square = Square;
//# sourceMappingURL=element_wise_activation.js.map

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var cost_functions_1 = __webpack_require__(405);
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var graph_util = __webpack_require__(21);
var op_1 = __webpack_require__(12);
var ElementWiseCost = (function (_super) {
    __extends(ElementWiseCost, _super);
    function ElementWiseCost(x1Tensor, x2Tensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        _this.func = func;
        _this.oneOverNScalar = ndarray_1.Scalar.new(1 / util.sizeFromShape(x1Tensor.shape));
        return _this;
    }
    ElementWiseCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var elementWiseCost = _this.func.cost(math, x1, x2);
            var sum = math.sum(elementWiseCost);
            var result = math.scalarTimesArray(_this.oneOverNScalar, sum);
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    ElementWiseCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.add(_this.x1Tensor, _this.func.der(math, x1, x2));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.add(_this.x2Tensor, _this.func.der(math, x2, x1));
            }
        });
    };
    ElementWiseCost.prototype.dispose = function () {
        this.func.dispose();
        this.oneOverNScalar.dispose();
    };
    return ElementWiseCost;
}(op_1.Operation));
exports.ElementWiseCost = ElementWiseCost;
var MeanSquaredCost = (function (_super) {
    __extends(MeanSquaredCost, _super);
    function MeanSquaredCost(x1Tensor, x2Tensor, yTensor) {
        return _super.call(this, x1Tensor, x2Tensor, yTensor, new cost_functions_1.SquareCostFunc()) || this;
    }
    return MeanSquaredCost;
}(ElementWiseCost));
exports.MeanSquaredCost = MeanSquaredCost;
//# sourceMappingURL=element_wise_cost.js.map

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = __webpack_require__(21);
var op_1 = __webpack_require__(12);
var Exp = (function (_super) {
    __extends(Exp, _super);
    function Exp(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Exp.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.exp(x)));
        });
    };
    Exp.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.add(_this.xTensor, math.elementWiseMul(y, dy));
            }
        });
    };
    return Exp;
}(op_1.Operation));
exports.Exp = Exp;
//# sourceMappingURL=exp.js.map

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = __webpack_require__(21);
var op_1 = __webpack_require__(12);
var LinearCombination = (function (_super) {
    __extends(LinearCombination, _super);
    function LinearCombination(x1Tensor, x2Tensor, c1Tensor, c2Tensor, outTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.c1Tensor = c1Tensor;
        _this.c2Tensor = c2Tensor;
        _this.outTensor = outTensor;
        return _this;
    }
    LinearCombination.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor).asScalar();
        var c2 = inferenceArrays.get(this.c2Tensor).asScalar();
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.scaledArrayAdd(c1, x1, c2, x2)));
        });
    };
    LinearCombination.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor);
        var c2 = inferenceArrays.get(this.c2Tensor);
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(c1, dy));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(c2, dy));
            }
            if (graph_util.shouldBackProp(_this.c1Tensor)) {
                var dotProduct1 = math.elementWiseMul(x1, dy);
                gradientArrays.add(_this.c1Tensor, math.sum(dotProduct1));
            }
            if (graph_util.shouldBackProp(_this.c2Tensor)) {
                var dotProduct2 = math.elementWiseMul(x2, dy);
                gradientArrays.add(_this.c2Tensor, math.sum(dotProduct2));
            }
        });
    };
    return LinearCombination;
}(op_1.Operation));
exports.LinearCombination = LinearCombination;
//# sourceMappingURL=linear_combination.js.map

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = __webpack_require__(21);
var op_1 = __webpack_require__(12);
var Log = (function (_super) {
    __extends(Log, _super);
    function Log(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Log.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.log(x)));
        });
    };
    Log.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.add(_this.xTensor, math.divide(dy, x));
            }
        });
    };
    return Log;
}(op_1.Operation));
exports.Log = Log;
//# sourceMappingURL=log.js.map

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var math_1 = __webpack_require__(57);
var graph_util = __webpack_require__(21);
var op_1 = __webpack_require__(12);
var MatMul = (function (_super) {
    __extends(MatMul, _super);
    function MatMul(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    MatMul.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            if (x1.shape.length === 2 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.matMul(x1, x2)));
            }
            else if (x1.shape.length === 2 && x2.shape.length === 1) {
                inferenceArrays.set(_this.yTensor, keep(math.matrixTimesVector(x1, x2)));
            }
            else if (x1.shape.length === 1 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.vectorTimesMatrix(x1, x2)));
            }
        });
    };
    MatMul.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        if (x1.shape.length === 1) {
            x1 = x1.reshape([1, x1.size]);
            dy = dy.reshape([1, dy.size]);
        }
        if (x2.shape.length === 1) {
            x2 = x2.reshape([x2.size, 1]);
            dy = dy.reshape([dy.size, 1]);
        }
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                var dx1 = math.matMul(dy, x2, math_1.MatrixOrientation.REGULAR, math_1.MatrixOrientation.TRANSPOSED);
                gradientArrays.add(_this.x1Tensor, _this.x1Tensor.shape.length === 1 ? dx1.as1D() : dx1);
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var dx2 = math.matMul(x1, dy, math_1.MatrixOrientation.TRANSPOSED, math_1.MatrixOrientation.REGULAR);
                gradientArrays.add(_this.x2Tensor, _this.x2Tensor.shape.length === 1 ? dx2.as1D() : dx2);
            }
        });
    };
    return MatMul;
}(op_1.Operation));
exports.MatMul = MatMul;
//# sourceMappingURL=matmul.js.map

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = __webpack_require__(51);
var util = __webpack_require__(4);
var op_1 = __webpack_require__(12);
var MaxPool = (function (_super) {
    __extends(MaxPool, _super);
    function MaxPool(xTensor, yTensor, fieldSize, stride, pad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        if (pad != null) {
            _this.pad = pad;
        }
        else {
            _this.pad = conv_util.computeDefaultPad(xTensor.shape, _this.fieldSize, _this.stride);
        }
        util.assert(util.isInt(_this.pad), "The zero padding (" + _this.pad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    MaxPool.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.maxPool(x, _this.fieldSize, _this.stride, _this.pad)));
        });
    };
    MaxPool.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            gradientArrays.add(_this.xTensor, math.maxPoolBackprop(dy, x, _this.fieldSize, _this.stride, _this.pad));
        });
    };
    return MaxPool;
}(op_1.Operation));
exports.MaxPool = MaxPool;
//# sourceMappingURL=max_pool.js.map

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = __webpack_require__(4);
var graph_util = __webpack_require__(21);
var op_1 = __webpack_require__(12);
var Multiply = (function (_super) {
    __extends(Multiply, _super);
    function Multiply(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Multiply.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarTimesArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.scalarTimesArray(t2, t1);
            }
            else {
                result = math.elementWiseMul(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Multiply.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x2);
                    gradientArrays.add(_this.x1Tensor, math.sum(mul));
                }
                else if (util.isScalarShape(x2.shape)) {
                    gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(x2, dy));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.elementWiseMul(x2, dy));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x1);
                    gradientArrays.add(_this.x2Tensor, math.sum(mul));
                }
                else if (util.isScalarShape(x1.shape)) {
                    gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(x1, dy));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, math.elementWiseMul(x1, dy));
                }
            }
        });
    };
    return Multiply;
}(op_1.Operation));
exports.Multiply = Multiply;
//# sourceMappingURL=multiply.js.map

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var graph_util = __webpack_require__(21);
var op_1 = __webpack_require__(12);
var ReduceSum = (function (_super) {
    __extends(ReduceSum, _super);
    function ReduceSum(x, outTensor) {
        var _this = _super.call(this) || this;
        _this.x = x;
        _this.outTensor = outTensor;
        util.assertShapesMatch(outTensor.shape, []);
        return _this;
    }
    ReduceSum.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.x);
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.sum(x)));
        });
    };
    ReduceSum.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        if (!graph_util.shouldBackProp(this.x)) {
            return;
        }
        math.scope(function () {
            var dy = gradientArrays.get(_this.outTensor);
            if (_this.ones == null) {
                var xArray = inferenceArrays.get(_this.x);
                _this.ones = ndarray_1.NDArray.zerosLike(xArray);
                _this.ones.fill(1);
            }
            gradientArrays.add(_this.x, math.scalarTimesArray(dy, _this.ones));
        });
    };
    return ReduceSum;
}(op_1.Operation));
exports.ReduceSum = ReduceSum;
//# sourceMappingURL=reduce_sum.js.map

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = __webpack_require__(4);
var op_1 = __webpack_require__(12);
var Reshape = (function (_super) {
    __extends(Reshape, _super);
    function Reshape(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        var xSize = util.sizeFromShape(xTensor.shape);
        var ySize = util.sizeFromShape(yTensor.shape);
        util.assert(xSize === ySize, "The input size (" + xSize + ") and output size (" + ySize + ") must match");
        return _this;
    }
    Reshape.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var clone = math.clone(x);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(clone.reshape(_this.yTensor.shape)));
        });
    };
    Reshape.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        var clone = math.clone(dy);
        math.scope(function () {
            gradientArrays.add(_this.xTensor, clone.reshape(_this.xTensor.shape));
        });
    };
    return Reshape;
}(op_1.Operation));
exports.Reshape = Reshape;
//# sourceMappingURL=reshape.js.map

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var graph_1 = __webpack_require__(64);
var op_1 = __webpack_require__(12);
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax(logitsTensor, output) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.output = output;
        return _this;
    }
    Softmax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        return math.scope(function (keep) {
            inferenceArrays.set(_this.output, keep(math.softmax(logits)));
        });
    };
    Softmax.prototype.backProp = function () {
        throw Error('Softmax backprop is not yet implemented');
    };
    return Softmax;
}(op_1.Operation));
exports.Softmax = Softmax;
var SoftmaxCrossEntropyCost = (function (_super) {
    __extends(SoftmaxCrossEntropyCost, _super);
    function SoftmaxCrossEntropyCost(logitsTensor, labelTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.labelTensor = labelTensor;
        _this.yTensor = yTensor;
        _this.epsilon = ndarray_1.Scalar.new(1e-5);
        _this.softmaxTensor = new graph_1.Tensor(logitsTensor.shape);
        return _this;
    }
    SoftmaxCrossEntropyCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function (keep) {
            var softmaxResult = math.softmax(logits);
            inferenceArrays.set(_this.softmaxTensor, keep(softmaxResult));
            inferenceArrays.set(_this.yTensor, keep(crossEntropyCost(math, softmaxResult, label, _this.epsilon)));
        });
    };
    SoftmaxCrossEntropyCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var softmax = inferenceArrays.get(this.softmaxTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function () {
            gradientArrays.add(_this.logitsTensor, math.subtract(softmax, label));
        });
    };
    SoftmaxCrossEntropyCost.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {
        inferenceArrays.disposeArray(this.softmaxTensor);
    };
    SoftmaxCrossEntropyCost.prototype.dispose = function () {
        this.epsilon.dispose();
    };
    return SoftmaxCrossEntropyCost;
}(op_1.Operation));
exports.SoftmaxCrossEntropyCost = SoftmaxCrossEntropyCost;
function crossEntropyCost(math, y, target, epsilon) {
    util.assert(y.size === target.size, 'The output and target must be the same size');
    return math.scope(function () {
        var yPlusEps = math.scalarPlusArray(epsilon, y);
        var logOutput = math.log(yPlusEps);
        var tarLogOutput = math.elementWiseMul(target, logOutput);
        var costVector = math.neg(tarLogOutput);
        return math.sum(costVector);
    });
}
exports.crossEntropyCost = crossEntropyCost;
//# sourceMappingURL=softmax.js.map

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var util = __webpack_require__(4);
var graph_util = __webpack_require__(21);
var op_1 = __webpack_require__(12);
var Subtract = (function (_super) {
    __extends(Subtract, _super);
    function Subtract(t1, t2, outTensor) {
        var _this = _super.call(this) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.outTensor = outTensor;
        util.assert(util.sizeFromShape(t1.shape) === 1 ||
            util.sizeFromShape(t2.shape) === 1 ||
            util.arraysEqual(t1.shape, t2.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Subtract.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.t1);
        var t2 = inferenceArrays.get(this.t2);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarMinusArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayMinusScalar(t1, t2);
            }
            else {
                result = math.subtract(t1, t2);
            }
            inferenceArrays.set(_this.outTensor, keep(result));
        });
    };
    Subtract.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.t1)) {
                if (util.isScalarShape(_this.t1.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.t1, math.divide(sum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.t1, math.clone(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.t2)) {
                if (util.isScalarShape(_this.t2.shape)) {
                    var sum = math.sum(dy);
                    var negSum = math.neg(sum);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.t2, math.divide(negSum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.t2, math.neg(dy));
                }
            }
        });
    };
    Subtract.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Subtract;
}(op_1.Operation));
exports.Subtract = Subtract;
//# sourceMappingURL=subtract.js.map

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var tensor_array_map_1 = __webpack_require__(35);
var optimizer_1 = __webpack_require__(50);
var AdadeltaOptimizer = (function (_super) {
    __extends(AdadeltaOptimizer, _super);
    function AdadeltaOptimizer(learningRate, gamma, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.gamma = gamma;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.accumulatedUpdates = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        _this.g = ndarray_1.Scalar.new(_this.gamma);
        return _this;
    }
    AdadeltaOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                _this.accumulatedUpdates.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdadeltaOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var oldUpdates = _this.accumulatedUpdates.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
                var updates = math.multiply(math.divide(math.sqrt(math.add(oldUpdates, _this.eps)), math.sqrt(math.add(oldCache, _this.eps))), gradient);
                var variable = math.scaledArrayAdd(_this.c, updates, _this.one, oldVariable);
                var updateSquare = math.multiply(updates, updates);
                var newUpdates = math.scaledArrayAdd(_this.g, oldUpdates, math.subtract(_this.one, _this.g), updateSquare);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                _this.accumulatedUpdates.set(node.output, keep(newUpdates));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
                oldUpdates.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdadeltaOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.g.dispose();
        this.accumulatedSquaredGradients.dispose();
        this.accumulatedUpdates.dispose();
    };
    return AdadeltaOptimizer;
}(optimizer_1.Optimizer));
exports.AdadeltaOptimizer = AdadeltaOptimizer;
//# sourceMappingURL=adadelta_optimizer.js.map

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var tensor_array_map_1 = __webpack_require__(35);
var optimizer_1 = __webpack_require__(50);
var AdagradOptimizer = (function (_super) {
    __extends(AdagradOptimizer, _super);
    function AdagradOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        return _this;
    }
    AdagradOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdagradOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.add(oldCache, gradientSquare);
                var variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdagradOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.accumulatedSquaredGradients.dispose();
    };
    return AdagradOptimizer;
}(optimizer_1.Optimizer));
exports.AdagradOptimizer = AdagradOptimizer;
//# sourceMappingURL=adagrad_optimizer.js.map

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var tensor_array_map_1 = __webpack_require__(35);
var optimizer_1 = __webpack_require__(50);
var AdamOptimizer = (function (_super) {
    __extends(AdamOptimizer, _super);
    function AdamOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
        _this.secondMoment = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-8);
        _this.b1 = ndarray_1.Scalar.new(_this.beta1);
        _this.b2 = ndarray_1.Scalar.new(_this.beta2);
        _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
        _this.accB2 = ndarray_1.Scalar.new(_this.beta2);
        return _this;
    }
    AdamOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.firstMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
        if (this.secondMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.secondMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdamOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldFirstMoment = _this.firstMoment.get(node.output);
                var oldSecondMoment = _this.secondMoment.get(node.output);
                var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
                var gradientSquare = math.multiply(gradient, gradient);
                var newSecondMoment = math.scaledArrayAdd(_this.b2, oldSecondMoment, math.subtract(_this.one, _this.b2), gradientSquare);
                var biasCorrectedFirstMoment = math.divide(newFirstMoment, math.subtract(_this.one, _this.accB1));
                var biasCorrectedSecondMoment = math.divide(newSecondMoment, math.subtract(_this.one, _this.accB2));
                var variable = math.scaledArrayAdd(_this.c, math.divide(biasCorrectedFirstMoment, math.add(math.sqrt(biasCorrectedSecondMoment), _this.eps)), _this.one, oldVariable);
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                _this.firstMoment.set(node.output, keep(newFirstMoment));
                _this.secondMoment.set(node.output, keep(newSecondMoment));
                oldVariable.dispose();
                gradient.dispose();
                oldFirstMoment.dispose();
                oldSecondMoment.dispose();
            });
            var oldAccB1 = _this.accB1;
            var oldAccB2 = _this.accB2;
            _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
            _this.accB2 = keep(math.multiply(_this.accB2, _this.b2));
            oldAccB1.dispose();
            oldAccB2.dispose();
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdamOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.firstMoment.dispose();
        this.secondMoment.dispose();
        this.eps.dispose();
        this.b1.dispose();
        this.b2.dispose();
        this.accB1.dispose();
        this.accB2.dispose();
    };
    return AdamOptimizer;
}(optimizer_1.Optimizer));
exports.AdamOptimizer = AdamOptimizer;
//# sourceMappingURL=adam_optimizer.js.map

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var tensor_array_map_1 = __webpack_require__(35);
var optimizer_1 = __webpack_require__(50);
var AdamaxOptimizer = (function (_super) {
    __extends(AdamaxOptimizer, _super);
    function AdamaxOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
        _this.weightedInfNorm = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-8);
        _this.b1 = ndarray_1.Scalar.new(_this.beta1);
        _this.b2 = ndarray_1.Scalar.new(_this.beta2);
        _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
        return _this;
    }
    AdamaxOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.firstMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
        if (this.weightedInfNorm.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.weightedInfNorm.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdamaxOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldFirstMoment = _this.firstMoment.get(node.output);
                var oldWeightedInfNorm = _this.weightedInfNorm.get(node.output);
                var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
                var ut0 = math.multiply(_this.b2, oldWeightedInfNorm);
                var ut1 = math.abs(gradient);
                var newWeightedInfNorm = math.add(math.relu(math.subtract(ut0, ut1)), ut1);
                var variable = math.scaledArrayAdd(_this.one, oldVariable, math.divide(_this.c, math.subtract(_this.one, _this.accB1)), math.divide(newFirstMoment, math.add(_this.eps, newWeightedInfNorm)));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                _this.firstMoment.set(node.output, keep(newFirstMoment));
                _this.weightedInfNorm.set(node.output, keep(newWeightedInfNorm));
                oldVariable.dispose();
                gradient.dispose();
                oldFirstMoment.dispose();
                oldWeightedInfNorm.dispose();
            });
            var oldAccB1 = _this.accB1;
            _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
            oldAccB1.dispose();
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdamaxOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.firstMoment.dispose();
        this.weightedInfNorm.dispose();
        this.eps.dispose();
        this.accB1.dispose();
        this.b1.dispose();
        this.b2.dispose();
    };
    return AdamaxOptimizer;
}(optimizer_1.Optimizer));
exports.AdamaxOptimizer = AdamaxOptimizer;
//# sourceMappingURL=adamax_optimizer.js.map

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var tensor_array_map_1 = __webpack_require__(35);
var sgd_optimizer_1 = __webpack_require__(148);
var MomentumOptimizer = (function (_super) {
    __extends(MomentumOptimizer, _super);
    function MomentumOptimizer(learningRate, momentum, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.momentum = momentum;
        _this.variableVelocities = new tensor_array_map_1.TensorArrayMap();
        _this.m = ndarray_1.Scalar.new(_this.momentum);
        return _this;
    }
    MomentumOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.variableVelocities.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.variableVelocities.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    MomentumOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldVelocity = _this.variableVelocities.get(node.output);
                var velocity = math.scaledArrayAdd(_this.m, oldVelocity, _this.one, gradient);
                var variable = math.scaledArrayAdd(_this.c, velocity, _this.one, oldVariable);
                _this.variableVelocities.set(node.output, keep(velocity));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldVelocity.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    MomentumOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.m.dispose();
        this.variableVelocities.dispose();
    };
    MomentumOptimizer.prototype.setMomentum = function (momentum) {
        this.momentum = momentum;
    };
    return MomentumOptimizer;
}(sgd_optimizer_1.SGDOptimizer));
exports.MomentumOptimizer = MomentumOptimizer;
//# sourceMappingURL=momentum_optimizer.js.map

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var tensor_array_map_1 = __webpack_require__(35);
var optimizer_1 = __webpack_require__(50);
var RMSPropOptimizer = (function (_super) {
    __extends(RMSPropOptimizer, _super);
    function RMSPropOptimizer(learningRate, gamma, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.gamma = gamma;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        _this.g = ndarray_1.Scalar.new(_this.gamma);
        return _this;
    }
    RMSPropOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    RMSPropOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
                var variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    RMSPropOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.g.dispose();
        this.accumulatedSquaredGradients.dispose();
    };
    return RMSPropOptimizer;
}(optimizer_1.Optimizer));
exports.RMSPropOptimizer = RMSPropOptimizer;
//# sourceMappingURL=rmsprop_optimizer.js.map

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var session_1 = __webpack_require__(150);
var ndarray_1 = __webpack_require__(6);
var DEFAULT_EVAL_INTERVAL_MS = 1500;
var DEFAULT_COST_INTERVAL_MS = 500;
var DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS = 3000;
var MetricReduction;
(function (MetricReduction) {
    MetricReduction[MetricReduction["SUM"] = 0] = "SUM";
    MetricReduction[MetricReduction["MEAN"] = 1] = "MEAN";
})(MetricReduction = exports.MetricReduction || (exports.MetricReduction = {}));
var GraphRunner = (function () {
    function GraphRunner(math, session, eventObserver) {
        this.math = math;
        this.session = session;
        this.eventObserver = eventObserver;
        this.lastCostTimestamp = 0;
        this.lastEvalTimestamp = 0;
        this.totalIdleTimeMs = 0;
        this.resetStatistics();
        this.zeroScalar = ndarray_1.Scalar.new(0);
    }
    GraphRunner.prototype.resetStatistics = function () {
        this.totalBatchesTrained = 0;
        this.totalIdleTimeMs = 0;
        this.lastStopTimestamp = null;
    };
    GraphRunner.prototype.train = function (costTensor, trainFeedEntries, batchSize, optimizer, numBatches, metricTensor, metricFeedEntries, metricBatchSize, metricReduction, evalIntervalMs, costIntervalMs) {
        if (metricReduction === void 0) { metricReduction = MetricReduction.MEAN; }
        if (evalIntervalMs === void 0) { evalIntervalMs = DEFAULT_EVAL_INTERVAL_MS; }
        if (costIntervalMs === void 0) { costIntervalMs = DEFAULT_COST_INTERVAL_MS; }
        this.costTensor = costTensor;
        this.trainFeedEntries = trainFeedEntries;
        this.metricTensor = metricTensor;
        this.metricFeedEntries = metricFeedEntries;
        if (metricBatchSize != null && this.metricBatchSize !== metricBatchSize) {
            if (this.metricBatchSizeScalar != null) {
                this.metricBatchSizeScalar.dispose();
            }
            this.metricBatchSizeScalar = ndarray_1.Scalar.new(metricBatchSize);
        }
        this.metricBatchSize = metricBatchSize;
        this.metricReduction = metricReduction;
        this.batchSize = batchSize;
        this.optimizer = optimizer;
        this.metricIntervalMs = evalIntervalMs;
        this.costIntervalMs = costIntervalMs;
        this.currentTrainLoopNumBatches = numBatches;
        this.batchesTrainedThisRun = 0;
        this.isTraining = true;
        this.trainStartTimestamp = performance.now();
        this.trainNetwork();
    };
    GraphRunner.prototype.stopTraining = function () {
        this.isTraining = false;
        this.lastStopTimestamp = performance.now();
    };
    GraphRunner.prototype.resumeTraining = function () {
        this.isTraining = true;
        if (this.lastStopTimestamp != null) {
            this.totalIdleTimeMs += performance.now() - this.lastStopTimestamp;
        }
        this.trainNetwork();
    };
    GraphRunner.prototype.trainNetwork = function () {
        var _this = this;
        if (this.batchesTrainedThisRun === this.currentTrainLoopNumBatches) {
            this.stopTraining();
        }
        if (!this.isTraining) {
            if (this.eventObserver.doneTrainingCallback != null) {
                this.eventObserver.doneTrainingCallback();
            }
            return;
        }
        var start = performance.now();
        var shouldComputeCost = this.eventObserver.avgCostCallback != null &&
            (start - this.lastCostTimestamp > this.costIntervalMs);
        if (shouldComputeCost) {
            this.lastCostTimestamp = start;
        }
        var costReduction = shouldComputeCost ? session_1.CostReduction.MEAN : session_1.CostReduction.NONE;
        this.math.scope(function (keep) {
            var avgCost = _this.session.train(_this.costTensor, _this.trainFeedEntries, _this.batchSize, _this.optimizer, costReduction);
            if (shouldComputeCost) {
                var trainTime = performance.now() - start;
                _this.eventObserver.avgCostCallback(avgCost);
                if (_this.eventObserver.trainExamplesPerSecCallback != null) {
                    var examplesPerSec = (_this.batchSize * 1000 / trainTime);
                    _this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);
                }
            }
            if (_this.eventObserver.metricCallback != null &&
                _this.metricFeedEntries != null &&
                start - _this.lastEvalTimestamp > _this.metricIntervalMs) {
                _this.lastEvalTimestamp = start;
                if (_this.lastComputedMetric != null) {
                    _this.lastComputedMetric.dispose();
                }
                _this.lastComputedMetric = _this.computeMetric();
                _this.eventObserver.metricCallback(_this.lastComputedMetric);
            }
            if (_this.eventObserver.totalTimeCallback != null) {
                _this.eventObserver.totalTimeCallback((start - _this.trainStartTimestamp) / 1000);
            }
            _this.batchesTrainedThisRun++;
            _this.totalBatchesTrained++;
            if (_this.eventObserver.batchesTrainedCallback != null) {
                _this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);
            }
        });
        requestAnimationFrame(function () { return _this.trainNetwork(); });
    };
    GraphRunner.prototype.infer = function (inferenceTensor, inferenceFeedEntries, inferenceExampleIntervalMs, inferenceExampleCount, numPasses) {
        var _this = this;
        if (inferenceExampleIntervalMs === void 0) { inferenceExampleIntervalMs = DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS; }
        if (inferenceExampleCount === void 0) { inferenceExampleCount = 5; }
        if (this.eventObserver.inferenceExamplesCallback == null &&
            this.eventObserver.inferenceExamplesPerSecCallback == null) {
            throw new Error('Cannot start inference loop, no inference example or ' +
                'examples/sec observer provided.');
        }
        for (var i = 0; i < inferenceFeedEntries.length; i++) {
            var feedEntry = inferenceFeedEntries[i];
            if (feedEntry.data instanceof ndarray_1.NDArray) {
                throw new Error('Cannot start inference on the model runner with feed entries of ' +
                    'type NDArray. Please use InputProviders.');
            }
        }
        this.inferenceExampleIntervalMs = inferenceExampleIntervalMs;
        this.inferenceTensor = inferenceTensor;
        this.inferenceFeedEntries = inferenceFeedEntries;
        this.inferenceExampleCount = inferenceExampleCount;
        this.currentInferenceLoopNumPasses = numPasses;
        if (!this.isInferring) {
            this.inferencePassesThisRun = 0;
            requestAnimationFrame(function () { return _this.inferNetwork(); });
        }
        this.isInferring = true;
    };
    GraphRunner.prototype.inferNetwork = function () {
        var _this = this;
        if (!this.isInferring ||
            this.inferencePassesThisRun === this.currentInferenceLoopNumPasses) {
            return;
        }
        this.math.scope(function (keep, track) {
            var feeds = [];
            var inferenceValues = [];
            var start = performance.now();
            for (var i = 0; i < _this.inferenceExampleCount; i++) {
                var ndarrayFeedEntries = [];
                for (var j = 0; j < _this.inferenceFeedEntries.length; j++) {
                    var feedEntry = _this.inferenceFeedEntries[j];
                    var nextCopy = feedEntry.data.getNextCopy(_this.math);
                    ndarrayFeedEntries.push({ tensor: feedEntry.tensor, data: track(nextCopy) });
                }
                feeds.push(ndarrayFeedEntries);
                inferenceValues.push(_this.session.eval(_this.inferenceTensor, ndarrayFeedEntries));
            }
            if (_this.eventObserver.inferenceExamplesPerSecCallback != null) {
                inferenceValues[inferenceValues.length - 1].getValues();
                var inferenceExamplesPerSecTime = performance.now() - start;
                var examplesPerSec = (_this.inferenceExampleCount * 1000 / inferenceExamplesPerSecTime);
                _this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);
            }
            if (_this.eventObserver.inferenceExamplesCallback != null) {
                _this.eventObserver.inferenceExamplesCallback(feeds, inferenceValues);
            }
            _this.inferencePassesThisRun++;
        });
        this.lastInferTimeoutID = window.setTimeout(function () { return _this.inferNetwork(); }, this.inferenceExampleIntervalMs);
    };
    GraphRunner.prototype.stopInferring = function () {
        this.isInferring = false;
        window.clearTimeout(this.lastInferTimeoutID);
    };
    GraphRunner.prototype.isInferenceRunning = function () {
        return this.isInferring;
    };
    GraphRunner.prototype.computeMetric = function () {
        var _this = this;
        if (this.metricFeedEntries == null) {
            throw new Error('Cannot compute metric, no metric FeedEntries provided.');
        }
        var metric = this.zeroScalar;
        return this.math.scope(function (keep) {
            for (var i = 0; i < _this.metricBatchSize; i++) {
                var metricValue = _this.session.eval(_this.metricTensor, _this.metricFeedEntries);
                metric = _this.math.add(metric, metricValue);
            }
            if (_this.metricReduction === MetricReduction.MEAN) {
                metric = _this.math.divide(metric, _this.metricBatchSizeScalar);
            }
            return metric;
        });
    };
    GraphRunner.prototype.getTotalBatchesTrained = function () {
        return this.totalBatchesTrained;
    };
    GraphRunner.prototype.getLastComputedMetric = function () {
        return this.lastComputedMetric;
    };
    GraphRunner.prototype.setMath = function (math) {
        this.math = math;
    };
    GraphRunner.prototype.setSession = function (session) {
        this.session = session;
    };
    GraphRunner.prototype.setInferenceTensor = function (inferenceTensor) {
        this.inferenceTensor = inferenceTensor;
    };
    GraphRunner.prototype.setInferenceExampleCount = function (inferenceExampleCount) {
        this.inferenceExampleCount = inferenceExampleCount;
    };
    return GraphRunner;
}());
exports.GraphRunner = GraphRunner;
//# sourceMappingURL=graph_runner.js.map

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var TanHFunc = (function () {
    function TanHFunc() {
    }
    TanHFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.tanh(x);
        });
    };
    TanHFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.elementWiseMul(y, y);
            return math.scalarMinusArray(ndarray_1.Scalar.ONE, ySquared);
        });
    };
    TanHFunc.prototype.dispose = function () { };
    return TanHFunc;
}());
exports.TanHFunc = TanHFunc;
var ReLUFunc = (function () {
    function ReLUFunc() {
    }
    ReLUFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.relu(x);
        });
    };
    ReLUFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            return math.step(x);
        });
    };
    ReLUFunc.prototype.dispose = function () { };
    return ReLUFunc;
}());
exports.ReLUFunc = ReLUFunc;
var LeakyReluFunc = (function () {
    function LeakyReluFunc(alpha) {
        this.alpha = alpha;
    }
    LeakyReluFunc.prototype.output = function (math, x) {
        return math.leakyRelu(x, this.alpha);
    };
    LeakyReluFunc.prototype.der = function (math, x, y) {
        return math.step(x, this.alpha);
    };
    LeakyReluFunc.prototype.dispose = function () { };
    return LeakyReluFunc;
}());
exports.LeakyReluFunc = LeakyReluFunc;
var SigmoidFunc = (function () {
    function SigmoidFunc() {
    }
    SigmoidFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.sigmoid(x);
        });
    };
    SigmoidFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.elementWiseMul(y, y);
            return math.subStrict(y, ySquared);
        });
    };
    SigmoidFunc.prototype.dispose = function () { };
    return SigmoidFunc;
}());
exports.SigmoidFunc = SigmoidFunc;
var SquareFunc = (function () {
    function SquareFunc() {
    }
    SquareFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.elementWiseMul(x, x);
        });
    };
    SquareFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            return math.scalarTimesArray(ndarray_1.Scalar.TWO, x);
        });
    };
    SquareFunc.prototype.dispose = function () { };
    return SquareFunc;
}());
exports.SquareFunc = SquareFunc;
//# sourceMappingURL=activation_functions.js.map

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = __webpack_require__(6);
var SquareCostFunc = (function () {
    function SquareCostFunc() {
        this.halfOne = ndarray_1.Scalar.new(0.5);
    }
    SquareCostFunc.prototype.cost = function (math, x1, x2) {
        var diff = math.subStrict(x1, x2);
        var diffSquared = math.elementWiseMul(diff, diff);
        var result = math.scalarTimesArray(this.halfOne, diffSquared);
        diff.dispose();
        diffSquared.dispose();
        return result;
    };
    SquareCostFunc.prototype.der = function (math, x1, x2) {
        return math.subStrict(x1, x2);
    };
    SquareCostFunc.prototype.dispose = function () {
        this.halfOne.dispose();
    };
    return SquareCostFunc;
}());
exports.SquareCostFunc = SquareCostFunc;
//# sourceMappingURL=cost_functions.js.map

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
    if (inSize <= exports.PARALLELIZE_THRESHOLD) {
        return inSize;
    }
    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
exports.computeOptimalWindowSize = computeOptimalWindowSize;
function nearestDivisor(size, start) {
    for (var i = start; i < size; ++i) {
        if (size % i === 0) {
            return i;
        }
    }
    return size;
}
//# sourceMappingURL=reduce_util.js.map

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util = __webpack_require__(4);
function assertParamsValid(input, begin, size) {
    util.assert(input.rank === begin.length, "Error in slice" + input.rank + "D: Length of begin " + begin + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    util.assert(input.rank === size.length, "Error in slice" + input.rank + "D: Length of size " + size + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    for (var i = 0; i < input.rank; ++i) {
        util.assert(begin[i] + size[i] <= input.shape[i], "Error in slice" + input.rank + "D: begin[" + i + "] + size[" + i + "] " +
            ("(" + (begin[i] + size[i]) + ") would overflow input.shape[" + i + "] (" + input.shape[i] + ")"));
    }
}
exports.assertParamsValid = assertParamsValid;
//# sourceMappingURL=slice_util.js.map

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = __webpack_require__(56);
var AddScaledMatProgram = (function () {
    function AddScaledMatProgram(aShape, bShape) {
        this.variableNames = ['A', 'B', 'c1', 'c2'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        float c1 = getC1();\n        float c2 = getC2();\n        setOutput(dot(vec2(c1, c2), vec2(a, b)));\n      }\n    ";
    }
    return AddScaledMatProgram;
}());
exports.AddScaledMatProgram = AddScaledMatProgram;
//# sourceMappingURL=addscaledmat_gpu.js.map

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ArgMinMaxProgram = (function () {
    function ArgMinMaxProgram(reduceInfo, op, firstPass) {
        this.variableNames = ['A'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        if (!firstPass) {
            this.variableNames.push('bestIndicesA');
        }
        this.outputShape = [batchSize, outSize];
        var compOp = (op === 'max') ? '>' : '<';
        var indexSnippet = firstPass ?
            'inOffset + i;' :
            'round(getBestIndicesA(batch, inOffset + i));';
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < " + windowSize + "; i++) {\n          int inIdx = " + indexSnippet + ";\n          float candidate = getA(batch, inIdx);\n          if (isNaN(candidate)) {\n            setOutput(candidate);\n            return;\n          }\n          if (candidate " + compOp + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
    }
    return ArgMinMaxProgram;
}());
exports.ArgMinMaxProgram = ArgMinMaxProgram;
//# sourceMappingURL=argminmax_gpu.js.map

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = __webpack_require__(56);
var BatchNormProgram = (function () {
    function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.supportsBroadcasting = true;
        this.variableNames = ['x', 'mean', 'variance'];
        broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
        broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
        var offsetSnippet = '0.0';
        if (offsetShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        var scaleSnippet = '1.0';
        if (scaleShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + offsetSnippet + ";\n        float scale = " + scaleSnippet + ";\n        float inv = scale / sqrt(variance + float(" + varianceEpsilon + "));\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
    }
    return BatchNormProgram;
}());
exports.BatchNormProgram = BatchNormProgram;
//# sourceMappingURL=batchnorm_gpu.js.map

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ClipProgram = (function () {
    function ClipProgram(aShape, min, max) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        var minFixed = min.toFixed(20);
        var maxFixed = max.toFixed(20);
        this.userCode = "\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, " + minFixed + ", " + maxFixed + "));\n      }\n    ";
    }
    return ClipProgram;
}());
exports.ClipProgram = ClipProgram;
//# sourceMappingURL=clip_gpu.js.map

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = __webpack_require__(65);
var shader_compiler_1 = __webpack_require__(66);
var ConcatProgram = (function () {
    function ConcatProgram(aShape, bShape, axis) {
        this.variableNames = ['A', 'B'];
        this.outputShape = [];
        var yAxes = ['yR', 'yC', 'yD', 'yW'];
        var concatAxis = yAxes[axis];
        this.outputShape = concat_util.computeOutShape(aShape, bShape, axis);
        var dType = shader_compiler_1.getCoordsDataType(aShape.length);
        var unpackSnippet = getUnpack(aShape.length);
        var sampleCoords = getSampleCoords(aShape.length);
        this.userCode = "\n      void main() {\n        " + dType + " coords = getOutputCoords();\n        " + unpackSnippet + "\n\n        float value = 0.0;\n        if (" + concatAxis + " < " + aShape[axis] + ") {\n          value = getA(" + sampleCoords + ");\n        } else {\n          " + concatAxis + " -= " + aShape[axis] + ";\n          value = getB(" + sampleCoords + ");\n        }\n\n        setOutput(value);\n      }\n    ";
    }
    return ConcatProgram;
}());
exports.ConcatProgram = ConcatProgram;
function getSampleCoords(rank) {
    if (rank === 1) {
        return 'yR';
    }
    else if (rank === 2) {
        return 'yR, yC';
    }
    else if (rank === 3) {
        return 'yR, yC, yD';
    }
    else if (rank === 4) {
        return 'yR, yC, yD, yW';
    }
    else {
        throw Error("Concat for rank " + rank + " is not yet supported");
    }
}
function getUnpack(rank) {
    var res = rank === 1 ? 'int yR = coords;' : 'int yR = coords.x;';
    if (rank > 1) {
        res += '\nint yC = coords.y;';
    }
    if (rank > 2) {
        res += '\nint yD = coords.z;';
    }
    if (rank > 3) {
        res += '\nint yW = coords.w;';
    }
    if (rank > 4) {
        throw Error("Concat for rank " + rank + " is not yet supported");
    }
    return res;
}
//# sourceMappingURL=concat_gpu.js.map

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = __webpack_require__(51);
var Conv2DDerWeightsProgram = (function () {
    function Conv2DDerWeightsProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        var _a = convInfo.outShape, yNumRows = _a[0], yNumCols = _a[1], outDepth = _a[2];
        var _b = convInfo.inShape, xNumRows = _b[0], xNumCols = _b[1], inDepth = _b[2];
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        this.outputShape = conv_util.computeWeightsShape4D(inDepth, outDepth, convInfo.filterHeight, convInfo.filterWidth);
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int yR = 0; yR < " + yNumRows + "; yR++) {\n          int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int yC = 0; yC < " + yNumCols + "; yC++) {\n            int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float dyValue = getDy(yR, yC, d2);\n            float xValue = getX(xR, xC, d1);\n            dotProd += (xValue * dyValue);\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerWeightsProgram;
}());
exports.Conv2DDerWeightsProgram = Conv2DDerWeightsProgram;
var Conv2DDerInputProgram = (function () {
    function Conv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        var _a = convInfo.outShape, yRows = _a[0], yCols = _a[1], outDepth = _a[2];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d1 = coords.z;\n\n        ivec2 dyCorner = coords.xy - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + yRows + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + yCols + ".0 || fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + outDepth + "; d2++) {\n              float xValue = getDy(idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerInputProgram;
}());
exports.Conv2DDerInputProgram = Conv2DDerInputProgram;
var Conv2DDerBiasProgram = (function () {
    function Conv2DDerBiasProgram(yShape) {
        this.variableNames = ['dy'];
        var yNumRows = yShape[0], yNumCols = yShape[1], outputDepth = yShape[2];
        this.outputShape = [outputDepth];
        this.userCode = "\n      void main() {\n        int d2 = getOutputCoords();\n\n        float derBias = 0.0;\n        for (int yR = 0; yR < " + yNumRows + "; yR++) {\n          for (int yC = 0; yC < " + yNumCols + "; yC++) {\n            derBias += getDy(yR, yC, d2);\n          }\n        }\n        setOutput(derBias);\n      }\n    ";
    }
    return Conv2DDerBiasProgram;
}());
exports.Conv2DDerBiasProgram = Conv2DDerBiasProgram;
//# sourceMappingURL=conv_backprop_gpu.js.map

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DProgram = (function () {
    function Conv2DProgram(convInfo, hasBias) {
        this.variableNames = ['x', 'W'];
        if (hasBias) {
            this.variableNames.push('bias');
        }
        this.outputShape = convInfo.outShape;
        var biasSnippet = hasBias ? 'dotProd += getBias(d2);' : '';
        var _a = convInfo.inShape, xNumRows = _a[0], xNumCols = _a[1], inputDepth = _a[2];
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var inputDepthNearestVec4 = Math.floor(inputDepth / 4) * 4;
        var inputDepthVec4Remainder = inputDepth % 4;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d2 = coords.z;\n\n        ivec2 xRCCorner = coords.xy * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + inputDepthNearestVec4 + "; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(xR, xC, d1),\n                getX(xR, xC, d1 + 1),\n                getX(xR, xC, d1 + 2),\n                getX(xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (" + (inputDepthVec4Remainder === 1) + ") {\n              dotProd +=\n                getX(xR, xC, " + inputDepthNearestVec4 + ") *\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2);\n            } else if (" + (inputDepthVec4Remainder === 2) + ") {\n              vec2 xValues = vec2(\n                getX(xR, xC, " + inputDepthNearestVec4 + "),\n                getX(xR, xC, " + inputDepthNearestVec4 + " + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (" + (inputDepthVec4Remainder === 3) + ") {\n              vec3 xValues = vec3(\n                getX(xR, xC, " + inputDepthNearestVec4 + "),\n                getX(xR, xC, " + inputDepthNearestVec4 + " + 1),\n                getX(xR, xC, " + inputDepthNearestVec4 + " + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        " + biasSnippet + "\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DProgram;
}());
exports.Conv2DProgram = Conv2DProgram;
//# sourceMappingURL=conv_gpu.js.map

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DProgram = (function () {
    function DepthwiseConv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var xNumRows = convInfo.inShape[1];
        var xNumCols = convInfo.inShape[2];
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var channelMul = convInfo.channelMul;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + channelMul + ";\n        int q = d2 - d1 * " + channelMul + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DProgram;
}());
exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram;
//# sourceMappingURL=conv_gpu_depthwise.js.map

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Copy2DProgram = (function () {
    function Copy2DProgram(srcNumCols, destNumCols) {
        this.variableNames = ['source'];
        this.outputShape = null;
        this.userCode = "\n      uniform ivec2 sourceStart;\n      uniform ivec2 destStart;\n\n      void main() {\n        ivec2 destCoords = getOutputCoords() - destStart;\n        int index = destCoords.x * " + destNumCols + " + destCoords.y;\n        int r = index / " + srcNumCols + ";\n        ivec2 sourceCoords = sourceStart + ivec2(r, index - r * " + srcNumCols + ");\n        setOutput(getSource(sourceCoords.x, sourceCoords.y));\n      }\n    ";
    }
    Copy2DProgram.prototype.getCustomSetupFunc = function (sourceStart, destStart, destSize) {
        return function (gpgpu, webGLProgram) {
            gpgpu.setOutputMatrixWriteRegion(destStart[0], destSize[0], destStart[1], destSize[1]);
            var sourceStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'sourceStart');
            gpgpu.gl.uniform2i(sourceStartCRLoc, sourceStart[0], sourceStart[1]);
            var destStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'destStart');
            gpgpu.gl.uniform2i(destStartCRLoc, destStart[0], destStart[1]);
        };
    };
    return Copy2DProgram;
}());
exports.Copy2DProgram = Copy2DProgram;
//# sourceMappingURL=copy_gpu.js.map

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = __webpack_require__(32);
var util = __webpack_require__(4);
var shader_compiler = __webpack_require__(66);
var ATTRIBUTE_NAMES = ['uv', 'clipSpacePos'];
var NAN_UNIFORM_NAME = 'NaN';
function shouldUploadNaNUniform() {
    return !environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
}
function compileProgram(gpgpu, program, inputs, output) {
    var userCode = program.userCode;
    var inputInfos = inputs.map(function (input, i) {
        var shapeInfo = {
            logicalShape: input.shape,
            texShape: input.getTextureShapeRC(),
            textureType: input.getData().textureType
        };
        return { name: program.variableNames[i], shapeInfo: shapeInfo };
    });
    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
    var outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.getTextureShapeRC(),
        textureType: output.getData().textureType
    };
    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
    var webGLProgram = gpgpu.createProgram(source);
    var uniformLocations = {};
    for (var i = 0; i < program.variableNames.length; i++) {
        var uniformName = program.variableNames[i];
        uniformLocations[uniformName] =
            gpgpu.getUniformLocation(webGLProgram, uniformName);
    }
    var attributeLocations = {};
    ATTRIBUTE_NAMES.forEach(function (attribute) {
        attributeLocations[attribute] =
            gpgpu.getAttributeLocation(webGLProgram, attribute);
    });
    if (shouldUploadNaNUniform()) {
        uniformLocations[NAN_UNIFORM_NAME] =
            gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME);
    }
    return {
        program: program,
        source: source,
        webGLProgram: webGLProgram,
        uniformLocations: uniformLocations,
        attributeLocations: attributeLocations,
        gpgpu: gpgpu,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    };
}
exports.compileProgram = compileProgram;
function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
        throw Error("Binary was compiled with " + shapeInfos.length + " inputs, but " +
            ("was executed with " + inputs.length + " inputs"));
    }
    shapeInfos.forEach(function (s, i) {
        var shapeA = s.logicalShape;
        var texShapeA = s.texShape;
        var shapeB = inputs[i].shape;
        var texShapeB = inputs[i].getTextureShapeRC();
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error("Binary was compiled with different shapes than " +
                ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
        }
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error("Binary was compiled with different texture shapes than the" +
                (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
        }
    });
}
function runProgram(binary, inputs, output, customSetup) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    var outTex = output.getTexture();
    var outTexShape = output.getTextureShapeRC();
    var gpgpu = binary.gpgpu;
    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    gpgpu.setProgram(binary.webGLProgram);
    inputs.forEach(function (input, i) {
        var tex = input.getTexture();
        var variableName = binary.program.variableNames[i];
        var variableUniformLocation = binary.uniformLocations[variableName];
        gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);
    });
    if (shouldUploadNaNUniform()) {
        gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);
    }
    if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
    }
    gpgpu.executeProgram(binary.attributeLocations);
}
exports.runProgram = runProgram;
function makeShaderKey(program, inputs, output) {
    var keyInputs = '';
    inputs.concat(output).forEach(function (x) {
        keyInputs += x.shape + "_" + x.getTextureShapeRC();
    });
    var keyUserCode = program.userCode;
    var keyBroadcast = (program.supportsBroadcasting === true).toString();
    var key = program.constructor.name;
    key += '_' + keyBroadcast + '_' + keyInputs + '_' + keyUserCode;
    return key;
}
exports.makeShaderKey = makeShaderKey;
//# sourceMappingURL=gpgpu_math.js.map

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MaxPool2DBackpropProgram = (function () {
    function MaxPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy', 'maxPos'];
        this.outputShape = convInfo.inShape;
        var dyRows = convInfo.outShape[0];
        var dyCols = convInfo.outShape[1];
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var lastIndex = filterHeight * filterWidth - 1;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d = coords.z;\n\n        ivec2 dyRCCorner = coords.xy - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + dyRows + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + dyCols + ".0 || fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(idyR, idyC, d);\n            int maxPosValue = " + lastIndex + " - int(getMaxPos(idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + filterWidth + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return MaxPool2DBackpropProgram;
}());
exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;
//# sourceMappingURL=max_pool_backprop_gpu.js.map

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var math_1 = __webpack_require__(57);
var MatMulProgram = (function () {
    function MatMulProgram(aShape, bShape, aOrient, bOrient) {
        if (aOrient === void 0) { aOrient = math_1.MatrixOrientation.REGULAR; }
        if (bOrient === void 0) { bOrient = math_1.MatrixOrientation.REGULAR; }
        this.variableNames = ['matrixA', 'matrixB'];
        var outerShapeA = (aOrient === math_1.MatrixOrientation.REGULAR) ? aShape[0] : aShape[1];
        var outerShapeB = (bOrient === math_1.MatrixOrientation.REGULAR) ? bShape[1] : bShape[0];
        this.outputShape = [outerShapeA, outerShapeB];
        var sharedDim = (aOrient === math_1.MatrixOrientation.REGULAR ? aShape[1] : aShape[0]);
        var aSnippetFromOffset = function (vec4Offset, indexVar) {
            return (aOrient === math_1.MatrixOrientation.REGULAR) ?
                "aRow, " + indexVar + " + " + vec4Offset :
                indexVar + " + " + vec4Offset + ", aRow";
        };
        var bSnippetFromOffset = function (vec4Offset, indexVar) {
            return (bOrient === math_1.MatrixOrientation.REGULAR) ?
                indexVar + " + " + vec4Offset + ", bCol" :
                "bCol, " + indexVar + " + " + vec4Offset;
        };
        var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
        var sharedDimVec4Remainder = sharedDim % 4;
        this.userCode = " float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < " + sharedDimNearestVec4 + "; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(" + aSnippetFromOffset(0, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(1, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(2, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(3, 'i') + ")\n        );\n        vec4 b = vec4(\n          getMatrixB(" + bSnippetFromOffset(0, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(1, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(2, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(3, 'i') + ")\n        );\n\n        result += dot(a, b);\n      }\n\n      if (" + (sharedDimVec4Remainder === 1) + ") {\n        result += getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + ") *\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + ");\n      } else if (" + (sharedDimVec4Remainder === 2) + ") {\n        vec2 a = vec2(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        vec2 b = vec2(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      } else if (" + (sharedDimVec4Remainder === 3) + ") {\n        vec3 a = vec3(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        vec3 b = vec3(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    ";
    }
    return MatMulProgram;
}());
exports.MatMulProgram = MatMulProgram;
//# sourceMappingURL=mulmat_gpu.js.map

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MultinomialProgram = (function () {
    function MultinomialProgram(batchSize, numOutcomes, numSamples) {
        this.variableNames = ['probs'];
        this.outputShape = [batchSize, numSamples];
        this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (numOutcomes - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (numOutcomes - 1) + "));\n      }\n    ";
    }
    MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return MultinomialProgram;
}());
exports.MultinomialProgram = MultinomialProgram;
//# sourceMappingURL=multinomial_gpu.js.map

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var OneHotProgram = (function () {
    function OneHotProgram(numIndices, depth, onValue, offValue) {
        this.variableNames = ['indices'];
        this.outputShape = [numIndices, depth];
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + offValue + "), float(" + onValue + "),\n                      float(index == coords.y)));\n      }\n    ";
    }
    OneHotProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return OneHotProgram;
}());
exports.OneHotProgram = OneHotProgram;
//# sourceMappingURL=onehot_gpu.js.map

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Pool2DProgram = (function () {
    function Pool2DProgram(convInfo, poolType, computePositions) {
        this.variableNames = ['x'];
        if (poolType === 'avg' && computePositions) {
            throw new Error('Cannot compute positions for average pool.');
        }
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var xNumRows = convInfo.inShape[0];
        var xNumCols = convInfo.inShape[1];
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        var isAvgPool = poolType === 'avg';
        var initializationValue = '0.0';
        if (!isAvgPool) {
            if (poolType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        if (computePositions) {
            var compareOp_1 = poolType === 'min' ? '<=' : '>=';
            this.userCode = "\n        const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n        const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n          int d = coords.z;\n\n          ivec2 xRCCorner = coords.xy * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + filterHeight + "; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + xNumRows + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + filterWidth + "; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + xNumCols + ") {\n                continue;\n              }\n\n              float value = getX(xR, xC, d);\n\n              if (isNaN(value)) {\n                setOutput(value);\n                return;\n              }\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + compareOp_1 + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + filterWidth + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
            return;
        }
        var compareOp = poolType === 'min' ? 'min' : 'max';
        var returnValue = poolType + "(" + poolType + "(" + poolType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') {
            returnValue = "avgValue / " + filterHeight * filterWidth + ".0";
        }
        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        var filterWidthVec4Remainder = filterWidth % 4;
        var updateSnippet = "\n      if (hasNaN(values)) {\n        setOutput(getNaN(values));\n        return;\n      }\n      if (" + isAvgPool + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + xNumCols + ") {\n          return initializationValue;\n        }\n        return getX(xR, xC, d);\n      }\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d = coords.z;\n\n        ivec2 xRCCorner = coords.xy * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float avgValue = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidthNearestVec4 + "; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              getValue(xR, xC + 2, d),\n              getValue(xR, xC + 3, d)\n            );\n\n            " + updateSnippet + "\n          }\n\n          int xC = xCCorner + " + filterWidthNearestVec4 + ";\n          if (" + (filterWidthVec4Remainder === 1) + ") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 2) + ") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 3) + ") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              getValue(xR, xC + 2, d),\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          }\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return Pool2DProgram;
}());
exports.Pool2DProgram = Pool2DProgram;
//# sourceMappingURL=pool_gpu.js.map

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ReduceProgram = (function () {
    function ReduceProgram(reduceInfo, reduceType) {
        this.variableNames = ['x'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        var isReduceSum = reduceType === 'sum';
        var initializationValue = '0.0';
        if (!isReduceSum) {
            if (reduceType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        var compareOp = reduceType === 'min' ? 'min' : 'max';
        var returnValue = reduceType + "(" + reduceType + "(" + reduceType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (reduceType === 'sum') {
            returnValue = "sumValue";
        }
        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        var windowSizeVec4Remainder = windowSize % 4;
        var updateSnippet = "\n      if (" + isReduceSum + ") {\n        sumValue += dot(values, ones);\n      } else {\n        if (hasNaN(values)) {\n          setOutput(getNaN(values));\n          return;\n        }\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        var checkOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      ";
        }
        this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + checkOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return ReduceProgram;
}());
exports.ReduceProgram = ReduceProgram;
//# sourceMappingURL=reduce_gpu.js.map

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var webgl_util = __webpack_require__(58);
function getRenderRGBShader(gpgpu, destinationWidth) {
    var fragmentShaderSource = "\n    precision highp float;\n    uniform sampler2D source;\n    varying vec2 resultUV;\n\n    const float destinationWidth = " + destinationWidth + ".0;\n    const float a = 1.0;\n\n    void main() {\n      float xr = floor(resultUV.s * destinationWidth) * 3.0;\n      vec3 x = xr + vec3(0, 1, 2);\n\n      float sourceWidth = destinationWidth * 3.0;\n      vec3 u = (x + 0.5) / sourceWidth;\n      float v = 1.0 - resultUV.t;\n\n      float r = texture2D(source, vec2(u[0], v)).r;\n      float g = texture2D(source, vec2(u[1], v)).r;\n      float b = texture2D(source, vec2(u[2], v)).r;\n\n      gl_FragColor = vec4(r, g, b, a);\n    }";
    return gpgpu.createProgram(fragmentShaderSource);
}
exports.getRenderRGBShader = getRenderRGBShader;
function renderToCanvas(gpgpu, renderShader, sourceTex) {
    webgl_util.bindCanvasToFramebuffer(gpgpu.gl);
    renderToFramebuffer(gpgpu, renderShader, sourceTex);
}
exports.renderToCanvas = renderToCanvas;
function renderToFramebuffer(gpgpu, renderShader, sourceTex) {
    gpgpu.setProgram(renderShader);
    var sourceSamplerLocation = webgl_util.getProgramUniformLocationOrThrow(gpgpu.gl, renderShader, 'source');
    gpgpu.setInputMatrixTexture(sourceTex, sourceSamplerLocation, 0);
    gpgpu.executeProgram();
}
exports.renderToFramebuffer = renderToFramebuffer;
//# sourceMappingURL=render_ndarray_gpu_util.js.map

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinear3DProgram = (function () {
    function ResizeBilinear3DProgram(inputShape, outputDimensionsRowCol, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var depth = inputShape[2];
        this.outputShape =
            [outputDimensionsRowCol[0], outputDimensionsRowCol[1], depth];
        var effectiveInputShape = alignCorners ?
            [inputShape[0] - 1, inputShape[1] - 1, depth] :
            inputShape;
        var effectiveOutputShape = alignCorners ?
            [this.outputShape[0] - 1, this.outputShape[1] - 1, depth] :
            this.outputShape;
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInputShape[0] / effectiveOutputShape[0] + ",\n          " + effectiveInputShape[1] / effectiveOutputShape[1] + ");\n      const vec2 inputShapeRC = vec2(" + inputShape[0] + ".0, " + inputShape[1] + ".0);\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        ivec2 yRC = coords.xy;\n        int d = coords.z;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeBilinear3DProgram;
}());
exports.ResizeBilinear3DProgram = ResizeBilinear3DProgram;
//# sourceMappingURL=resize_bilinear_gpu.js.map

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = __webpack_require__(66);
var SliceProgram = (function () {
    function SliceProgram(destSize) {
        this.variableNames = ['source'];
        this.outputShape = destSize;
        this.rank = destSize.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getCoords(this.rank);
        this.userCode = "\n      uniform " + dtype + " start;\n\n      void main() {\n        " + dtype + " sourceLoc = start + getOutputCoords();\n        setOutput(getSource(" + sourceCoords + "));\n      }\n    ";
    }
    SliceProgram.prototype.getCustomSetupFunc = function (start) {
        var _this = this;
        if (start.length !== this.rank) {
            throw Error("The rank (" + this.rank + ") of the program must match the " +
                ("length of start (" + start.length + ")"));
        }
        return function (gpgpu, webGLProgram) {
            if (_this.startLoc == null) {
                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                if (_this.startLoc == null) {
                    return;
                }
            }
            if (_this.rank === 1) {
                gpgpu.gl.uniform1i(_this.startLoc, start[0]);
            }
            else if (_this.rank === 2) {
                gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);
            }
            else if (_this.rank === 3) {
                gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);
            }
            else if (_this.rank === 4) {
                gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);
            }
            else {
                throw Error("Slicing for rank " + _this.rank + " is not yet supported");
            }
        };
    };
    return SliceProgram;
}());
exports.SliceProgram = SliceProgram;
function getCoords(rank) {
    if (rank === 1) {
        return 'sourceLoc';
    }
    else if (rank === 2) {
        return 'sourceLoc.x, sourceLoc.y';
    }
    else if (rank === 3) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z';
    }
    else if (rank === 4) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';
    }
    else {
        throw Error("Slicing for rank " + rank + " is not yet supported");
    }
}
//# sourceMappingURL=slice_gpu.js.map

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TextureManager = (function () {
    function TextureManager(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextureCount = {};
    }
    TextureManager.prototype.acquireTexture = function (shapeRC) {
        var shapeKey = getKeyFromTextureShape(shapeRC);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextureCount)) {
            this.usedTextureCount[shapeKey] = 0;
        }
        this.usedTextureCount[shapeKey]++;
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this.log();
            return this.freeTextures[shapeKey].shift();
        }
        this.numUsedTextures++;
        this.log();
        return this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
    };
    TextureManager.prototype.releaseTexture = function (texture, shape) {
        var shapeKey = getKeyFromTextureShape(shape);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this.numUsedTextures--;
        this.usedTextureCount[shapeKey]--;
        this.log();
    };
    TextureManager.prototype.log = function () {
        if (!this.logEnabled) {
            return;
        }
        var total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', this.numFreeTextures + " / " + this.numUsedTextures, "(" + total + ")");
    };
    TextureManager.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures;
    };
    TextureManager.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures;
    };
    TextureManager.prototype.dispose = function () {
        for (var shape in this.freeTextures) {
            if (this.freeTextures.hasOwnProperty(shape)) {
                for (var i = 0; i < this.freeTextures[shape].length; i++) {
                    this.gpgpu.deleteMatrixTexture(this.freeTextures[shape][i]);
                }
            }
        }
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;
function getKeyFromTextureShape(shapeRowsCol) {
    return shapeRowsCol[0] + "_" + shapeRowsCol[1];
}
//# sourceMappingURL=texture_manager.js.map

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = __webpack_require__(66);
var TileProgram = (function () {
    function TileProgram(aShape, reps) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return TileProgram;
}());
exports.TileProgram = TileProgram;
function getSourceCoords(aShape) {
    var rank = aShape.length;
    if (rank > 4) {
        throw Error("Tile for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "imod(resRC, " + aShape[0] + ")";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        sourceCoords.push("imod(" + currentCoords[i] + ", " + aShape[i] + ")");
    }
    return sourceCoords.join();
}
//# sourceMappingURL=tile_gpu.js.map

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = __webpack_require__(66);
var TransposeProgram = (function () {
    function TransposeProgram(aShape, newDim) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var switched = getSwitchedCoords(newDim);
        this.userCode = "\n    void main() {\n      " + dtype + " resRC = getOutputCoords();\n      setOutput(getA(" + switched + "));\n    }\n    ";
    }
    return TransposeProgram;
}());
exports.TransposeProgram = TransposeProgram;
function getSwitchedCoords(newDim) {
    var rank = newDim.length;
    if (rank > 4) {
        throw Error("Transpose for rank " + rank + " is not yet supported");
    }
    var originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var switchedCoords = new Array(rank);
    for (var i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
}
//# sourceMappingURL=transpose_gpu.js.map

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var environment = __webpack_require__(32);
var environment_1 = __webpack_require__(32);
var math_cpu_1 = __webpack_require__(154);
var math_gpu_1 = __webpack_require__(155);
var util = __webpack_require__(4);
exports.TEST_EPSILON = 1e-2;
function mean(values) {
    var sum = 0;
    for (var i = 0; i < values.length; i++) {
        sum += values[i];
    }
    return sum / values.length;
}
exports.mean = mean;
function standardDeviation(values, mean) {
    var squareDiffSum = 0;
    for (var i = 0; i < values.length; i++) {
        var diff = values[i] - mean;
        squareDiffSum += diff * diff;
    }
    return Math.sqrt(squareDiffSum / values.length);
}
exports.standardDeviation = standardDeviation;
function kurtosis(values) {
    var valuesMean = mean(values);
    var n = values.length;
    var sum2 = 0;
    var sum4 = 0;
    for (var i = 0; i < n; i++) {
        var v = values[i] - valuesMean;
        sum2 += Math.pow(v, 2);
        sum4 += Math.pow(v, 4);
    }
    return (1 / n) * sum4 / Math.pow((1 / n) * sum2, 2) - 3;
}
exports.kurtosis = kurtosis;
function skewness(values) {
    var valuesMean = mean(values);
    var n = values.length;
    var sum2 = 0;
    var sum3 = 0;
    var i = -1;
    while (++i < n) {
        var v = values[i] - valuesMean;
        sum2 += Math.pow(v, 2);
        sum3 += Math.pow(v, 3);
    }
    return (1 / n) * sum3 / Math.pow((1 / (n - 1)) * sum2, 3 / 2);
}
exports.skewness = skewness;
function jarqueBeraNormalityTest(values) {
    var s = skewness(values);
    var k = kurtosis(values);
    var jb = values.length * ((Math.pow(s, 2) / 6) + (Math.pow(k, 2) / 24));
    var CHI_SQUARE_2DEG = 5.991;
    if (jb > CHI_SQUARE_2DEG) {
        throw new Error("Invalid p-value for JB: " + jb);
    }
}
exports.jarqueBeraNormalityTest = jarqueBeraNormalityTest;
function expectArrayInMeanStdRange(actual, expectedMean, expectedStdDev, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    var actualMean = mean(actual);
    expectNumbersClose(actualMean, expectedMean, epsilon);
    expectNumbersClose(standardDeviation(actual, actualMean), expectedStdDev, epsilon);
}
exports.expectArrayInMeanStdRange = expectArrayInMeanStdRange;
function expectArraysClose(actual, expected, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    var aType = actual.constructor.name;
    var bType = expected.constructor.name;
    if (aType !== bType) {
        throw new Error("Arrays are of different type " + aType + " vs " + bType);
    }
    if (actual.length !== expected.length) {
        throw new Error("Matrices have different lengths (" + actual.length + " vs " +
            (expected.length + ")."));
    }
    for (var i = 0; i < expected.length; ++i) {
        var a = actual[i];
        var e = expected[i];
        if (!areClose(a, e, epsilon)) {
            var actualStr = "actual[" + i + "] === " + a;
            var expectedStr = "expected[" + i + "] === " + e;
            throw new Error('Arrays differ: ' + actualStr + ', ' + expectedStr);
        }
    }
}
exports.expectArraysClose = expectArraysClose;
function expectNumbersClose(a, e, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!areClose(a, e, epsilon)) {
        throw new Error("Numbers differ: actual === " + a + ", expected === " + e);
    }
}
exports.expectNumbersClose = expectNumbersClose;
function areClose(a, e, epsilon) {
    if (isNaN(a) && isNaN(e)) {
        return true;
    }
    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
        return false;
    }
    return true;
}
function expectValuesInRange(actual, low, high) {
    for (var i = 0; i < actual.length; i++) {
        if (actual[i] < low || actual[i] > high) {
            throw new Error("Value out of range:" + actual[i] + " low: " + low + ", high: " + high);
        }
    }
}
exports.expectValuesInRange = expectValuesInRange;
function randomArrayInRange(n, minValue, maxValue) {
    var v = new Float32Array(n);
    var range = maxValue - minValue;
    for (var i = 0; i < n; ++i) {
        v[i] = (Math.random() * range) + minValue;
    }
    return v;
}
exports.randomArrayInRange = randomArrayInRange;
function makeIdentity(n) {
    var i = new Float32Array(n * n);
    for (var j = 0; j < n; ++j) {
        i[(j * n) + j] = 1;
    }
    return i;
}
exports.makeIdentity = makeIdentity;
function cpuMultiplyMatrix(a, aRow, aCol, b, bRow, bCol) {
    var result = new Float32Array(aRow * bCol);
    for (var r = 0; r < aRow; ++r) {
        var aOffset = (r * aCol);
        var cOffset = (r * bCol);
        for (var c = 0; c < bCol; ++c) {
            var d = 0;
            for (var k = 0; k < aCol; ++k) {
                d += a[aOffset + k] * b[(k * bCol) + c];
            }
            result[cOffset + c] = d;
        }
    }
    return result;
}
exports.cpuMultiplyMatrix = cpuMultiplyMatrix;
function cpuDotProduct(a, b) {
    if (a.length !== b.length) {
        throw new Error('cpuDotProduct: incompatible vectors.');
    }
    var d = 0;
    for (var i = 0; i < a.length; ++i) {
        d += a[i] * b[i];
    }
    return d;
}
exports.cpuDotProduct = cpuDotProduct;
function describeMathCPU(name, tests, featuresList) {
    var testNameBase = 'math_cpu.' + name;
    describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () { return new math_cpu_1.NDArrayMathCPU(); }, features); }, featuresList);
}
exports.describeMathCPU = describeMathCPU;
function describeMathGPU(name, tests, featuresList) {
    var testNameBase = 'math_gpu.' + name;
    describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () { return new math_gpu_1.NDArrayMathGPU(); }, features); }, featuresList);
}
exports.describeMathGPU = describeMathGPU;
function describeCustom(name, tests, featuresList, customBeforeEach, customAfterEach) {
    describeWithFeaturesAndExecutor(name, [tests], function (testName, tests, features) { return executeTests(testName, tests, features, customBeforeEach, customAfterEach); }, featuresList);
}
exports.describeCustom = describeCustom;
function describeWithFeaturesAndExecutor(testNameBase, tests, executor, featuresList) {
    if (featuresList != null) {
        featuresList.forEach(function (features) {
            var testName = testNameBase + ' ' + JSON.stringify(features);
            executor(testName, tests, features);
        });
    }
    else {
        executor(testNameBase, tests);
    }
}
var PROMISE_IT = function (name, testFunc) {
    it(name, function (done) {
        var result = testFunc();
        if (result instanceof Promise) {
            result.then(done, function (e) {
                fail(e);
                done();
            });
        }
        else {
            done();
        }
    });
};
function executeMathTests(testName, tests, mathFactory, features) {
    var math;
    var customBeforeEach = function () {
        math = mathFactory();
        math.startScope();
    };
    var customAfterEach = function () {
        math.endScope(null);
        math.dispose();
    };
    var customIt = function (name, testFunc) {
        PROMISE_IT(name, function () { return testFunc(math); });
    };
    executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt);
}
exports.executeMathTests = executeMathTests;
function executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt) {
    if (customIt === void 0) { customIt = PROMISE_IT; }
    describe(testName, function () {
        beforeEach(function () {
            if (features != null) {
                environment.setEnvironment(new environment_1.Environment(features));
            }
            if (customBeforeEach != null) {
                customBeforeEach();
            }
        });
        afterEach(function () {
            if (customAfterEach != null) {
                customAfterEach();
            }
            if (features != null) {
                environment.setEnvironment(new environment_1.Environment());
            }
        });
        tests.forEach(function (test) { return test(customIt); });
    });
}
exports.executeTests = executeTests;
function assertIsNan(val, dtype) {
    if (!util.isValNaN(val, dtype)) {
        throw new Error("Value " + val + " does not represent NaN for dtype " + dtype);
    }
}
exports.assertIsNan = assertIsNan;
//# sourceMappingURL=test_util.js.map

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.3.11';
exports.version = version;
//# sourceMappingURL=version.js.map

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(433);

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(435);

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(438);

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(437);

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(436);

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(434);

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(439);

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(22) && __webpack_require__(59)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  __webpack_require__(22)   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60)(module)))

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(22) && __webpack_require__(59)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  __webpack_require__(22)   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60)(module)))

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(22) && __webpack_require__(59)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  __webpack_require__(22)   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60)(module)))

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(22) && __webpack_require__(59)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  __webpack_require__(22)   // present with an AMD loader
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60)(module)))

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(22) && __webpack_require__(59)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  __webpack_require__(22)   // present with an AMD loader
);


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60)(module)))

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(22) && __webpack_require__(59)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return impl; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  __webpack_require__(22)   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60)(module)))

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(440);
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return seedrandom; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ }),
/* 440 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(161);
module.exports = __webpack_require__(160);


/***/ })
/******/ ]);
});